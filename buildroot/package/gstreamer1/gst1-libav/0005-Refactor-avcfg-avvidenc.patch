From 255e2e749f6f2cfe91ab60b0cbfcb1c7f0f11726 Mon Sep 17 00:00:00 2001
From: Mathieu Duponchelle <mathieu@centricular.com>
Date: Wed, 27 Jun 2018 20:41:37 +0200
Subject: [PATCH 5/5] Refactor avcfg / avvidenc

We were previously installing hardcoded properties for all
video encoders, refactor to instead use FFmpeg's AVOption API.

avvidenc still exposes a few properties related to the pass
mechanism: while the AVOption API allows specifying both passes
as flags at the same time, this is not practical in GStreamer's
context, where passes need to be run separately using a stats file.

https://bugzilla.gnome.org/show_bug.cgi?id=792900
---
 ext/libav/gstavcfg.c      | 1326 ++++++++++++-------------------------
 ext/libav/gstavcfg.h      |    2 +-
 ext/libav/gstavcodecmap.c |    2 +-
 ext/libav/gstavvidenc.c   |  254 ++-----
 ext/libav/gstavvidenc.h   |   32 +-
 5 files changed, 474 insertions(+), 1142 deletions(-)

diff --git a/ext/libav/gstavcfg.c b/ext/libav/gstavcfg.c
index 8012531..2139e55 100644
--- a/ext/libav/gstavcfg.c
+++ b/ext/libav/gstavcfg.c
@@ -30,700 +30,313 @@
 #include "gstavcfg.h"
 
 #include <string.h>
+#include <libavutil/opt.h>
 
-/* some enums used in property declarations */
+static GQuark avoption_quark;
+static GHashTable *venc_overrides = NULL;
 
-#define GST_TYPE_FFMPEG_PASS (gst_ffmpeg_pass_get_type ())
-static GType
-gst_ffmpeg_pass_get_type (void)
+static void
+make_venc_overrides (void)
 {
-  static GType ffmpeg_pass_type = 0;
-
-  if (!ffmpeg_pass_type) {
-    static const GEnumValue ffmpeg_passes[] = {
-      {0, "Constant Bitrate Encoding", "cbr"},
-      {AV_CODEC_FLAG_QSCALE, "Constant Quantizer", "quant"},
-      {AV_CODEC_FLAG_PASS1, "VBR Encoding - Pass 1", "pass1"},
-      {AV_CODEC_FLAG_PASS2, "VBR Encoding - Pass 2", "pass2"},
-      {0, NULL, NULL},
-    };
-
-    ffmpeg_pass_type =
-        g_enum_register_static ("GstLibAVEncPass", ffmpeg_passes);
-  }
-
-  return ffmpeg_pass_type;
+  g_assert (!venc_overrides);
+  venc_overrides = g_hash_table_new_full (g_str_hash, g_str_equal,
+      g_free, (GDestroyNotify) gst_structure_free);
+
+  g_hash_table_insert (venc_overrides, g_strdup ("b"),
+      gst_structure_new_empty ("bitrate"));
+  g_hash_table_insert (venc_overrides, g_strdup ("g"),
+      gst_structure_new_empty ("gop-size"));
+  g_hash_table_insert (venc_overrides, g_strdup ("bt"),
+      gst_structure_new_empty ("bitrate-tolerance"));
+  g_hash_table_insert (venc_overrides, g_strdup ("bf"),
+      gst_structure_new_empty ("max-bframes"));
 }
 
-#if 0
-/* some do not support 2-pass */
-#define GST_TYPE_FFMPEG_LIM_PASS (gst_ffmpeg_lim_pass_get_type ())
-static GType
-gst_ffmpeg_lim_pass_get_type (void)
+void
+gst_ffmpeg_cfg_init (void)
 {
-  static GType ffmpeg_lim_pass_type = 0;
-
-  if (!ffmpeg_lim_pass_type) {
-    static const GEnumValue ffmpeg_lim_passes[] = {
-      {0, "Constant Bitrate Encoding", "cbr"},
-      {AV_CODEC_FLAG_QSCALE, "Constant Quantizer", "quant"},
-      {0, NULL, NULL},
-    };
-
-    ffmpeg_lim_pass_type =
-        g_enum_register_static ("GstLibAVEncLimPass", ffmpeg_lim_passes);
-  }
-
-  return ffmpeg_lim_pass_type;
+  avoption_quark = g_quark_from_static_string ("ffmpeg-cfg-param-spec-data");
+  make_venc_overrides ();
 }
-#endif
 
-#define GST_TYPE_FFMPEG_MB_DECISION (gst_ffmpeg_mb_decision_get_type ())
-static GType
-gst_ffmpeg_mb_decision_get_type (void)
+static gint
+cmp_enum_value (GEnumValue * val1, GEnumValue * val2)
 {
-  static GType ffmpeg_mb_decision_type = 0;
-
-  if (!ffmpeg_mb_decision_type) {
-    static const GEnumValue ffmpeg_mb_decisions[] = {
-      {FF_MB_DECISION_SIMPLE, "Use method set by mb-cmp", "simple"},
-      {FF_MB_DECISION_BITS,
-          "Chooses the one which needs the fewest bits aka vhq mode", "bits"},
-      {FF_MB_DECISION_RD, "Rate Distortion", "rd"},
-      {0, NULL, NULL},
-    };
-
-    ffmpeg_mb_decision_type =
-        g_enum_register_static ("GstLibAVEncMBDecision", ffmpeg_mb_decisions);
-  }
-
-  return ffmpeg_mb_decision_type;
+  return val1->value - val2->value;
 }
 
-#define GST_TYPE_FFMPEG_CMP_FUNCTION (gst_ffmpeg_mb_cmp_get_type ())
 static GType
-gst_ffmpeg_mb_cmp_get_type (void)
+register_enum (const AVClass ** obj, const AVOption * top_opt)
 {
-  static GType ffmpeg_mb_cmp_type = 0;
-
-  /* TODO fill out remaining values */
-  if (!ffmpeg_mb_cmp_type) {
-    static const GEnumValue ffmpeg_mb_cmps[] = {
-      {FF_CMP_SAD, "Sum of Absolute Differences", "sad"},
-      {FF_CMP_SSE, "Sum of Squared Errors", "sse"},
-      {FF_CMP_SATD, "Sum of Absolute Hadamard Transformed Differences", "satd"},
-      {FF_CMP_DCT, "Sum of Absolute DCT Transformed Differences", "dct"},
-      {FF_CMP_PSNR, "Sum of the Squared Quantization Errors", "psnr"},
-      {FF_CMP_BIT, "Sum of the Bits needed for the block", "bit"},
-      {FF_CMP_RD, "Rate Distortion optimal", "rd"},
-      {FF_CMP_ZERO, "ZERO", "zero"},
-      {FF_CMP_VSAD, "VSAD", "vsad"},
-      {FF_CMP_VSSE, "VSSE", "vsse"},
-#if 0
-/* economize a bit for now */
-      {FF_CMP_NSSE, "NSSE", "nsse"},
-      {FF_CMP_W53, "W53", "w53"},
-      {FF_CMP_W97, "W97", "w97"},
-#endif
-      {0, NULL, NULL},
-    };
+  const AVOption *opt = NULL;
+  GType res = 0;
+  GArray *values = g_array_new (TRUE, TRUE, sizeof (GEnumValue));
+  gchar *lower_obj_name = g_ascii_strdown ((*obj)->class_name, -1);
+  gchar *enum_name = g_strdup_printf ("%s-%s", lower_obj_name, top_opt->unit);
+  gboolean none_default = TRUE;
 
-    ffmpeg_mb_cmp_type =
-        g_enum_register_static ("GstLibAVCMPFunction", ffmpeg_mb_cmps);
-  }
+  g_strcanon (enum_name, G_CSET_a_2_z G_CSET_DIGITS, '-');
 
-  return ffmpeg_mb_cmp_type;
-}
+  if ((res = g_type_from_name (enum_name)))
+    goto done;
 
-#define GST_TYPE_FFMPEG_DCT_ALGO (gst_ffmpeg_dct_algo_get_type ())
-static GType
-gst_ffmpeg_dct_algo_get_type (void)
-{
-  static GType ffmpeg_dct_algo_type = 0;
-
-  if (!ffmpeg_dct_algo_type) {
-    static const GEnumValue ffmpeg_dct_algos[] = {
-      {FF_DCT_AUTO, "Automatically select a good one", "auto"},
-      {FF_DCT_FASTINT, "Fast Integer", "fastint"},
-      {FF_DCT_INT, "Accurate Integer", "int"},
-      {FF_DCT_MMX, "MMX", "mmx"},
-      {FF_DCT_ALTIVEC, "ALTIVEC", "altivec"},
-      {FF_DCT_FAAN, "FAAN", "faan"},
-      {0, NULL, NULL},
-    };
-
-    ffmpeg_dct_algo_type =
-        g_enum_register_static ("GstLibAVDCTAlgo", ffmpeg_dct_algos);
-  }
+  while ((opt = av_opt_next (obj, opt))) {
+    if (opt->type == AV_OPT_TYPE_CONST && !g_strcmp0 (top_opt->unit, opt->unit)) {
+      GEnumValue val;
 
-  return ffmpeg_dct_algo_type;
-}
+      val.value = opt->default_val.i64;
+      val.value_name = g_strdup (opt->help ? opt->help : opt->name);
+      val.value_nick = g_strdup (opt->name);
 
-#define GST_TYPE_FFMPEG_IDCT_ALGO (gst_ffmpeg_idct_algo_get_type ())
-static GType
-gst_ffmpeg_idct_algo_get_type (void)
-{
-  static GType ffmpeg_idct_algo_type = 0;
-
-  if (!ffmpeg_idct_algo_type) {
-    static const GEnumValue ffmpeg_idct_algos[] = {
-      {FF_IDCT_AUTO, "Automatically select a good one", "auto"},
-      {FF_IDCT_INT, "JPEG reference Integer", "int"},
-      {FF_IDCT_SIMPLE, "Simple", "simple"},
-      {FF_IDCT_SIMPLEMMX, "Simple MMX", "simplemmx"},
-      {FF_IDCT_ARM, "ARM", "arm"},
-      {FF_IDCT_ALTIVEC, "Altivec", "altivec"},
-      {FF_IDCT_SIMPLEARM, "Simple ARM", "simplearm"},
-      {FF_IDCT_XVID, "XVID", "xvid"},
-      {FF_IDCT_SIMPLEARMV5TE, "Simple ARMV5TE", "simplearmv5te"},
-      {FF_IDCT_SIMPLEARMV6, "Simple ARMV6", "simplearmv6"},
-      {FF_IDCT_FAAN, "FAAN", "faan"},
-      {FF_IDCT_SIMPLENEON, "Simple NEON", "simpleneon"},
-      {0, NULL, NULL},
-    };
-
-    ffmpeg_idct_algo_type =
-        g_enum_register_static ("GstLibAVIDCTAlgo", ffmpeg_idct_algos);
-  }
+      if (opt->default_val.i64 == top_opt->default_val.i64)
+        none_default = FALSE;
 
-  return ffmpeg_idct_algo_type;
-}
+      g_array_append_val (values, val);
+    }
+  }
 
-#define GST_TYPE_FFMPEG_QUANT_TYPE (gst_ffmpeg_quant_type_get_type ())
-static GType
-gst_ffmpeg_quant_type_get_type (void)
-{
-  static GType ffmpeg_quant_type_type = 0;
+  if (values->len) {
+    guint i = 0;
+    gint cur_val;
+    gboolean cur_val_set = FALSE;
+
+    /* Sometimes ffmpeg sets a default value but no named constants with
+     * this value, we assume this means "unspecified" and add our own
+     */
+    if (none_default) {
+      GEnumValue val;
+
+      val.value = top_opt->default_val.i64;
+      val.value_name = g_strdup ("Unspecified");
+      val.value_nick = g_strdup ("unknown");
+      g_array_append_val (values, val);
+    }
 
-  if (!ffmpeg_quant_type_type) {
-    static const GEnumValue ffmpeg_quant_types[] = {
-      {0, "H263 quantization", "h263"},
-      {1, "MPEG quantization", "mpeg"},
-      {0, NULL, NULL},
-    };
+    g_array_sort (values, (GCompareFunc) cmp_enum_value);
+
+    /* Dedup, easy once sorted
+     * We do this because ffmpeg can expose multiple names for the
+     * same constant, the way we expose enums makes this too confusing.
+     */
+    while (i < values->len) {
+      if (cur_val_set) {
+        if (g_array_index (values, GEnumValue, i).value == cur_val) {
+          g_array_remove_index (values, i);
+        } else {
+          cur_val = g_array_index (values, GEnumValue, i).value;
+          i++;
+        }
+      } else {
+        cur_val = g_array_index (values, GEnumValue, i).value;
+        cur_val_set = TRUE;
+        i++;
+      }
+    }
 
-    ffmpeg_quant_type_type =
-        g_enum_register_static ("GstLibAVEncQuantTypes", ffmpeg_quant_types);
+    res =
+        g_enum_register_static (enum_name, &g_array_index (values, GEnumValue,
+            0));
   }
 
-  return ffmpeg_quant_type_type;
+done:
+  g_free (lower_obj_name);
+  g_free (enum_name);
+  return res;
 }
 
-#define GST_TYPE_FFMPEG_PRE_ME (gst_ffmpeg_pre_me_get_type ())
-static GType
-gst_ffmpeg_pre_me_get_type (void)
+static gint
+cmp_flags_value (GEnumValue * val1, GEnumValue * val2)
 {
-  static GType ffmpeg_pre_me_type = 0;
-
-  if (!ffmpeg_pre_me_type) {
-    static const GEnumValue ffmpeg_pre_mes[] = {
-      {0, "Disabled", "off"},
-      {1, "Only after I-frames", "key"},
-      {2, "Always", "all"},
-      {0, NULL, NULL}
-    };
-
-    ffmpeg_pre_me_type =
-        g_enum_register_static ("GstLibAVEncPreME", ffmpeg_pre_mes);
-  }
-
-  return ffmpeg_pre_me_type;
+  return val1->value - val2->value;
 }
 
-#define GST_TYPE_FFMPEG_PRED_METHOD (gst_ffmpeg_pred_method_get_type ())
 static GType
-gst_ffmpeg_pred_method_get_type (void)
+register_flags (const AVClass ** obj, const AVOption * top_opt)
 {
-  static GType ffmpeg_pred_method = 0;
-
-  if (!ffmpeg_pred_method) {
-    static const GEnumValue ffmpeg_pred_methods[] = {
-      {FF_PRED_LEFT, "Left", "left"},
-      {FF_PRED_PLANE, "Plane", "plane"},
-      {FF_PRED_MEDIAN, "Median", "median"},
-      {0, NULL, NULL}
-    };
-
-    ffmpeg_pred_method =
-        g_enum_register_static ("GstLibAVEncPredMethod", ffmpeg_pred_methods);
-  }
+  const AVOption *opt = NULL;
+  GType res = 0;
+  GArray *values = g_array_new (TRUE, TRUE, sizeof (GEnumValue));
+  gchar *lower_obj_name = g_ascii_strdown ((*obj)->class_name, -1);
+  gchar *flags_name = g_strdup_printf ("%s-%s", lower_obj_name, top_opt->unit);
+
+  g_strcanon (flags_name, G_CSET_a_2_z G_CSET_DIGITS, '-');
+
+  if ((res = g_type_from_name (flags_name)))
+    goto done;
+
+  while ((opt = av_opt_next (obj, opt))) {
+    if (opt->type == AV_OPT_TYPE_CONST && !g_strcmp0 (top_opt->unit, opt->unit)) {
+      GFlagsValue val;
+
+      /* We expose pass manually, hardcoding this isn't very nice, but
+       * I don't expect we want to do that sort of things often enough
+       * to warrant a general mechanism
+       */
+      if (!g_strcmp0 (top_opt->name, "flags")) {
+        if (opt->default_val.i64 == AV_CODEC_FLAG_QSCALE ||
+            opt->default_val.i64 == AV_CODEC_FLAG_PASS1 ||
+            opt->default_val.i64 == AV_CODEC_FLAG_PASS2) {
+          continue;
+        }
+      }
 
-  return ffmpeg_pred_method;
-}
+      val.value = opt->default_val.i64;
+      val.value_name = g_strdup (opt->help ? opt->help : opt->name);
+      val.value_nick = g_strdup (opt->name);
 
-#define GST_TYPE_FFMPEG_FLAGS (gst_ffmpeg_flags_get_type())
-static GType
-gst_ffmpeg_flags_get_type (void)
-{
-  static GType ffmpeg_flags_type = 0;
-
-  /* FIXME: This needs some serious resyncing with avcodec.h */
-  if (!ffmpeg_flags_type) {
-    static const GFlagsValue ffmpeg_flags[] = {
-      {AV_CODEC_FLAG_QSCALE, "Use fixed qscale", "qscale"},
-      {AV_CODEC_FLAG_4MV, "Allow 4 MV per MB", "4mv"},
-      {AV_CODEC_FLAG_QPEL, "Quartel Pel Motion Compensation", "qpel"},
-      {CODEC_FLAG_GMC, "GMC", "gmc"},
-      {CODEC_FLAG_MV0, "Always try a MB with MV (0,0)", "mv0"},
-      {AV_CODEC_FLAG_LOOP_FILTER, "Loop filter", "loop-filter"},
-      {AV_CODEC_FLAG_GRAY, "Only decode/encode grayscale", "gray"},
-      {CODEC_FLAG_NORMALIZE_AQP,
-          "Normalize Adaptive Quantization (masking, etc)", "aqp"},
-      {AV_CODEC_FLAG_GLOBAL_HEADER,
-            "Global headers in extradata instead of every keyframe",
-          "global-headers"},
-      {AV_CODEC_FLAG_AC_PRED,
-            "H263 Advanced Intra Coding / MPEG4 AC prediction",
-          "aic"},
-      {AV_CODEC_FLAG_CLOSED_GOP, "Closed GOP", "closedgop"},
-      {0, NULL, NULL},
-    };
-
-    ffmpeg_flags_type = g_flags_register_static ("GstLibAVFlags", ffmpeg_flags);
+      g_array_append_val (values, val);
+    }
   }
 
-  return ffmpeg_flags_type;
-}
-
-/* provides additional info to attach to a property */
+  if (values->len) {
+    g_array_sort (values, (GCompareFunc) cmp_flags_value);
 
-typedef struct _GParamSpecData GParamSpecData;
+    res =
+        g_flags_register_static (flags_name, &g_array_index (values,
+            GFlagsValue, 0));
+  }
 
-struct _GParamSpecData
-{
-  /* offset of member in the element struct that stores the property */
-  guint offset;
-
-  /* size of the above member */
-  guint size;
-
-  /* if TRUE, try to get the default from lavc and ignore the paramspec default */
-  gboolean lavc_default;
-
-  /* these lists are arrays terminated by AV_CODEC_ID_NONE entry:
-   * property applies to a codec if it's not in the exclude_list
-   * and in exclude_list (or the latter is NULL) */
-  gint *include_list;
-  gint *exclude_list;
-};
-
-/* properties whose member offset is higher than the config base
- * can be copied directly at context configuration time;
- * and can also retrieve a default value from lavc */
-#define CONTEXT_CONFIG_OFFSET   G_STRUCT_OFFSET (GstFFMpegVidEnc, config)
-
-/* additional info is named pointer specified by the quark */
-static GQuark quark;
-
-/* central configuration store:
- * list of GParamSpec's with GParamSpecData attached as named pointer */
-static GList *property_list;
-
-/* add the GParamSpec pspec to store with GParamSpecData
- * constructed from struct_type, member, default and include and exclude */
-#define gst_ffmpeg_add_pspec_full(pspec, store, struct_type, member,    \
-    default, include, exclude)                                          \
-G_STMT_START {                                                          \
-  GParamSpecData *_qdata = g_new0 (GParamSpecData, 1);                  \
-  GstFFMpegVidEnc _enc;                                                    \
-  _qdata->offset = G_STRUCT_OFFSET (struct_type, member);               \
-  _qdata->size = sizeof (_enc.member);                                  \
-  _qdata->lavc_default = default;                                       \
-  _qdata->include_list = include;                                       \
-  _qdata->exclude_list = exclude;                                       \
-  g_param_spec_set_qdata_full (pspec, quark, _qdata, g_free);           \
-  store = g_list_append (store, pspec);                                 \
-} G_STMT_END
-
-#define gst_ffmpeg_add_pspec(pspec, member, default, include, exclude)       \
-  gst_ffmpeg_add_pspec_full (pspec, property_list, GstFFMpegVidEnc, member,     \
-      default, include, exclude)
-
-/* ==== BEGIN CONFIGURATION SECTION ==== */
-
-/* some typical include and exclude lists; modify and/or add where needed */
-
-static gint mpeg[] = {
-  AV_CODEC_ID_MPEG4,
-  AV_CODEC_ID_MSMPEG4V1,
-  AV_CODEC_ID_MSMPEG4V2,
-  AV_CODEC_ID_MSMPEG4V3,
-  AV_CODEC_ID_MPEG1VIDEO,
-  AV_CODEC_ID_MPEG2VIDEO,
-  AV_CODEC_ID_H263P,
-  AV_CODEC_ID_FLV1,
-  AV_CODEC_ID_H263,
-  AV_CODEC_ID_NONE
-};
-
-static gint huffyuv[] = {
-  AV_CODEC_ID_HUFFYUV,
-  AV_CODEC_ID_FFVHUFF,
-  AV_CODEC_ID_NONE
-};
-
-/* Properties should be added here for registration into the config store.
- * Note that some may occur more than once, with different include/exclude lists,
- * as some may require different defaults for different codecs,
- * or some may have slightly varying enum-types with more or less options.
- * The enum-types themselves should be declared above. */
-void
-gst_ffmpeg_cfg_init (void)
-{
-  GParamSpec *pspec;
-
-  /* initialize global config vars */
-  quark = g_quark_from_static_string ("ffmpeg-cfg-param-spec-data");
-  property_list = NULL;
-
-  /* list properties here */
-  pspec = g_param_spec_enum ("pass", "Encoding pass/type",
-      "Encoding pass/type", GST_TYPE_FFMPEG_PASS, 0,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, pass, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_float ("quantizer", "Constant Quantizer",
-      "Constant Quantizer", 0, 30, 0.01f,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, quantizer, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_string ("multipass-cache-file", "Multipass Cache File",
-      "Filename for multipass cache file", "stats.log",
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, filename, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int ("bitrate-tolerance", "Bitrate Tolerance",
-      "Number of bits the bitstream is allowed to diverge from the reference",
-      0, 100000000, 8000000, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.bit_rate_tolerance, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_enum ("mb-decision", "Macroblock Decision",
-      "Macroblok Decision Mode",
-      GST_TYPE_FFMPEG_MB_DECISION, FF_CMP_SAD,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.mb_decision, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_enum ("mb-cmp", "Macroblock Compare Function",
-      "Macroblok Compare Function",
-      GST_TYPE_FFMPEG_CMP_FUNCTION, FF_CMP_SAD,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.mb_cmp, FALSE, mpeg, NULL);
-
-  pspec =
-      g_param_spec_enum ("me-pre-cmp",
-      "Motion Estimation Pre Pass Compare Function",
-      "Motion Estimation Pre Pass Compare Function",
-      GST_TYPE_FFMPEG_CMP_FUNCTION, FF_CMP_SAD,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.me_pre_cmp, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_enum ("me-cmp", "Motion Estimation Compare Function",
-      "Motion Estimation Compare Function",
-      GST_TYPE_FFMPEG_CMP_FUNCTION, FF_CMP_SAD,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.me_cmp, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_enum ("me-sub-cmp",
-      "Subpixel Motion Estimation Compare Function",
-      "Subpixel Motion Estimation Compare Function",
-      GST_TYPE_FFMPEG_CMP_FUNCTION, FF_CMP_SAD,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.me_sub_cmp, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_enum ("ildct-cmp", "Interlaced DCT Compare Function",
-      "Interlaced DCT Compare Function",
-      GST_TYPE_FFMPEG_CMP_FUNCTION, FF_CMP_VSAD,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.ildct_cmp, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_enum ("dct-algo", "DCT Algorithm",
-      "DCT Algorithm",
-      GST_TYPE_FFMPEG_DCT_ALGO, FF_DCT_AUTO,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.dct_algo, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_enum ("idct-algo", "IDCT Algorithm",
-      "IDCT Algorithm",
-      GST_TYPE_FFMPEG_IDCT_ALGO, FF_IDCT_AUTO,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.idct_algo, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_enum ("quant-type", "Quantizer Type",
-      "Quantizer Type", GST_TYPE_FFMPEG_QUANT_TYPE, 0,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.mpeg_quant, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int ("qmin", "Minimum Quantizer",
-      "Minimum Quantizer", 1, 31, 2,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.qmin, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int ("qmax", "Maximum Quantizer",
-      "Maximum Quantizer", 1, 31, 31,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.qmax, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int ("max-qdiff", "Maximum Quantizer Difference",
-      "Maximum Quantizer Difference between frames",
-      1, 31, 3, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.max_qdiff, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int ("lmin", "Minimum Lagrange Multiplier",
-      "Minimum Lagrange Multiplier", 1, 31, 2,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, lmin, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int ("lmax", "Maximum Lagrange Multiplier",
-      "Maximum Lagrange Multiplier", 1, 31, 31,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, lmax, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_float ("qcompress", "Quantizer Change",
-      "Quantizer Change between easy and hard scenes",
-      0, 1.0f, 0.5f, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.qcompress, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_float ("qblur", "Quantizer Smoothing",
-      "Quantizer Smoothing over time", 0, 1.0f, 0.5f,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.qblur, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_float ("rc-qsquish", "Ratecontrol Limiting Method",
-      "0 means limit by clipping, otherwise use nice continuous function",
-      0, 99.0f, 1.0f, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.rc_qsquish, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_float ("rc-qmod-amp", "Ratecontrol Mod",
-      "Ratecontrol Mod", 0, 99.0f, 0,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.rc_qmod_amp, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int ("rc-qmod-freq", "Ratecontrol Freq",
-      "Ratecontrol Freq", 0, 0, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.rc_qmod_freq, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int ("rc-buffer-size", "Ratecontrol Buffer Size",
-      "Decoder bitstream buffer size", 0, G_MAXINT, 0,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.rc_buffer_size, FALSE, mpeg, NULL);
-
-  pspec =
-      g_param_spec_float ("rc-buffer-aggressivity",
-      "Ratecontrol Buffer Aggressivity", "Ratecontrol Buffer Aggressivity", 0,
-      99.0f, 1.0f, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.rc_buffer_aggressivity, FALSE, mpeg,
-      NULL);
-
-#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT (57, 3, 0)
-  pspec = g_param_spec_int ("rc-max-rate", "Ratecontrol Maximum Bitrate",
-      "Ratecontrol Maximum Bitrate", 0, G_MAXINT, 0,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-#else
-  pspec = g_param_spec_int64 ("rc-max-rate", "Ratecontrol Maximum Bitrate",
-      "Ratecontrol Maximum Bitrate", 0, G_MAXINT64, 0,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-#endif
-  gst_ffmpeg_add_pspec (pspec, config.rc_max_rate, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int64 ("rc-min-rate", "Ratecontrol Minimum Bitrate",
-      "Ratecontrol Minimum Bitrate", 0, G_MAXINT64, 0,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.rc_min_rate, FALSE, mpeg, NULL);
-
-  pspec =
-      g_param_spec_float ("rc-initial-cplx",
-      "Initial Complexity for Pass 1 Ratecontrol",
-      "Initial Complexity for Pass 1 Ratecontrol", 0, 9999999.0f, 0,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.rc_initial_cplx, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_string ("rc-eq", "Ratecontrol Equation",
-      "Ratecontrol Equation", "tex^qComp",
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.rc_eq, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_float ("b-quant-factor", "B-Quantizer Factor",
-      "Factor in B-Frame Quantizer Computation",
-      -31.0f, 31.0f, 1.25f, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.b_quant_factor, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_float ("b-quant-offset", "B-Quantizer Offset",
-      "Offset in B-Frame Quantizer Computation",
-      0.0f, 31.0f, 1.25f, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.b_quant_offset, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_float ("i-quant-factor", "I-Quantizer Factor",
-      "Factor in P-Frame Quantizer Computation",
-      -31.0f, 31.0f, 0.8f, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.i_quant_factor, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_float ("i-quant-offset", "I-Quantizer Offset",
-      "Offset in P-Frame Quantizer Computation",
-      0.0f, 31.0f, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.i_quant_offset, FALSE, mpeg, NULL);
-
-  /* note overlap with gop-size; 0 means do not override */
-  pspec = g_param_spec_int ("max-key-interval", "Maximum Key Interval",
-      "Maximum number of frames between two keyframes (< 0 is in sec)",
-      -100, G_MAXINT, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, max_key_interval, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_float ("lumi-masking", "Luminance Masking",
-      "Luminance Masking", -1.0f, 1.0f, 0.0f,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.lumi_masking, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_float ("dark-masking", "Darkness Masking",
-      "Darkness Masking", -1.0f, 1.0f, 0.0f,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.dark_masking, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_float ("temporal-cplx-masking",
-      "Temporal Complexity Masking",
-      "Temporal Complexity Masking", -1.0f, 1.0f, 0.0f,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.temporal_cplx_masking, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_float ("spatial-cplx-masking",
-      "Spatial Complexity Masking",
-      "Spatial Complexity Masking", -1.0f, 1.0f, 0.0f,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.spatial_cplx_masking, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_float ("p-masking", "P Block Masking",
-      "P Block  Masking", -1.0f, 1.0f, 0.0f,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.p_masking, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int ("dia-size",
-      "Motion Estimation Diamond Size/Shape",
-      "Motion Estimation Diamond Size/Shape",
-      -2000, 2000, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.dia_size, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int ("pre-dia-size",
-      "Motion Estimation Pre Pass Diamond Size/Shape",
-      "Motion Estimation Diamond Size/Shape",
-      -2000, 2000, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.pre_dia_size, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int ("last-predictor-count",
-      "Last Predictor Count",
-      "Amount of previous Motion Vector predictors",
-      0, 2000, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.last_predictor_count, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_enum ("pre-me",
-      "Pre Pass for Motion Estimation",
-      "Pre Pass for Motion Estimation",
-      GST_TYPE_FFMPEG_PRE_ME, 1, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.pre_me, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int ("me-subpel-quality",
-      "Motion Estimation Subpixel Quality",
-      "Motion Estimation Subpixel Refinement Quality",
-      0, 8, 8, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.me_subpel_quality, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int ("me-range",
-      "Motion Estimation Range",
-      "Motion Estimation search range in subpel units",
-      0, 16000, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.me_range, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int ("intra-quant-bias",
-      "Intra Quantizer Bias",
-      "Intra Quantizer Bias",
-      -1000000, 1000000, FF_DEFAULT_QUANT_BIAS,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.intra_quant_bias, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int ("inter-quant-bias",
-      "Inter Quantizer Bias",
-      "Inter Quantizer Bias",
-      -1000000, 1000000, FF_DEFAULT_QUANT_BIAS,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.inter_quant_bias, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int ("noise-reduction",
-      "Noise Reduction",
-      "Noise Reduction Strength", 0, 1000000, 0,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.noise_reduction, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int ("intra-dc-precision",
-      "Intra DC precision",
-      "Precision of the Intra DC coefficient - 8", 0, 16, 0,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.intra_dc_precision, FALSE, mpeg, NULL);
-
-  /* TODO skipped coder_type, context_model, inter_threshold, scenechange_threshold */
-
-  pspec = g_param_spec_flags ("flags", "Flags",
-      "Flags", GST_TYPE_FFMPEG_FLAGS, 0,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.flags, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_boolean ("interlaced", "Interlaced Material",
-      "Interlaced Material", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, interlaced, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_int ("max-bframes", "Max B-Frames",
-      "Maximum B-frames in a row", 0, INT_MAX, 0,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.max_b_frames, FALSE, mpeg, NULL);
-
-  pspec = g_param_spec_enum ("prediction-method", "Prediction Method",
-      "Prediction Method",
-      GST_TYPE_FFMPEG_PRED_METHOD, FF_PRED_LEFT,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.prediction_method, FALSE, huffyuv, NULL);
-  pspec = g_param_spec_int ("trellis", "Trellis Quantization",
-      "Trellis RD quantization", 0, 1, 1,
-      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.trellis, FALSE, mpeg, NULL);
+done:
+  g_free (lower_obj_name);
+  g_free (flags_name);
+  return res;
 }
 
-/* ==== END CONFIGURATION SECTION ==== */
+static guint
+install_opts (GObjectClass * gobject_class, const AVClass ** obj, guint prop_id,
+    gint flags, const gchar * extra_help, GHashTable * overrides)
+{
+  const AVOption *opt = NULL;
+
+  while ((opt = av_opt_next (obj, opt))) {
+    GParamSpec *pspec = NULL;
+    AVOptionRanges *r;
+    gdouble min = G_MINDOUBLE;
+    gdouble max = G_MAXDOUBLE;
+    gchar *help;
+    const gchar *name;
+
+    if (overrides && g_hash_table_contains (overrides, opt->name)) {
+      name =
+          gst_structure_get_name (g_hash_table_lookup (overrides, opt->name));
+    } else {
+      name = opt->name;
+    }
 
+    if ((opt->flags & flags) != flags)
+      continue;
 
-/* return TRUE if property described by pspec applies to the codec with codec_id */
-static gboolean
-gst_ffmpeg_cfg_codec_has_pspec (enum AVCodecID codec_id, GParamSpec * pspec)
-{
-  GParamSpecData *qdata;
-  gint *codec;
-  gboolean ret = FALSE;
+    if (g_object_class_find_property (gobject_class, name))
+      continue;
 
-  qdata = g_param_spec_get_qdata (pspec, quark);
+    if (av_opt_query_ranges (&r, obj, opt->name, AV_OPT_SEARCH_FAKE_OBJ) >= 0
+        && r->nb_ranges == 1) {
+      min = r->range[0]->value_min;
+      max = r->range[0]->value_max;
+    }
 
-  /* check if excluded first */
-  if ((codec = qdata->exclude_list)) {
-    for (; *codec != AV_CODEC_ID_NONE; ++codec) {
-      if (*codec == codec_id)
-        return FALSE;
+    help = g_strdup_printf ("%s%s", opt->help, extra_help);
+
+    switch (opt->type) {
+      case AV_OPT_TYPE_INT:
+        if (opt->unit) {
+          GType enum_gtype;
+          enum_gtype = register_enum (obj, opt);
+
+          if (enum_gtype) {
+            pspec = g_param_spec_enum (name, name, help,
+                enum_gtype, opt->default_val.i64, G_PARAM_READWRITE);
+            g_object_class_install_property (gobject_class, prop_id++, pspec);
+          } else {              /* Some options have a unit but no named constants associated */
+            pspec = g_param_spec_int (name, name, help,
+                (gint) min, (gint) max, opt->default_val.i64,
+                G_PARAM_READWRITE);
+            g_object_class_install_property (gobject_class, prop_id++, pspec);
+          }
+        } else {
+          pspec = g_param_spec_int (name, name, help,
+              (gint) min, (gint) max, opt->default_val.i64, G_PARAM_READWRITE);
+          g_object_class_install_property (gobject_class, prop_id++, pspec);
+        }
+        break;
+      case AV_OPT_TYPE_FLAGS:
+        if (opt->unit) {
+          GType flags_gtype;
+          flags_gtype = register_flags (obj, opt);
+
+          if (flags_gtype) {
+            pspec = g_param_spec_flags (name, name, help,
+                flags_gtype, opt->default_val.i64, G_PARAM_READWRITE);
+            g_object_class_install_property (gobject_class, prop_id++, pspec);
+          }
+        }
+        break;
+      case AV_OPT_TYPE_DURATION:       /* Fall through */
+      case AV_OPT_TYPE_INT64:
+        /* ffmpeg expresses all ranges with doubles, this is sad */
+        pspec = g_param_spec_int64 (name, name, help,
+            (gint64) (min == (gdouble) INT64_MIN ? INT64_MIN : min),
+            (gint64) (max == (gdouble) INT64_MAX ? INT64_MAX : max),
+            opt->default_val.i64, G_PARAM_READWRITE);
+        g_object_class_install_property (gobject_class, prop_id++, pspec);
+        break;
+      case AV_OPT_TYPE_DOUBLE:
+        pspec = g_param_spec_double (name, name, help,
+            min, max, opt->default_val.dbl, G_PARAM_READWRITE);
+        g_object_class_install_property (gobject_class, prop_id++, pspec);
+        break;
+      case AV_OPT_TYPE_FLOAT:
+        pspec = g_param_spec_float (name, name, help,
+            (gfloat) min, (gfloat) max, (gfloat) opt->default_val.dbl,
+            G_PARAM_READWRITE);
+        g_object_class_install_property (gobject_class, prop_id++, pspec);
+        break;
+      case AV_OPT_TYPE_STRING:
+        pspec = g_param_spec_string (name, name, help,
+            opt->default_val.str, G_PARAM_READWRITE);
+        g_object_class_install_property (gobject_class, prop_id++, pspec);
+        break;
+      case AV_OPT_TYPE_UINT64:
+        /* ffmpeg expresses all ranges with doubles, this is appalling */
+        pspec = g_param_spec_uint64 (name, name, help,
+            (gint64) (min == (gdouble) 0 ? 0 : min),
+            (gint64) (max == (gdouble) UINT64_MAX ? UINT64_MAX : min),
+            opt->default_val.i64, G_PARAM_READWRITE);
+        g_object_class_install_property (gobject_class, prop_id++, pspec);
+        break;
+      case AV_OPT_TYPE_BOOL:
+        pspec = g_param_spec_boolean (name, name, help,
+            opt->default_val.i64 ? TRUE : FALSE, G_PARAM_READWRITE);
+        g_object_class_install_property (gobject_class, prop_id++, pspec);
+        break;
+        /* TODO: didn't find options for the video encoders with
+         * the following type, add support if needed */
+      case AV_OPT_TYPE_CHANNEL_LAYOUT:
+      case AV_OPT_TYPE_COLOR:
+      case AV_OPT_TYPE_VIDEO_RATE:
+      case AV_OPT_TYPE_SAMPLE_FMT:
+      case AV_OPT_TYPE_PIXEL_FMT:
+      case AV_OPT_TYPE_IMAGE_SIZE:
+      case AV_OPT_TYPE_DICT:
+      case AV_OPT_TYPE_BINARY:
+      case AV_OPT_TYPE_RATIONAL:
+      default:
+        break;
     }
-  }
 
-  /* no include list means it is accepted */
-  if ((codec = qdata->include_list)) {
-    for (; *codec != AV_CODEC_ID_NONE; ++codec) {
-      if (*codec == codec_id)
-        ret = TRUE;
+    g_free (help);
+
+    if (pspec) {
+      g_param_spec_set_qdata (pspec, avoption_quark, (gpointer) opt);
     }
-  } else {
-    ret = TRUE;
   }
 
-  return ret;
+  return prop_id;
 }
 
-/* install all properties for klass that have been registered in property_list */
 void
-gst_ffmpeg_cfg_install_property (GstFFMpegVidEncClass * klass, guint base)
+gst_ffmpeg_cfg_install_properties (GstFFMpegVidEncClass * klass, guint base)
 {
-  GParamSpec *pspec;
-  GList *list;
   gint prop_id;
   AVCodecContext *ctx;
 
@@ -734,111 +347,14 @@ gst_ffmpeg_cfg_install_property (GstFFMpegVidEncClass * klass, guint base)
   if (!ctx)
     g_warning ("could not get context");
 
-  for (list = property_list; list; list = list->next) {
-    pspec = G_PARAM_SPEC (list->data);
-    if (gst_ffmpeg_cfg_codec_has_pspec (klass->in_plugin->id, pspec)) {
-      /* 'clone' the paramspec for the various codecs,
-       * since a single paramspec cannot be owned by distinct types */
-
-      const gchar *name = g_param_spec_get_name (pspec);
-      const gchar *nick = g_param_spec_get_nick (pspec);
-      const gchar *blurb = g_param_spec_get_blurb (pspec);
-      GParamSpecData *qdata = g_param_spec_get_qdata (pspec, quark);
-      gint ctx_offset = 0;
-      gboolean lavc_default;
-
-      /* cannot obtain lavc default if no context */
-      if (!ctx)
-        lavc_default = FALSE;
-      else {
-        ctx_offset = qdata->offset - CONTEXT_CONFIG_OFFSET;
-        /* safety check; is it really member of the avcodec context */
-        if (ctx_offset < 0)
-          lavc_default = FALSE;
-        else
-          lavc_default = qdata->lavc_default;
-      }
-
-      switch (G_PARAM_SPEC_VALUE_TYPE (pspec)) {
-        case G_TYPE_STRING:{
-          GParamSpecString *pstring = G_PARAM_SPEC_STRING (pspec);
-
-          pspec = g_param_spec_string (name, nick, blurb,
-              lavc_default ? G_STRUCT_MEMBER (gchar *, ctx, ctx_offset)
-              : pstring->default_value, pspec->flags);
-          break;
-        }
-        case G_TYPE_INT:{
-          GParamSpecInt *pint = G_PARAM_SPEC_INT (pspec);
-
-          pspec = g_param_spec_int (name, nick, blurb,
-              pint->minimum, pint->maximum,
-              lavc_default ? G_STRUCT_MEMBER (gint, ctx, ctx_offset)
-              : pint->default_value, pspec->flags);
-          break;
-        }
-        case G_TYPE_INT64:{
-          GParamSpecInt64 *pint = G_PARAM_SPEC_INT64 (pspec);
-
-          pspec = g_param_spec_int64 (name, nick, blurb,
-              pint->minimum, pint->maximum,
-              lavc_default ? G_STRUCT_MEMBER (gint64, ctx, ctx_offset)
-              : pint->default_value, pspec->flags);
-          break;
-        }
-        case G_TYPE_UINT:{
-          GParamSpecUInt *puint = G_PARAM_SPEC_UINT (pspec);
-
-          pspec = g_param_spec_uint (name, nick, blurb,
-              puint->minimum, puint->maximum,
-              lavc_default ? G_STRUCT_MEMBER (guint, ctx, ctx_offset)
-              : puint->default_value, pspec->flags);
-          break;
-        }
-        case G_TYPE_FLOAT:{
-          GParamSpecFloat *pfloat = G_PARAM_SPEC_FLOAT (pspec);
-
-          pspec = g_param_spec_float (name, nick, blurb,
-              pfloat->minimum, pfloat->maximum,
-              lavc_default ? G_STRUCT_MEMBER (gfloat, ctx, ctx_offset)
-              : pfloat->default_value, pspec->flags);
-          break;
-        }
-        case G_TYPE_BOOLEAN:{
-          GParamSpecBoolean *pboolean = G_PARAM_SPEC_BOOLEAN (pspec);
-
-          pspec = g_param_spec_boolean (name, nick, blurb,
-              lavc_default ? G_STRUCT_MEMBER (gboolean, ctx, ctx_offset)
-              : pboolean->default_value, pspec->flags);
-          break;
-        }
-        default:
-          if (G_IS_PARAM_SPEC_ENUM (pspec)) {
-            GParamSpecEnum *penum = G_PARAM_SPEC_ENUM (pspec);
-
-            pspec = g_param_spec_enum (name, nick, blurb,
-                pspec->value_type,
-                lavc_default ? G_STRUCT_MEMBER (gint, ctx, ctx_offset)
-                : penum->default_value, pspec->flags);
-          } else if (G_IS_PARAM_SPEC_FLAGS (pspec)) {
-            GParamSpecFlags *pflags = G_PARAM_SPEC_FLAGS (pspec);
-
-            pspec = g_param_spec_flags (name, nick, blurb,
-                pspec->value_type,
-                lavc_default ? G_STRUCT_MEMBER (guint, ctx, ctx_offset)
-                : pflags->default_value, pspec->flags);
-          } else {
-            g_critical ("%s does not yet support type %s", GST_FUNCTION,
-                g_type_name (G_PARAM_SPEC_VALUE_TYPE (pspec)));
-            continue;
-          }
-          break;
-      }
-      g_param_spec_set_qdata (pspec, quark, qdata);
-      g_object_class_install_property (G_OBJECT_CLASS (klass), prop_id, pspec);
-      ++prop_id;
-    }
-  }
+  prop_id =
+      install_opts ((GObjectClass *) klass, &klass->in_plugin->priv_class,
+      prop_id, AV_OPT_FLAG_ENCODING_PARAM | AV_OPT_FLAG_VIDEO_PARAM,
+      " (Private codec option)", NULL);
+  prop_id =
+      install_opts ((GObjectClass *) klass, &ctx->av_class, prop_id,
+      AV_OPT_FLAG_ENCODING_PARAM | AV_OPT_FLAG_VIDEO_PARAM,
+      " (Generic codec option, might have no effect)", venc_overrides);
 
   if (ctx) {
     gst_ffmpeg_avcodec_close (ctx);
@@ -846,205 +362,180 @@ gst_ffmpeg_cfg_install_property (GstFFMpegVidEncClass * klass, guint base)
   }
 }
 
-/* returns TRUE if it is a known property for this config system,
- * FALSE otherwise */
-gboolean
-gst_ffmpeg_cfg_set_property (GObject * object,
-    const GValue * value, GParamSpec * pspec)
+static gint
+set_option_value (AVCodecContext * ctx, GParamSpec * pspec,
+    const GValue * value, const AVOption * opt)
 {
-  GstFFMpegVidEnc *ffmpegenc = (GstFFMpegVidEnc *) (object);
-  GParamSpecData *qdata;
-
-  qdata = g_param_spec_get_qdata (pspec, quark);
-
-  /* our param specs should have such qdata */
-  if (!qdata)
-    return FALSE;
+  int res = -1;
 
-  /* set the member using the offset, also mild type check based on size */
   switch (G_PARAM_SPEC_VALUE_TYPE (pspec)) {
-    case G_TYPE_BOOLEAN:
-      g_return_val_if_fail (qdata->size == sizeof (gboolean), TRUE);
-      G_STRUCT_MEMBER (gboolean, ffmpegenc, qdata->offset) =
-          g_value_get_boolean (value);
-      break;
-    case G_TYPE_UINT:
-      g_return_val_if_fail (qdata->size == sizeof (guint), TRUE);
-      G_STRUCT_MEMBER (guint, ffmpegenc, qdata->offset) =
-          g_value_get_uint (value);
-      break;
     case G_TYPE_INT:
-      g_return_val_if_fail (qdata->size == sizeof (gint), TRUE);
-      G_STRUCT_MEMBER (gint, ffmpegenc, qdata->offset) =
-          g_value_get_int (value);
+      res = av_opt_set_int (ctx, opt->name,
+          g_value_get_int (value), AV_OPT_SEARCH_CHILDREN);
       break;
     case G_TYPE_INT64:
-      g_return_val_if_fail (qdata->size == sizeof (gint64), TRUE);
-      G_STRUCT_MEMBER (gint64, ffmpegenc, qdata->offset) =
-          g_value_get_int64 (value);
+      res = av_opt_set_int (ctx, opt->name,
+          g_value_get_int64 (value), AV_OPT_SEARCH_CHILDREN);
+      break;
+    case G_TYPE_UINT64:
+      res = av_opt_set_int (ctx, opt->name,
+          g_value_get_uint64 (value), AV_OPT_SEARCH_CHILDREN);
+      break;
+    case G_TYPE_DOUBLE:
+      res = av_opt_set_double (ctx, opt->name,
+          g_value_get_double (value), AV_OPT_SEARCH_CHILDREN);
       break;
     case G_TYPE_FLOAT:
-      g_return_val_if_fail (qdata->size == sizeof (gfloat), TRUE);
-      G_STRUCT_MEMBER (gfloat, ffmpegenc, qdata->offset) =
-          g_value_get_float (value);
+      res = av_opt_set_double (ctx, opt->name,
+          g_value_get_float (value), AV_OPT_SEARCH_CHILDREN);
       break;
     case G_TYPE_STRING:
-      g_return_val_if_fail (qdata->size == sizeof (gchar *), TRUE);
-      g_free (G_STRUCT_MEMBER (gchar *, ffmpegenc, qdata->offset));
-      G_STRUCT_MEMBER (gchar *, ffmpegenc, qdata->offset) =
-          g_value_dup_string (value);
+      res = av_opt_set (ctx, opt->name,
+          g_value_get_string (value), AV_OPT_SEARCH_CHILDREN);
+      /* Some code in FFmpeg returns ENOMEM if the string is NULL:
+       * *dst = av_strdup(val);
+       * return *dst ? 0 : AVERROR(ENOMEM);
+       * That makes little sense, let's ignore that
+       */
+      if (!g_value_get_string (value))
+        res = 0;
+      break;
+    case G_TYPE_BOOLEAN:
+      res = av_opt_set_int (ctx, opt->name,
+          g_value_get_boolean (value), AV_OPT_SEARCH_CHILDREN);
       break;
-    default:                   /* must be enum, given the check above */
+    default:
       if (G_IS_PARAM_SPEC_ENUM (pspec)) {
-        g_return_val_if_fail (qdata->size == sizeof (gint), TRUE);
-        G_STRUCT_MEMBER (gint, ffmpegenc, qdata->offset) =
-            g_value_get_enum (value);
+        res = av_opt_set_int (ctx, opt->name,
+            g_value_get_enum (value), AV_OPT_SEARCH_CHILDREN);
       } else if (G_IS_PARAM_SPEC_FLAGS (pspec)) {
-        g_return_val_if_fail (qdata->size == sizeof (guint), TRUE);
-        G_STRUCT_MEMBER (guint, ffmpegenc, qdata->offset) =
-            g_value_get_flags (value);
+        res = av_opt_set_int (ctx, opt->name,
+            g_value_get_flags (value), AV_OPT_SEARCH_CHILDREN);
       } else {                  /* oops, bit lazy we don't cover this case yet */
         g_critical ("%s does not yet support type %s", GST_FUNCTION,
             g_type_name (G_PARAM_SPEC_VALUE_TYPE (pspec)));
       }
-
-      break;
   }
 
-  return TRUE;
+  return res;
 }
 
-/* returns TRUE if it is a known property for this config system,
- * FALSE otherwise */
 gboolean
-gst_ffmpeg_cfg_get_property (GObject * object,
-    GValue * value, GParamSpec * pspec)
+gst_ffmpeg_cfg_set_property (GObject * object,
+    const GValue * value, GParamSpec * pspec)
 {
   GstFFMpegVidEnc *ffmpegenc = (GstFFMpegVidEnc *) (object);
-  GParamSpecData *qdata;
+  const AVOption *opt;
 
-  qdata = g_param_spec_get_qdata (pspec, quark);
+  opt = g_param_spec_get_qdata (pspec, avoption_quark);
 
-  /* our param specs should have such qdata */
-  if (!qdata)
+  if (!opt)
     return FALSE;
 
-  /* get the member using the offset, also mild type check based on size */
-  switch (G_PARAM_SPEC_VALUE_TYPE (pspec)) {
-    case G_TYPE_BOOLEAN:
-      g_return_val_if_fail (qdata->size == sizeof (gboolean), TRUE);
-      g_value_set_boolean (value,
-          G_STRUCT_MEMBER (gboolean, ffmpegenc, qdata->offset));
-      break;
-    case G_TYPE_UINT:
-      g_return_val_if_fail (qdata->size == sizeof (guint), TRUE);
-      g_value_set_uint (value,
-          G_STRUCT_MEMBER (guint, ffmpegenc, qdata->offset));
-      break;
-    case G_TYPE_INT:
-      g_return_val_if_fail (qdata->size == sizeof (gint), TRUE);
-      g_value_set_int (value, G_STRUCT_MEMBER (gint, ffmpegenc, qdata->offset));
-      break;
-    case G_TYPE_INT64:
-      g_return_val_if_fail (qdata->size == sizeof (gint64), TRUE);
-      g_value_set_int64 (value, G_STRUCT_MEMBER (gint64, ffmpegenc,
-              qdata->offset));
-      break;
-    case G_TYPE_FLOAT:
-      g_return_val_if_fail (qdata->size == sizeof (gfloat), TRUE);
-      g_value_set_float (value,
-          G_STRUCT_MEMBER (gfloat, ffmpegenc, qdata->offset));
-      break;
-    case G_TYPE_STRING:
-      g_return_val_if_fail (qdata->size == sizeof (gchar *), TRUE);
-      g_value_take_string (value,
-          g_strdup (G_STRUCT_MEMBER (gchar *, ffmpegenc, qdata->offset)));
-      break;
-    default:                   /* must be enum, given the check above */
-      if (G_IS_PARAM_SPEC_ENUM (pspec)) {
-        g_return_val_if_fail (qdata->size == sizeof (gint), TRUE);
-        g_value_set_enum (value,
-            G_STRUCT_MEMBER (gint, ffmpegenc, qdata->offset));
-      } else if (G_IS_PARAM_SPEC_FLAGS (pspec)) {
-        g_return_val_if_fail (qdata->size == sizeof (guint), TRUE);
-        g_value_set_flags (value,
-            G_STRUCT_MEMBER (guint, ffmpegenc, qdata->offset));
-      } else {                  /* oops, bit lazy we don't cover this case yet */
-        g_critical ("%s does not yet support type %s", GST_FUNCTION,
-            g_type_name (G_PARAM_SPEC_VALUE_TYPE (pspec)));
-      }
-      break;
-  }
-
-  return TRUE;
+  return set_option_value (ffmpegenc->refcontext, pspec, value, opt) >= 0;
 }
 
-void
-gst_ffmpeg_cfg_set_defaults (GstFFMpegVidEnc * ffmpegenc)
+gboolean
+gst_ffmpeg_cfg_get_property (GObject * object,
+    GValue * value, GParamSpec * pspec)
 {
-  GParamSpec **pspecs;
-  guint num_props, i;
-
-  pspecs = g_object_class_list_properties (G_OBJECT_GET_CLASS (ffmpegenc),
-      &num_props);
+  GstFFMpegVidEnc *ffmpegenc = (GstFFMpegVidEnc *) (object);
+  const AVOption *opt;
 
-  for (i = 0; i < num_props; ++i) {
-    GValue val = { 0, };
-    GParamSpec *pspec = pspecs[i];
+  opt = g_param_spec_get_qdata (pspec, avoption_quark);
 
-    /* only touch those that are really ours; i.e. should have some qdata */
-    if (!g_param_spec_get_qdata (pspec, quark))
-      continue;
-    g_value_init (&val, G_PARAM_SPEC_VALUE_TYPE (pspec));
-    g_param_value_set_default (pspec, &val);
-    g_object_set_property (G_OBJECT (ffmpegenc),
-        g_param_spec_get_name (pspec), &val);
-    g_value_unset (&val);
+  if (!opt) {
+    return FALSE;
   }
 
-  g_free (pspecs);
-
-}
-
+  if (opt) {
+    int res = -1;
 
-void
-gst_ffmpeg_cfg_fill_context (GstFFMpegVidEnc * ffmpegenc,
-    AVCodecContext * context)
-{
-  GstFFMpegVidEncClass *klass
-      = (GstFFMpegVidEncClass *) G_OBJECT_GET_CLASS (ffmpegenc);
-  GParamSpec *pspec;
-  GParamSpecData *qdata;
-  GList *list;
-
-  list = property_list;
-
-  while (list) {
-    gint context_offset;
-
-    pspec = G_PARAM_SPEC (list->data);
-    qdata = g_param_spec_get_qdata (pspec, quark);
-    context_offset = qdata->offset - CONTEXT_CONFIG_OFFSET;
-    if (gst_ffmpeg_cfg_codec_has_pspec (klass->in_plugin->id, pspec)
-        && context_offset >= 0) {
-      if (G_PARAM_SPEC_VALUE_TYPE (pspec) == G_TYPE_STRING) {
-        /* make a copy for ffmpeg, it will likely free only some,
-         * but in any case safer than a potential double free */
-        G_STRUCT_MEMBER (gchar *, context, context_offset) =
-            av_strdup (G_STRUCT_MEMBER (gchar *, ffmpegenc, qdata->offset));
-      } else {
-        /* memcpy a bit heavy for a small copy,
-         * but hardly part of 'inner loop' */
-        memcpy (G_STRUCT_MEMBER_P (context, context_offset),
-            G_STRUCT_MEMBER_P (ffmpegenc, qdata->offset), qdata->size);
+    switch (G_PARAM_SPEC_VALUE_TYPE (pspec)) {
+      case G_TYPE_INT:
+      {
+        int64_t val;
+        if ((res = av_opt_get_int (ffmpegenc->refcontext, opt->name,
+                    AV_OPT_SEARCH_CHILDREN, &val) >= 0))
+          g_value_set_int (value, val);
+        break;
+      }
+      case G_TYPE_INT64:
+      {
+        int64_t val;
+        if ((res = av_opt_get_int (ffmpegenc->refcontext, opt->name,
+                    AV_OPT_SEARCH_CHILDREN, &val) >= 0))
+          g_value_set_int64 (value, val);
+        break;
+      }
+      case G_TYPE_UINT64:
+      {
+        int64_t val;
+        if ((res = av_opt_get_int (ffmpegenc->refcontext, opt->name,
+                    AV_OPT_SEARCH_CHILDREN, &val) >= 0))
+          g_value_set_uint64 (value, val);
+        break;
       }
+      case G_TYPE_DOUBLE:
+      {
+        gdouble val;
+        if ((res = av_opt_get_double (ffmpegenc->refcontext, opt->name,
+                    AV_OPT_SEARCH_CHILDREN, &val) >= 0))
+          g_value_set_double (value, val);
+        break;
+      }
+      case G_TYPE_FLOAT:
+      {
+        gdouble val;
+        if ((res = av_opt_get_double (ffmpegenc->refcontext, opt->name,
+                    AV_OPT_SEARCH_CHILDREN, &val) >= 0))
+          g_value_set_float (value, (gfloat) val);
+        break;
+      }
+      case G_TYPE_STRING:
+      {
+        uint8_t *val;
+        if ((res = av_opt_get (ffmpegenc->refcontext, opt->name,
+                    AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &val) >= 0)) {
+          g_value_set_string (value, (gchar *) val);
+        }
+        break;
+      }
+      case G_TYPE_BOOLEAN:
+      {
+        int64_t val;
+        if ((res = av_opt_get_int (ffmpegenc->refcontext, opt->name,
+                    AV_OPT_SEARCH_CHILDREN, &val) >= 0))
+          g_value_set_boolean (value, val ? TRUE : FALSE);
+        break;
+      }
+      default:
+        if (G_IS_PARAM_SPEC_ENUM (pspec)) {
+          int64_t val;
+
+          if ((res = av_opt_get_int (ffmpegenc->refcontext, opt->name,
+                      AV_OPT_SEARCH_CHILDREN, &val) >= 0))
+            g_value_set_enum (value, val);
+        } else if (G_IS_PARAM_SPEC_FLAGS (pspec)) {
+          int64_t val;
+
+          if ((res = av_opt_get_int (ffmpegenc->refcontext, opt->name,
+                      AV_OPT_SEARCH_CHILDREN, &val) >= 0))
+            g_value_set_flags (value, val);
+        } else {                /* oops, bit lazy we don't cover this case yet */
+          g_critical ("%s does not yet support type %s", GST_FUNCTION,
+              g_type_name (G_PARAM_SPEC_VALUE_TYPE (pspec)));
+        }
     }
-    list = list->next;
+    return res >= 0;
   }
+
+  return TRUE;
 }
 
 void
-gst_ffmpeg_cfg_finalize (GstFFMpegVidEnc * ffmpegenc)
+gst_ffmpeg_cfg_fill_context (GstFFMpegVidEnc * ffmpegenc,
+    AVCodecContext * context)
 {
   GParamSpec **pspecs;
   guint num_props, i;
@@ -1054,24 +545,23 @@ gst_ffmpeg_cfg_finalize (GstFFMpegVidEnc * ffmpegenc)
 
   for (i = 0; i < num_props; ++i) {
     GParamSpec *pspec = pspecs[i];
-    GParamSpecData *qdata;
+    const AVOption *opt;
+    GValue value;
 
-    qdata = g_param_spec_get_qdata (pspec, quark);
+    opt = g_param_spec_get_qdata (pspec, avoption_quark);
 
-    /* our param specs should have such qdata */
-    if (!qdata)
+    if (!opt)
       continue;
 
-    switch (G_PARAM_SPEC_VALUE_TYPE (pspec)) {
-      case G_TYPE_STRING:
-        if (qdata->size == sizeof (gchar *)) {
-          g_free (G_STRUCT_MEMBER (gchar *, ffmpegenc, qdata->offset));
-          G_STRUCT_MEMBER (gchar *, ffmpegenc, qdata->offset) = NULL;
-        }
-        break;
-      default:
-        break;
-    }
+    g_object_getv (G_OBJECT (ffmpegenc), 1, &pspec->name, &value);
+    set_option_value (context, pspec, &value, opt);
   }
   g_free (pspecs);
 }
+
+void
+gst_ffmpeg_cfg_finalize (GstFFMpegVidEnc * ffmpegenc)
+{
+  g_assert (venc_overrides);
+  g_hash_table_unref (venc_overrides);
+}
diff --git a/ext/libav/gstavcfg.h b/ext/libav/gstavcfg.h
index 2aef665..d087d84 100644
--- a/ext/libav/gstavcfg.h
+++ b/ext/libav/gstavcfg.h
@@ -25,7 +25,7 @@ G_BEGIN_DECLS
 
 void gst_ffmpeg_cfg_init (void);
 
-void gst_ffmpeg_cfg_install_property (GstFFMpegVidEncClass * klass, guint base);
+void gst_ffmpeg_cfg_install_properties (GstFFMpegVidEncClass * klass, guint base);
 
 gboolean gst_ffmpeg_cfg_set_property (GObject * object,
     const GValue * value, GParamSpec * pspec);
diff --git a/ext/libav/gstavcodecmap.c b/ext/libav/gstavcodecmap.c
index 7e48449..2ea667f 100644
--- a/ext/libav/gstavcodecmap.c
+++ b/ext/libav/gstavcodecmap.c
@@ -3222,7 +3222,7 @@ gst_ffmpeg_caps_with_codecid (enum AVCodecID codec_id,
         profile = gst_structure_get_string (str, "profile");
         if (profile) {
           if (g_strcmp0 (profile, "advanced-simple") == 0)
-            context->flags |= CODEC_FLAG_GMC | AV_CODEC_FLAG_QPEL;
+            context->flags |= AV_CODEC_FLAG_QPEL;
         }
       }
       break;
diff --git a/ext/libav/gstavvidenc.c b/ext/libav/gstavvidenc.c
index c347c10..eecc19d 100644
--- a/ext/libav/gstavvidenc.c
+++ b/ext/libav/gstavvidenc.c
@@ -30,6 +30,7 @@
 
 #include <libavcodec/avcodec.h>
 #include <libavutil/stereo3d.h>
+#include <libavutil/opt.h>
 
 #include <gst/gst.h>
 #include <gst/video/gstvideometa.h>
@@ -40,56 +41,16 @@
 #include "gstavvidenc.h"
 #include "gstavcfg.h"
 
-#define DEFAULT_VIDEO_BITRATE 300000    /* in bps */
-#define DEFAULT_VIDEO_GOP_SIZE 15
-
-#define DEFAULT_WIDTH 352
-#define DEFAULT_HEIGHT 288
-
-
-#define VIDEO_BUFFER_SIZE (1024*1024)
-
-enum
-{
-  /* FILL ME */
-  LAST_SIGNAL
-};
 
 enum
 {
   PROP_0,
-  PROP_BIT_RATE,
-  PROP_GOP_SIZE,
-  PROP_ME_METHOD,
-  PROP_BUFSIZE,
-  PROP_RTP_PAYLOAD_SIZE,
-  PROP_MAX_THREADS,
-  PROP_COMPLIANCE,
+  PROP_QUANTIZER,
+  PROP_PASS,
+  PROP_FILENAME,
   PROP_CFG_BASE,
 };
 
-#define GST_TYPE_ME_METHOD (gst_ffmpegvidenc_me_method_get_type())
-static GType
-gst_ffmpegvidenc_me_method_get_type (void)
-{
-  static GType ffmpegenc_me_method_type = 0;
-  static GEnumValue ffmpegenc_me_methods[] = {
-    {ME_ZERO, "None (Very low quality)", "zero"},
-    {ME_FULL, "Full (Slow, unmaintained)", "full"},
-    {ME_LOG, "Logarithmic (Low quality, unmaintained)", "logarithmic"},
-    {ME_PHODS, "phods (Low quality, unmaintained)", "phods"},
-    {ME_EPZS, "EPZS (Best quality, Fast)", "epzs"},
-    {ME_X1, "X1 (Experimental)", "x1"},
-    {0, NULL, NULL},
-  };
-  if (!ffmpegenc_me_method_type) {
-    ffmpegenc_me_method_type =
-        g_enum_register_static ("GstLibAVVidEncMeMethod", ffmpegenc_me_methods);
-  }
-  return ffmpegenc_me_method_type;
-}
-
-/* A number of function prototypes are given so we can refer to them later. */
 static void gst_ffmpegvidenc_class_init (GstFFMpegVidEncClass * klass);
 static void gst_ffmpegvidenc_base_init (GstFFMpegVidEncClass * klass);
 static void gst_ffmpegvidenc_init (GstFFMpegVidEnc * ffmpegenc);
@@ -116,7 +77,27 @@ static void gst_ffmpegvidenc_get_property (GObject * object,
 
 static GstElementClass *parent_class = NULL;
 
-/*static guint gst_ffmpegvidenc_signals[LAST_SIGNAL] = { 0 }; */
+#define GST_TYPE_FFMPEG_PASS (gst_ffmpeg_pass_get_type ())
+static GType
+gst_ffmpeg_pass_get_type (void)
+{
+  static GType ffmpeg_pass_type = 0;
+
+  if (!ffmpeg_pass_type) {
+    static const GEnumValue ffmpeg_passes[] = {
+      {0, "Constant Bitrate Encoding", "cbr"},
+      {AV_CODEC_FLAG_QSCALE, "Constant Quantizer", "quant"},
+      {AV_CODEC_FLAG_PASS1, "VBR Encoding - Pass 1", "pass1"},
+      {AV_CODEC_FLAG_PASS2, "VBR Encoding - Pass 2", "pass2"},
+      {0, NULL, NULL},
+    };
+
+    ffmpeg_pass_type =
+        g_enum_register_static ("GstLibAVEncPass", ffmpeg_passes);
+  }
+
+  return ffmpeg_pass_type;
+}
 
 static void
 gst_ffmpegvidenc_base_init (GstFFMpegVidEncClass * klass)
@@ -181,7 +162,6 @@ gst_ffmpegvidenc_class_init (GstFFMpegVidEncClass * klass)
 {
   GObjectClass *gobject_class;
   GstVideoEncoderClass *venc_class;
-  int caps;
 
   gobject_class = (GObjectClass *) klass;
   venc_class = (GstVideoEncoderClass *) klass;
@@ -191,46 +171,23 @@ gst_ffmpegvidenc_class_init (GstFFMpegVidEncClass * klass)
   gobject_class->set_property = gst_ffmpegvidenc_set_property;
   gobject_class->get_property = gst_ffmpegvidenc_get_property;
 
-  /* FIXME: could use -1 for a sensible per-codec default based on
-   * e.g. input resolution and framerate */
-  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_BIT_RATE,
-      g_param_spec_int ("bitrate", "Bit Rate",
-          "Target Video Bitrate", 0, G_MAXINT, DEFAULT_VIDEO_BITRATE,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
-  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_GOP_SIZE,
-      g_param_spec_int ("gop-size", "GOP Size",
-          "Number of frames within one GOP", 0, G_MAXINT,
-          DEFAULT_VIDEO_GOP_SIZE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
-  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_ME_METHOD,
-      g_param_spec_enum ("me-method", "ME Method", "Motion Estimation Method",
-          GST_TYPE_ME_METHOD, ME_EPZS,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
-
-  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_BUFSIZE,
-      g_param_spec_int ("buffer-size", "Buffer Size",
-          "Size of the video buffers", 0, G_MAXINT, 0,
-          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
-  g_object_class_install_property (G_OBJECT_CLASS (klass),
-      PROP_RTP_PAYLOAD_SIZE, g_param_spec_int ("rtp-payload-size",
-          "RTP Payload Size", "Target GOB length", 0, G_MAXINT, 0,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
-
-  caps = klass->in_plugin->capabilities;
-  if (caps & (AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS)) {
-    g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_MAX_THREADS,
-        g_param_spec_int ("max-threads", "Maximum encode threads",
-            "Maximum number of worker threads to spawn. (0 = auto)",
-            0, G_MAXINT, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
-  }
+  g_object_class_install_property (gobject_class, PROP_QUANTIZER,
+      g_param_spec_float ("quantizer", "Constant Quantizer",
+          "Constant Quantizer", 0, 30, 0.01f,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT));
 
-  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_COMPLIANCE,
-      g_param_spec_enum ("compliance", "Compliance",
-          "Adherence of the encoder to the specifications",
-          GST_TYPE_FFMPEG_COMPLIANCE, FFMPEG_DEFAULT_COMPLIANCE,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_PASS,
+      g_param_spec_enum ("pass", "Encoding pass/type",
+          "Encoding pass/type", GST_TYPE_FFMPEG_PASS, 0,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT));
+
+  g_object_class_install_property (gobject_class, PROP_FILENAME,
+      g_param_spec_string ("multipass-cache-file", "Multipass Cache File",
+          "Filename for multipass cache file", "stats.log",
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT));
 
   /* register additional properties, possibly dependent on the exact CODEC */
-  gst_ffmpeg_cfg_install_property (klass, PROP_CFG_BASE);
+  gst_ffmpeg_cfg_install_properties (klass, PROP_CFG_BASE);
 
   venc_class->start = gst_ffmpegvidenc_start;
   venc_class->stop = gst_ffmpegvidenc_stop;
@@ -251,26 +208,11 @@ gst_ffmpegvidenc_init (GstFFMpegVidEnc * ffmpegenc)
 
   GST_PAD_SET_ACCEPT_TEMPLATE (GST_VIDEO_ENCODER_SINK_PAD (ffmpegenc));
 
-  /* ffmpeg objects */
   ffmpegenc->context = avcodec_alloc_context3 (klass->in_plugin);
+  ffmpegenc->refcontext = avcodec_alloc_context3 (klass->in_plugin);
   ffmpegenc->picture = av_frame_alloc ();
   ffmpegenc->opened = FALSE;
-
   ffmpegenc->file = NULL;
-
-  ffmpegenc->bitrate = DEFAULT_VIDEO_BITRATE;
-  ffmpegenc->me_method = ME_EPZS;
-  ffmpegenc->buffer_size = 512 * 1024;
-  ffmpegenc->gop_size = DEFAULT_VIDEO_GOP_SIZE;
-  ffmpegenc->rtp_payload_size = 0;
-  ffmpegenc->compliance = FFMPEG_DEFAULT_COMPLIANCE;
-  ffmpegenc->max_threads = 0;
-
-  ffmpegenc->lmin = 2;
-  ffmpegenc->lmax = 31;
-  ffmpegenc->max_key_interval = 0;
-
-  gst_ffmpeg_cfg_set_defaults (ffmpegenc);
 }
 
 static void
@@ -284,8 +226,7 @@ gst_ffmpegvidenc_finalize (GObject * object)
   av_frame_free (&ffmpegenc->picture);
   gst_ffmpeg_avcodec_close (ffmpegenc->context);
   av_free (ffmpegenc->context);
-
-  g_free (ffmpegenc->filename);
+  av_free (ffmpegenc->refcontext);
 
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
@@ -314,50 +255,9 @@ gst_ffmpegvidenc_set_format (GstVideoEncoder * encoder,
     }
   }
 
-  /* if we set it in _getcaps we should set it also in _link */
-  ffmpegenc->context->strict_std_compliance = ffmpegenc->compliance;
-
-  /* user defined properties */
-  ffmpegenc->context->bit_rate = ffmpegenc->bitrate;
-  ffmpegenc->context->bit_rate_tolerance = ffmpegenc->bitrate;
-  ffmpegenc->context->gop_size = ffmpegenc->gop_size;
-  ffmpegenc->context->me_method = ffmpegenc->me_method;
-  GST_DEBUG_OBJECT (ffmpegenc, "Setting avcontext to bitrate %d, gop_size %d",
-      ffmpegenc->bitrate, ffmpegenc->gop_size);
-
-  if (ffmpegenc->max_threads == 0) {
-    if (!(oclass->in_plugin->capabilities & AV_CODEC_CAP_AUTO_THREADS))
-      ffmpegenc->context->thread_count = gst_ffmpeg_auto_max_threads ();
-    else
-      ffmpegenc->context->thread_count = 0;
-  } else
-    ffmpegenc->context->thread_count = ffmpegenc->max_threads;
-
-  /* RTP payload used for GOB production (for Asterisk) */
-  if (ffmpegenc->rtp_payload_size) {
-    ffmpegenc->context->rtp_payload_size = ffmpegenc->rtp_payload_size;
-  }
-
   /* additional avcodec settings */
-  /* first fill in the majority by copying over */
   gst_ffmpeg_cfg_fill_context (ffmpegenc, ffmpegenc->context);
 
-  /* then handle some special cases */
-  ffmpegenc->context->lmin = (ffmpegenc->lmin * FF_QP2LAMBDA + 0.5);
-  ffmpegenc->context->lmax = (ffmpegenc->lmax * FF_QP2LAMBDA + 0.5);
-
-  if (ffmpegenc->interlaced) {
-    ffmpegenc->context->flags |=
-        AV_CODEC_FLAG_INTERLACED_DCT | AV_CODEC_FLAG_INTERLACED_ME;
-  }
-
-  /* some other defaults */
-  ffmpegenc->context->rc_strategy = 2;
-  ffmpegenc->context->b_frame_strategy = 0;
-  ffmpegenc->context->coder_type = 0;
-  ffmpegenc->context->context_model = 0;
-  ffmpegenc->context->scenechange_threshold = 0;
-
   /* and last but not least the pass; CBR, 2-pass, etc */
   ffmpegenc->context->flags |= ffmpegenc->pass;
   switch (ffmpegenc->pass) {
@@ -412,18 +312,6 @@ gst_ffmpegvidenc_set_format (GstVideoEncoder * encoder,
 
   pix_fmt = ffmpegenc->context->pix_fmt;
 
-  /* max-key-interval may need the framerate set above */
-  if (ffmpegenc->max_key_interval) {
-    AVCodecContext *ctx;
-
-    /* override gop-size */
-    ctx = ffmpegenc->context;
-    ctx->gop_size = (ffmpegenc->max_key_interval < 0) ?
-        (-ffmpegenc->max_key_interval
-        * (ctx->time_base.den * ctx->ticks_per_frame / ctx->time_base.num))
-        : ffmpegenc->max_key_interval;
-  }
-
   /* some codecs support more than one format, first auto-choose one */
   GST_DEBUG_OBJECT (ffmpegenc, "picking an output format ...");
   allowed_caps = gst_pad_get_allowed_caps (GST_VIDEO_ENCODER_SRC_PAD (encoder));
@@ -645,7 +533,8 @@ gst_ffmpegvidenc_handle_frame (GstVideoEncoder * encoder,
   int have_data = 0;
   BufferInfo *buffer_info;
 
-  if (ffmpegenc->interlaced) {
+  if (ffmpegenc->context->flags & (AV_CODEC_FLAG_INTERLACED_DCT |
+          AV_CODEC_FLAG_INTERLACED_ME)) {
     ffmpegenc->picture->interlaced_frame = TRUE;
     /* if this is not the case, a filter element should be used to swap fields */
     ffmpegenc->picture->top_field_first =
@@ -825,14 +714,12 @@ done:
   return flow_ret;
 }
 
-
 static void
 gst_ffmpegvidenc_set_property (GObject * object,
     guint prop_id, const GValue * value, GParamSpec * pspec)
 {
   GstFFMpegVidEnc *ffmpegenc;
 
-  /* Get a pointer of the right type. */
   ffmpegenc = (GstFFMpegVidEnc *) (object);
 
   if (ffmpegenc->opened) {
@@ -841,27 +728,16 @@ gst_ffmpegvidenc_set_property (GObject * object,
     return;
   }
 
-  /* Check the argument id to see which argument we're setting. */
   switch (prop_id) {
-    case PROP_BIT_RATE:
-      ffmpegenc->bitrate = g_value_get_int (value);
-      break;
-    case PROP_GOP_SIZE:
-      ffmpegenc->gop_size = g_value_get_int (value);
-      break;
-    case PROP_ME_METHOD:
-      ffmpegenc->me_method = g_value_get_enum (value);
-      break;
-    case PROP_BUFSIZE:
-      break;
-    case PROP_RTP_PAYLOAD_SIZE:
-      ffmpegenc->rtp_payload_size = g_value_get_int (value);
+    case PROP_QUANTIZER:
+      ffmpegenc->quantizer = g_value_get_float (value);
       break;
-    case PROP_COMPLIANCE:
-      ffmpegenc->compliance = g_value_get_enum (value);
+    case PROP_PASS:
+      ffmpegenc->pass = g_value_get_enum (value);
       break;
-    case PROP_MAX_THREADS:
-      ffmpegenc->max_threads = g_value_get_int (value);
+    case PROP_FILENAME:
+      g_free (ffmpegenc->filename);
+      ffmpegenc->filename = g_value_dup_string (value);
       break;
     default:
       if (!gst_ffmpeg_cfg_set_property (object, value, pspec))
@@ -870,37 +746,23 @@ gst_ffmpegvidenc_set_property (GObject * object,
   }
 }
 
-/* The set function is simply the inverse of the get fuction. */
 static void
 gst_ffmpegvidenc_get_property (GObject * object,
     guint prop_id, GValue * value, GParamSpec * pspec)
 {
   GstFFMpegVidEnc *ffmpegenc;
 
-  /* It's not null if we got it, but it might not be ours */
   ffmpegenc = (GstFFMpegVidEnc *) (object);
 
   switch (prop_id) {
-    case PROP_BIT_RATE:
-      g_value_set_int (value, ffmpegenc->bitrate);
+    case PROP_QUANTIZER:
+      g_value_set_float (value, ffmpegenc->quantizer);
       break;
-    case PROP_GOP_SIZE:
-      g_value_set_int (value, ffmpegenc->gop_size);
+    case PROP_PASS:
+      g_value_set_enum (value, ffmpegenc->pass);
       break;
-    case PROP_ME_METHOD:
-      g_value_set_enum (value, ffmpegenc->me_method);
-      break;
-    case PROP_BUFSIZE:
-      g_value_set_int (value, ffmpegenc->buffer_size);
-      break;
-    case PROP_RTP_PAYLOAD_SIZE:
-      g_value_set_int (value, ffmpegenc->rtp_payload_size);
-      break;
-    case PROP_COMPLIANCE:
-      g_value_set_enum (value, ffmpegenc->compliance);
-      break;
-    case PROP_MAX_THREADS:
-      g_value_set_int (value, ffmpegenc->max_threads);
+    case PROP_FILENAME:
+      g_value_take_string (value, g_strdup (ffmpegenc->filename));
       break;
     default:
       if (!gst_ffmpeg_cfg_get_property (object, value, pspec))
@@ -946,10 +808,6 @@ gst_ffmpegvidenc_stop (GstVideoEncoder * encoder)
   gst_ffmpeg_avcodec_close (ffmpegenc->context);
   ffmpegenc->opened = FALSE;
 
-  if (ffmpegenc->file) {
-    fclose (ffmpegenc->file);
-    ffmpegenc->file = NULL;
-  }
   if (ffmpegenc->input_state) {
     gst_video_codec_state_unref (ffmpegenc->input_state);
     ffmpegenc->input_state = NULL;
diff --git a/ext/libav/gstavvidenc.h b/ext/libav/gstavvidenc.h
index 92312bd..7ef0c3b 100644
--- a/ext/libav/gstavvidenc.h
+++ b/ext/libav/gstavvidenc.h
@@ -24,12 +24,12 @@
 #ifndef __GST_FFMPEGVIDENC_H__
 #define __GST_FFMPEGVIDENC_H__
 
-G_BEGIN_DECLS
-
 #include <gst/gst.h>
 #include <gst/video/gstvideoencoder.h>
 #include <libavcodec/avcodec.h>
 
+G_BEGIN_DECLS
+
 typedef struct _GstFFMpegVidEnc GstFFMpegVidEnc;
 
 struct _GstFFMpegVidEnc
@@ -42,34 +42,18 @@ struct _GstFFMpegVidEnc
   AVFrame *picture;
   gboolean opened;
   gboolean discont;
-
-  /* cache */
-  gint bitrate;
-  gint me_method;
-  gint gop_size;
-  gint buffer_size;
-  gint rtp_payload_size;
-  gint compliance;
-  gint max_threads;
-
-  guint8 *working_buf;
-  gsize working_buf_size;
-
-  /* settings with some special handling */
   guint pass;
   gfloat quantizer;
-  gchar *filename;
-  guint lmin;
-  guint lmax;
-  gint max_key_interval;
-  gboolean interlaced;
 
   /* statistics file */
+  gchar *filename;
   FILE *file;
 
-  /* other settings are copied over straight,
-   * include a context here, rather than copy-and-past it from avcodec.h */
-  AVCodecContext config;
+  /* cache */
+  guint8 *working_buf;
+  gsize working_buf_size;
+
+  AVCodecContext *refcontext;
 };
 
 typedef struct _GstFFMpegVidEncClass GstFFMpegVidEncClass;
-- 
2.17.1

