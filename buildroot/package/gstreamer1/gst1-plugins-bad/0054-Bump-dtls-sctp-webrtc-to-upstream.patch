From ca2afe7f6f4cf043f4609c05961e28ea73cc6e5e Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Wed, 18 Sep 2019 18:22:24 +0800
Subject: [PATCH 54/60] Bump dtls/sctp/webrtc to upstream

Bump to:
2af240288 vulkan: add device provider implementation

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 configure.ac                                |   21 +
 ext/Makefile.am                             |    8 +
 ext/dtls/Makefile.am                        |    2 +-
 ext/dtls/gstdtlsagent.c                     |   42 +-
 ext/dtls/gstdtlscertificate.c               |   29 +-
 ext/dtls/gstdtlsconnection.c                |   95 +-
 ext/dtls/gstdtlsdec.c                       |   17 +-
 ext/dtls/gstdtlssrtpdec.c                   |    3 +-
 ext/dtls/meson.build                        |    7 +-
 ext/sctp/Makefile.am                        |   22 +
 ext/sctp/gstsctpdec.c                       |  656 ++++
 ext/sctp/gstsctpdec.h                       |   66 +
 ext/sctp/gstsctpenc.c                       |  954 ++++++
 ext/sctp/gstsctpenc.h                       |   77 +
 ext/sctp/gstsctpplugin.c                    |   53 +
 ext/sctp/meson.build                        |   37 +
 ext/sctp/sctpassociation.c                  |  841 +++++
 ext/sctp/sctpassociation.h                  |  123 +
 ext/webrtc/Makefile.am                      |    8 +-
 ext/webrtc/fwd.h                            |    4 +
 ext/webrtc/gstwebrtcbin.c                   | 3245 ++++++++++++++-----
 ext/webrtc/gstwebrtcbin.h                   |   30 +-
 ext/webrtc/gstwebrtcice.c                   |  351 +-
 ext/webrtc/gstwebrtcice.h                   |    4 +
 ext/webrtc/gstwebrtcstats.c                 |  351 +-
 ext/webrtc/icestream.c                      |   18 +-
 ext/webrtc/meson.build                      |   13 +-
 ext/webrtc/nicetransport.c                  |   20 +-
 ext/webrtc/sctptransport.c                  |  270 ++
 ext/webrtc/sctptransport.h                  |   65 +
 ext/webrtc/transportreceivebin.c            |  169 +-
 ext/webrtc/transportreceivebin.h            |    4 +
 ext/webrtc/transportsendbin.c               |   26 +-
 ext/webrtc/transportstream.c                |   75 +
 ext/webrtc/transportstream.h                |   18 +
 ext/webrtc/utils.c                          |   79 +-
 ext/webrtc/utils.h                          |   20 +
 ext/webrtc/webrtcdatachannel.c              | 1351 ++++++++
 ext/webrtc/webrtcdatachannel.h              |   85 +
 ext/webrtc/webrtcsdp.c                      |  289 +-
 ext/webrtc/webrtcsdp.h                      |   32 +-
 ext/webrtc/webrtctransceiver.c              |   39 +-
 ext/webrtc/webrtctransceiver.h              |    5 +
 gst-libs/gst/Makefile.am                    |    6 +-
 gst-libs/gst/sctp/Makefile.am               |   26 +
 gst-libs/gst/sctp/meson.build               |   26 +
 gst-libs/gst/sctp/sctp-prelude.h            |   31 +
 gst-libs/gst/sctp/sctpreceivemeta.c         |   93 +
 gst-libs/gst/sctp/sctpreceivemeta.h         |   57 +
 gst-libs/gst/sctp/sctpsendmeta.c            |  102 +
 gst-libs/gst/sctp/sctpsendmeta.h            |   69 +
 gst-libs/gst/webrtc/Makefile.am             |    1 +
 gst-libs/gst/webrtc/dtlstransport.c         |    2 +-
 gst-libs/gst/webrtc/dtlstransport.h         |    5 +
 gst-libs/gst/webrtc/icetransport.c          |    2 +-
 gst-libs/gst/webrtc/icetransport.h          |    5 +
 gst-libs/gst/webrtc/meson.build             |   25 +-
 gst-libs/gst/webrtc/rtcsessiondescription.c |    2 +-
 gst-libs/gst/webrtc/rtcsessiondescription.h |    5 +-
 gst-libs/gst/webrtc/rtpreceiver.c           |    2 +-
 gst-libs/gst/webrtc/rtpreceiver.h           |    8 +-
 gst-libs/gst/webrtc/rtpsender.c             |    2 +-
 gst-libs/gst/webrtc/rtpsender.h             |    5 +
 gst-libs/gst/webrtc/rtptransceiver.c        |   30 +-
 gst-libs/gst/webrtc/rtptransceiver.h        |    6 +
 gst-libs/gst/webrtc/webrtc_fwd.h            |  236 +-
 pkgconfig/Makefile.am                       |    5 +-
 pkgconfig/gstreamer-sctp-uninstalled.pc.in  |   12 +
 pkgconfig/gstreamer-sctp.pc.in              |   12 +
 69 files changed, 9020 insertions(+), 1379 deletions(-)
 create mode 100644 ext/sctp/Makefile.am
 create mode 100644 ext/sctp/gstsctpdec.c
 create mode 100644 ext/sctp/gstsctpdec.h
 create mode 100644 ext/sctp/gstsctpenc.c
 create mode 100644 ext/sctp/gstsctpenc.h
 create mode 100644 ext/sctp/gstsctpplugin.c
 create mode 100644 ext/sctp/meson.build
 create mode 100644 ext/sctp/sctpassociation.c
 create mode 100644 ext/sctp/sctpassociation.h
 create mode 100644 ext/webrtc/sctptransport.c
 create mode 100644 ext/webrtc/sctptransport.h
 create mode 100644 ext/webrtc/webrtcdatachannel.c
 create mode 100644 ext/webrtc/webrtcdatachannel.h
 create mode 100644 gst-libs/gst/sctp/Makefile.am
 create mode 100644 gst-libs/gst/sctp/meson.build
 create mode 100644 gst-libs/gst/sctp/sctp-prelude.h
 create mode 100644 gst-libs/gst/sctp/sctpreceivemeta.c
 create mode 100644 gst-libs/gst/sctp/sctpreceivemeta.h
 create mode 100644 gst-libs/gst/sctp/sctpsendmeta.c
 create mode 100644 gst-libs/gst/sctp/sctpsendmeta.h
 create mode 100644 pkgconfig/gstreamer-sctp-uninstalled.pc.in
 create mode 100644 pkgconfig/gstreamer-sctp.pc.in

diff --git a/configure.ac b/configure.ac
index 34b5d1faa..ac5677af4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2310,6 +2310,22 @@ AG_GST_CHECK_FEATURE(WEBRTC, [WebRTC], webrtc, [
   ])
 ])
 
+dnl *** usrsctp ***
+translit(dnm, m, l) AM_CONDITIONAL(USE_SCTP, true)
+AG_GST_CHECK_FEATURE(SCTP, [sctp plug-in], sctp, [
+  AC_CHECK_HEADER(usrsctp.h, [
+    AC_CHECK_LIB(usrsctp, usrsctp_init, [
+      USRSCTP_LIBS="-lusrsctp"
+      AC_SUBST(USRSCTP_LIBS)
+      HAVE_SCTP=yes
+    ], [
+      HAVE_SCTP=no
+    ])
+  ], [
+    HAVE_SCTP=no
+  ])
+])
+
 else
 
 dnl not building plugins with external dependencies,
@@ -2393,6 +2409,7 @@ AM_CONDITIONAL(USE_X265, false)
 AM_CONDITIONAL(USE_DTLS, false)
 AM_CONDITIONAL(USE_VULKAN, false)
 AM_CONDITIONAL(USE_TTML, false)
+AM_CONDITIONAL(USE_SCTP, false)
 
 fi dnl of EXT plugins
 
@@ -2565,6 +2582,7 @@ gst-libs/gst/interfaces/Makefile
 gst-libs/gst/isoff/Makefile
 gst-libs/gst/codecparsers/Makefile
 gst-libs/gst/mpegts/Makefile
+gst-libs/gst/sctp/Makefile
 gst-libs/gst/uridownloader/Makefile
 gst-libs/gst/wayland/Makefile
 gst-libs/gst/webrtc/Makefile
@@ -2666,6 +2684,7 @@ ext/rsvg/Makefile
 ext/resindvd/Makefile
 ext/rtmp/Makefile
 ext/sbc/Makefile
+ext/sctp/Makefile
 ext/smoothstreaming/Makefile
 ext/sndfile/Makefile
 ext/soundtouch/Makefile
@@ -2702,6 +2721,8 @@ pkgconfig/gstreamer-mpegts.pc
 pkgconfig/gstreamer-mpegts-uninstalled.pc
 pkgconfig/gstreamer-player.pc
 pkgconfig/gstreamer-player-uninstalled.pc
+pkgconfig/gstreamer-sctp.pc
+pkgconfig/gstreamer-sctp-uninstalled.pc
 pkgconfig/gstreamer-wayland.pc
 pkgconfig/gstreamer-wayland-uninstalled.pc
 pkgconfig/gstreamer-webrtc.pc
diff --git a/ext/Makefile.am b/ext/Makefile.am
index 4de92141d..d4d5e964b 100644
--- a/ext/Makefile.am
+++ b/ext/Makefile.am
@@ -280,6 +280,12 @@ else
 SBC_DIR=
 endif
 
+if USE_SCTP
+SCTP_DIR=sctp
+else
+SCTP_DIR=
+endif
+
 if USE_SMOOTHSTREAMING
 SMOOTHSTREAMING_DIR = smoothstreaming
 else
@@ -448,6 +454,7 @@ SUBDIRS=\
 	$(OPUS_DIR) \
 	$(RSVG_DIR) \
 	$(SBC_DIR) \
+	$(SCTP_DIR) \
 	$(SMOOTHSTREAMING_DIR) \
 	$(SMOOTHWAVE_DIR) \
 	$(SNDFILE_DIR) \
@@ -515,6 +522,7 @@ DIST_SUBDIRS = \
 	rsvg \
 	resindvd \
 	sbc \
+	sctp \
 	smoothstreaming \
 	sndfile \
 	soundtouch \
diff --git a/ext/dtls/Makefile.am b/ext/dtls/Makefile.am
index 20a95f3f8..63cbcd866 100644
--- a/ext/dtls/Makefile.am
+++ b/ext/dtls/Makefile.am
@@ -18,7 +18,7 @@ libgstdtls_la_CFLAGS = \
     $(GST_CFLAGS) \
     $(DTLS_CFLAGS)
 
-libgstdtls_la_LIBADD = $(GST_LIBS) $(GST_BASE_LIBS) $(DTLS_LIBS)
+libgstdtls_la_LIBADD = $(GST_LIBS) $(GST_BASE_LIBS) $(DTLS_LIBS) $(WINSOCK2_LIBS)
 libgstdtls_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
 
 noinst_HEADERS = \
diff --git a/ext/dtls/gstdtlsagent.c b/ext/dtls/gstdtlsagent.c
index 55500f95b..4070c7957 100644
--- a/ext/dtls/gstdtlsagent.c
+++ b/ext/dtls/gstdtlsagent.c
@@ -42,10 +42,6 @@
 GST_DEBUG_CATEGORY_STATIC (gst_dtls_agent_debug);
 #define GST_CAT_DEFAULT gst_dtls_agent_debug
 
-G_DEFINE_TYPE (GstDtlsAgent, gst_dtls_agent, G_TYPE_OBJECT);
-
-#define GST_DTLS_AGENT_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), GST_TYPE_DTLS_AGENT, GstDtlsAgentPrivate))
-
 enum
 {
   PROP_0,
@@ -62,6 +58,8 @@ struct _GstDtlsAgentPrivate
   GstDtlsCertificate *certificate;
 };
 
+G_DEFINE_TYPE_WITH_PRIVATE (GstDtlsAgent, gst_dtls_agent, G_TYPE_OBJECT);
+
 static void gst_dtls_agent_finalize (GObject * gobject);
 static void gst_dtls_agent_set_property (GObject *, guint prop_id,
     const GValue *, GParamSpec *);
@@ -122,14 +120,13 @@ _gst_dtls_init_openssl (void)
           OPENSSL_VERSION_TEXT);
       g_assert_not_reached ();
     }
-
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     GST_INFO_OBJECT (NULL, "initializing openssl %lx", OPENSSL_VERSION_NUMBER);
     SSL_library_init ();
     SSL_load_error_strings ();
     ERR_load_BIO_strings ();
 
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
-    {
+    if (!CRYPTO_get_locking_callback ()) {
       gint i;
       gint num_locks;
       num_locks = CRYPTO_num_locks ();
@@ -151,8 +148,6 @@ gst_dtls_agent_class_init (GstDtlsAgentClass * klass)
 {
   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 
-  g_type_class_add_private (klass, sizeof (GstDtlsAgentPrivate));
-
   gobject_class->set_property = gst_dtls_agent_set_property;
   gobject_class->finalize = gst_dtls_agent_finalize;
 
@@ -168,10 +163,18 @@ gst_dtls_agent_class_init (GstDtlsAgentClass * klass)
   _gst_dtls_init_openssl ();
 }
 
+static int
+ssl_warn_cb (const char *str, size_t len, void *u)
+{
+  GstDtlsAgent *self = u;
+  GST_WARNING_OBJECT (self, "ssl error: %s", str);
+  return 0;
+}
+
 static void
 gst_dtls_agent_init (GstDtlsAgent * self)
 {
-  GstDtlsAgentPrivate *priv = GST_DTLS_AGENT_GET_PRIVATE (self);
+  GstDtlsAgentPrivate *priv = gst_dtls_agent_get_instance_private (self);
   self->priv = priv;
 
   ERR_clear_error ();
@@ -181,23 +184,24 @@ gst_dtls_agent_init (GstDtlsAgent * self)
 #else
   priv->ssl_context = SSL_CTX_new (DTLSv1_method ());
 #endif
-  if (ERR_peek_error () || !priv->ssl_context) {
-    char buf[512];
-
-    priv->ssl_context = NULL;
-
-    GST_WARNING_OBJECT (self, "Error creating SSL Context: %s",
-        ERR_error_string (ERR_get_error (), buf));
+  if (!priv->ssl_context) {
+    GST_WARNING_OBJECT (self, "Error creating SSL Context");
+    ERR_print_errors_cb (ssl_warn_cb, self);
 
     g_return_if_reached ();
   }
+  /* If any non-fatal issues happened, print them out and carry on */
+  if (ERR_peek_error ()) {
+    ERR_print_errors_cb (ssl_warn_cb, self);
+    ERR_clear_error ();
+  }
 
   SSL_CTX_set_verify_depth (priv->ssl_context, 2);
   SSL_CTX_set_tlsext_use_srtp (priv->ssl_context, "SRTP_AES128_CM_SHA1_80");
   SSL_CTX_set_cipher_list (priv->ssl_context,
       "ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH");
   SSL_CTX_set_read_ahead (priv->ssl_context, 1);
-#if OPENSSL_VERSION_NUMBER >= 0x1000200fL
+#if (OPENSSL_VERSION_NUMBER >= 0x1000200fL) && (OPENSSL_VERSION_NUMBER < 0x10100000L)
   SSL_CTX_set_ecdh_auto (priv->ssl_context, 1);
 #endif
 }
@@ -210,6 +214,8 @@ gst_dtls_agent_finalize (GObject * gobject)
   SSL_CTX_free (priv->ssl_context);
   priv->ssl_context = NULL;
 
+  g_clear_object (&priv->certificate);
+
   GST_DEBUG_OBJECT (gobject, "finalized");
 
   G_OBJECT_CLASS (gst_dtls_agent_parent_class)->finalize (gobject);
diff --git a/ext/dtls/gstdtlscertificate.c b/ext/dtls/gstdtlscertificate.c
index c2d9bb217..4e4484942 100644
--- a/ext/dtls/gstdtlscertificate.c
+++ b/ext/dtls/gstdtlscertificate.c
@@ -45,17 +45,18 @@
 #endif
 #endif
 
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
 #include <openssl/ssl.h>
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#define X509_getm_notBefore X509_get_notBefore
+#define X509_getm_notAfter X509_get_notAfter
+#endif
+
 GST_DEBUG_CATEGORY_STATIC (gst_dtls_certificate_debug);
 #define GST_CAT_DEFAULT gst_dtls_certificate_debug
 
-G_DEFINE_TYPE_WITH_CODE (GstDtlsCertificate, gst_dtls_certificate,
-    G_TYPE_OBJECT, GST_DEBUG_CATEGORY_INIT (gst_dtls_certificate_debug,
-        "dtlscertificate", 0, "DTLS Certificate"));
-
-#define GST_DTLS_CERTIFICATE_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), GST_TYPE_DTLS_CERTIFICATE, GstDtlsCertificatePrivate))
-
 enum
 {
   PROP_0,
@@ -75,6 +76,11 @@ struct _GstDtlsCertificatePrivate
   gchar *pem;
 };
 
+G_DEFINE_TYPE_WITH_CODE (GstDtlsCertificate, gst_dtls_certificate,
+    G_TYPE_OBJECT, G_ADD_PRIVATE (GstDtlsCertificate)
+    GST_DEBUG_CATEGORY_INIT (gst_dtls_certificate_debug,
+        "dtlscertificate", 0, "DTLS Certificate"));
+
 static void gst_dtls_certificate_finalize (GObject * gobject);
 static void gst_dtls_certificate_set_property (GObject *, guint prop_id,
     const GValue *, GParamSpec *);
@@ -89,8 +95,6 @@ gst_dtls_certificate_class_init (GstDtlsCertificateClass * klass)
 {
   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 
-  g_type_class_add_private (klass, sizeof (GstDtlsCertificatePrivate));
-
   gobject_class->set_property = gst_dtls_certificate_set_property;
   gobject_class->get_property = gst_dtls_certificate_get_property;
 
@@ -111,8 +115,9 @@ gst_dtls_certificate_class_init (GstDtlsCertificateClass * klass)
 static void
 gst_dtls_certificate_init (GstDtlsCertificate * self)
 {
-  GstDtlsCertificatePrivate *priv = GST_DTLS_CERTIFICATE_GET_PRIVATE (self);
-  self->priv = priv;
+  GstDtlsCertificatePrivate *priv;
+
+  self->priv = priv = gst_dtls_certificate_get_instance_private (self);
 
   priv->x509 = NULL;
   priv->private_key = NULL;
@@ -240,8 +245,8 @@ init_generated (GstDtlsCertificate * self)
 
   X509_set_version (priv->x509, 2);
   ASN1_INTEGER_set (X509_get_serialNumber (priv->x509), 0);
-  X509_gmtime_adj (X509_get_notBefore (priv->x509), 0);
-  X509_gmtime_adj (X509_get_notAfter (priv->x509), 31536000L);  /* A year */
+  X509_gmtime_adj (X509_getm_notBefore (priv->x509), 0);
+  X509_gmtime_adj (X509_getm_notAfter (priv->x509), 31536000L); /* A year */
   X509_set_pubkey (priv->x509, priv->private_key);
 
   name = X509_get_subject_name (priv->x509);
diff --git a/ext/dtls/gstdtlsconnection.c b/ext/dtls/gstdtlsconnection.c
index 77ed95e5c..244ec997c 100644
--- a/ext/dtls/gstdtlsconnection.c
+++ b/ext/dtls/gstdtlsconnection.c
@@ -42,15 +42,15 @@
 #include <openssl/err.h>
 #include <openssl/ssl.h>
 
+#ifdef G_OS_WIN32
+#include <winsock2.h>
+#else
 #include <string.h>
+#include <errno.h>
+#endif
 
 GST_DEBUG_CATEGORY_STATIC (gst_dtls_connection_debug);
 #define GST_CAT_DEFAULT gst_dtls_connection_debug
-G_DEFINE_TYPE_WITH_CODE (GstDtlsConnection, gst_dtls_connection, G_TYPE_OBJECT,
-    GST_DEBUG_CATEGORY_INIT (gst_dtls_connection_debug, "dtlsconnection", 0,
-        "DTLS Connection"));
-
-#define GST_DTLS_CONNECTION_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), GST_TYPE_DTLS_CONNECTION, GstDtlsConnectionPrivate))
 
 #define SRTP_KEY_LEN 16
 #define SRTP_SALT_LEN 14
@@ -99,6 +99,11 @@ struct _GstDtlsConnectionPrivate
   GThreadPool *thread_pool;
 };
 
+G_DEFINE_TYPE_WITH_CODE (GstDtlsConnection, gst_dtls_connection, G_TYPE_OBJECT,
+    G_ADD_PRIVATE (GstDtlsConnection)
+    GST_DEBUG_CATEGORY_INIT (gst_dtls_connection_debug, "dtlsconnection", 0,
+        "DTLS Connection"));
+
 static void gst_dtls_connection_finalize (GObject * gobject);
 static void gst_dtls_connection_set_property (GObject *, guint prop_id,
     const GValue *, GParamSpec *);
@@ -121,8 +126,6 @@ gst_dtls_connection_class_init (GstDtlsConnectionClass * klass)
 {
   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 
-  g_type_class_add_private (klass, sizeof (GstDtlsConnectionPrivate));
-
   gobject_class->set_property = gst_dtls_connection_set_property;
 
   connection_ex_index =
@@ -163,8 +166,9 @@ gst_dtls_connection_class_init (GstDtlsConnectionClass * klass)
 static void
 gst_dtls_connection_init (GstDtlsConnection * self)
 {
-  GstDtlsConnectionPrivate *priv = GST_DTLS_CONNECTION_GET_PRIVATE (self);
-  self->priv = priv;
+  GstDtlsConnectionPrivate *priv;
+
+  self->priv = priv = gst_dtls_connection_get_instance_private (self);
 
   priv->ssl = NULL;
   priv->bio = NULL;
@@ -708,36 +712,53 @@ beach:
   self->priv->keys_exported = TRUE;
 }
 
+static int
+ssl_warn_cb (const char *str, size_t len, void *u)
+{
+  GstDtlsConnection *self = u;
+  GST_WARNING_OBJECT (self, "ssl error: %s", str);
+  return 0;
+}
+
+static int
+ssl_err_cb (const char *str, size_t len, void *u)
+{
+  GstDtlsConnection *self = u;
+  GST_ERROR_OBJECT (self, "ssl error: %s", str);
+  return 0;
+}
+
 static void
 openssl_poll (GstDtlsConnection * self)
 {
   int ret;
-  char buf[512];
   int error;
 
   log_state (self, "poll: before handshake");
 
+  ERR_clear_error ();
   ret = SSL_do_handshake (self->priv->ssl);
 
   log_state (self, "poll: after handshake");
 
-  if (ret == 1) {
-    if (!self->priv->keys_exported) {
-      GST_INFO_OBJECT (self,
-          "handshake just completed successfully, exporting keys");
-      export_srtp_keys (self);
-    } else {
-      GST_INFO_OBJECT (self, "handshake is completed");
-    }
-    return;
-  } else {
-    if (ret == 0) {
+  switch (ret) {
+    case 1:
+      if (!self->priv->keys_exported) {
+        GST_INFO_OBJECT (self,
+            "handshake just completed successfully, exporting keys");
+        export_srtp_keys (self);
+      } else {
+        GST_INFO_OBJECT (self, "handshake is completed");
+      }
+      return;
+    case 0:
       GST_DEBUG_OBJECT (self, "do_handshake encountered EOF");
-    } else if (ret == -1) {
-      GST_WARNING_OBJECT (self, "do_handshake encountered BIO error");
-    } else {
+      break;
+    case -1:
+      GST_DEBUG_OBJECT (self, "do_handshake encountered BIO error");
+      break;
+    default:
       GST_DEBUG_OBJECT (self, "do_handshake returned %d", ret);
-    }
   }
 
   error = SSL_get_error (self->priv->ssl, ret);
@@ -747,9 +768,9 @@ openssl_poll (GstDtlsConnection * self)
       GST_WARNING_OBJECT (self, "no error, handshake should be done");
       break;
     case SSL_ERROR_SSL:
-      GST_LOG_OBJECT (self, "SSL error %d: %s", error,
-          ERR_error_string (ERR_get_error (), buf));
-      break;
+      GST_ERROR_OBJECT (self, "SSL error");
+      ERR_print_errors_cb (ssl_err_cb, self);
+      return;
     case SSL_ERROR_WANT_READ:
       GST_LOG_OBJECT (self, "SSL wants read");
       break;
@@ -757,12 +778,26 @@ openssl_poll (GstDtlsConnection * self)
       GST_LOG_OBJECT (self, "SSL wants write");
       break;
     case SSL_ERROR_SYSCALL:{
-      GST_LOG_OBJECT (self, "SSL syscall (error) : %lu", ERR_get_error ());
+      gchar message[1024] = "<unknown>";
+      gint syserror;
+#ifdef G_OS_WIN32
+      syserror = WSAGetLastError ();
+      FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM, NULL, syserror, 0, message,
+          sizeof message, NULL);
+#else
+      syserror = errno;
+      strerror_r (syserror, message, sizeof message);
+#endif
+      GST_CAT_LEVEL_LOG (GST_CAT_DEFAULT,
+          syserror != 0 ? GST_LEVEL_WARNING : GST_LEVEL_LOG,
+          self, "SSL syscall error: errno %d: %s", syserror, message);
       break;
     }
     default:
       GST_WARNING_OBJECT (self, "Unknown SSL error: %d, ret: %d", error, ret);
   }
+
+  ERR_print_errors_cb (ssl_warn_cb, self);
 }
 
 static int
@@ -884,6 +919,8 @@ bio_method_write (BIO * bio, const char *data, int size)
     g_value_set_int (&values[2], size);
 
     g_closure_invoke (self->priv->send_closure, NULL, 3, values, NULL);
+
+    g_value_unset (&values[0]);
   }
 
   return size;
diff --git a/ext/dtls/gstdtlsdec.c b/ext/dtls/gstdtlsdec.c
index 87b822131..a1ae7205a 100644
--- a/ext/dtls/gstdtlsdec.c
+++ b/ext/dtls/gstdtlsdec.c
@@ -141,7 +141,8 @@ gst_dtls_dec_class_init (GstDtlsDecClass * klass)
       g_param_spec_string ("pem",
       "PEM string",
       "A string containing a X509 certificate and RSA private key in PEM format",
-      DEFAULT_PEM, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+      DEFAULT_PEM,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
   properties[PROP_PEER_PEM] =
       g_param_spec_string ("peer-pem",
@@ -587,9 +588,12 @@ get_agent_by_pem (const gchar * pem)
   if (!pem) {
     if (g_once_init_enter (&generated_cert_agent)) {
       GstDtlsAgent *new_agent;
+      GObject *certificate;
 
+      certificate = g_object_new (GST_TYPE_DTLS_CERTIFICATE, NULL);
       new_agent = g_object_new (GST_TYPE_DTLS_AGENT, "certificate",
-          g_object_new (GST_TYPE_DTLS_CERTIFICATE, NULL), NULL);
+          certificate, NULL);
+      g_object_unref (certificate);
 
       GST_DEBUG_OBJECT (generated_cert_agent,
           "no agent with generated cert found, creating new");
@@ -612,9 +616,12 @@ get_agent_by_pem (const gchar * pem)
     agent = GST_DTLS_AGENT (g_hash_table_lookup (agent_table, pem));
 
     if (!agent) {
-      agent = g_object_new (GST_TYPE_DTLS_AGENT,
-          "certificate", g_object_new (GST_TYPE_DTLS_CERTIFICATE, "pem", pem,
-              NULL), NULL);
+      GObject *certificate;
+
+      certificate = g_object_new (GST_TYPE_DTLS_CERTIFICATE, "pem", pem, NULL);
+      agent = g_object_new (GST_TYPE_DTLS_AGENT, "certificate", certificate,
+          NULL);
+      g_object_unref (certificate);
 
       g_object_weak_ref (G_OBJECT (agent), (GWeakNotify) agent_weak_ref_notify,
           (gpointer) g_strdup (pem));
diff --git a/ext/dtls/gstdtlssrtpdec.c b/ext/dtls/gstdtlssrtpdec.c
index 983621001..949f20d20 100644
--- a/ext/dtls/gstdtlssrtpdec.c
+++ b/ext/dtls/gstdtlssrtpdec.c
@@ -123,7 +123,8 @@ gst_dtls_srtp_dec_class_init (GstDtlsSrtpDecClass * klass)
       g_param_spec_string ("pem",
       "PEM string",
       "A string containing a X509 certificate and RSA private key in PEM format",
-      DEFAULT_PEM, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+      DEFAULT_PEM,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
   properties[PROP_PEER_PEM] =
       g_param_spec_string ("peer-pem",
diff --git a/ext/dtls/meson.build b/ext/dtls/meson.build
index 1ce99dcbd..74babae17 100644
--- a/ext/dtls/meson.build
+++ b/ext/dtls/meson.build
@@ -11,15 +11,18 @@ dtls_sources = [
   'plugin.c',
 ]
 
-libcrypto_dep = dependency('libcrypto', required : false)
+openssl_dep = dependency('openssl', version : '>= 1.0.1', required : get_option('dtls'))
+libcrypto_dep = dependency('libcrypto', required : get_option('dtls'))
 
 if openssl_dep.found() and libcrypto_dep.found()
   gstdtls = library('gstdtls',
     dtls_sources,
     c_args : gst_plugins_bad_args,
     include_directories : [configinc],
-    dependencies : [gst_dep, libcrypto_dep, openssl_dep],
+    dependencies : [gst_dep, libcrypto_dep, openssl_dep] + winsock2,
     install : true,
     install_dir : plugins_install_dir,
   )
+  pkgconfig.generate(gstdtls, install_dir : plugins_pkgconfig_install_dir)
+  plugins += [gstdtls]
 endif
diff --git a/ext/sctp/Makefile.am b/ext/sctp/Makefile.am
new file mode 100644
index 000000000..957ee6a93
--- /dev/null
+++ b/ext/sctp/Makefile.am
@@ -0,0 +1,22 @@
+plugin_LTLIBRARIES = libgstsctp.la
+
+libgstsctp_la_SOURCES = \
+    gstsctpplugin.c \
+    sctpassociation.c \
+    gstsctpenc.c \
+    gstsctpdec.c
+
+libgstsctp_la_CFLAGS = \
+    $(GST_PLUGINS_BASE_CFLAGS) \
+    $(GST_BASE_CFLAGS) \
+    $(GST_CFLAGS) \
+    $(USRSCTP_CFLAGS) \
+    -I$(top_srcdir)/gst-libs
+
+libgstsctp_la_LIBADD = $(GST_LIBS) $(GST_BASE_LIBS) $(USRSCTP_LIBS) $(top_builddir)/gst-libs/gst/sctp/libgstsctp-1.0.la
+libgstsctp_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+
+noinst_HEADERS = \
+    sctpassociation.h \
+    gstsctpenc.h \
+    gstsctpdec.h
diff --git a/ext/sctp/gstsctpdec.c b/ext/sctp/gstsctpdec.c
new file mode 100644
index 000000000..870a3ba00
--- /dev/null
+++ b/ext/sctp/gstsctpdec.c
@@ -0,0 +1,656 @@
+/*
+ * Copyright (c) 2015, Collabora Ltd.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this
+ * list of conditions and the following disclaimer in the documentation and/or other
+ * materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include "gstsctpdec.h"
+
+#include <gst/sctp/sctpreceivemeta.h>
+#include <gst/base/gstdataqueue.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+
+GST_DEBUG_CATEGORY_STATIC (gst_sctp_dec_debug_category);
+#define GST_CAT_DEFAULT gst_sctp_dec_debug_category
+
+#define gst_sctp_dec_parent_class parent_class
+G_DEFINE_TYPE (GstSctpDec, gst_sctp_dec, GST_TYPE_ELEMENT);
+
+static GstStaticPadTemplate sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink", GST_PAD_SINK,
+    GST_PAD_ALWAYS, GST_STATIC_CAPS ("application/x-sctp"));
+
+static GstStaticPadTemplate src_template =
+GST_STATIC_PAD_TEMPLATE ("src_%u", GST_PAD_SRC,
+    GST_PAD_SOMETIMES, GST_STATIC_CAPS_ANY);
+
+enum
+{
+  SIGNAL_RESET_STREAM,
+  NUM_SIGNALS
+};
+
+static guint signals[NUM_SIGNALS];
+
+enum
+{
+  PROP_0,
+
+  PROP_GST_SCTP_ASSOCIATION_ID,
+  PROP_LOCAL_SCTP_PORT,
+
+  NUM_PROPERTIES
+};
+
+static GParamSpec *properties[NUM_PROPERTIES];
+
+#define DEFAULT_GST_SCTP_ASSOCIATION_ID 1
+#define DEFAULT_LOCAL_SCTP_PORT 0
+#define MAX_SCTP_PORT 65535
+#define MAX_GST_SCTP_ASSOCIATION_ID 65535
+#define MAX_STREAM_ID 65535
+
+GType gst_sctp_dec_pad_get_type (void);
+
+#define GST_TYPE_SCTP_DEC_PAD (gst_sctp_dec_pad_get_type())
+#define GST_SCTP_DEC_PAD(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_SCTP_DEC_PAD, GstSctpDecPad))
+#define GST_SCTP_DEC_PAD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_SCTP_DEC_PAD, GstSctpDecPadClass))
+#define GST_IS_SCTP_DEC_PAD(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_SCTP_DEC_PAD))
+#define GST_IS_SCTP_DEC_PAD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_SCTP_DEC_PAD))
+
+typedef struct _GstSctpDecPad GstSctpDecPad;
+typedef GstPadClass GstSctpDecPadClass;
+
+struct _GstSctpDecPad
+{
+  GstPad parent;
+
+  GstDataQueue *packet_queue;
+};
+
+G_DEFINE_TYPE (GstSctpDecPad, gst_sctp_dec_pad, GST_TYPE_PAD);
+
+static void
+gst_sctp_dec_pad_finalize (GObject * object)
+{
+  GstSctpDecPad *self = GST_SCTP_DEC_PAD (object);
+
+  gst_object_unref (self->packet_queue);
+
+  G_OBJECT_CLASS (gst_sctp_dec_pad_parent_class)->finalize (object);
+}
+
+static gboolean
+data_queue_check_full_cb (GstDataQueue * queue, guint visible, guint bytes,
+    guint64 time, gpointer user_data)
+{
+  /* FIXME: Are we full at some point and block? */
+  return FALSE;
+}
+
+static void
+data_queue_empty_cb (GstDataQueue * queue, gpointer user_data)
+{
+}
+
+static void
+data_queue_full_cb (GstDataQueue * queue, gpointer user_data)
+{
+}
+
+static void
+gst_sctp_dec_pad_class_init (GstSctpDecPadClass * klass)
+{
+  GObjectClass *gobject_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+
+  gobject_class->finalize = gst_sctp_dec_pad_finalize;
+}
+
+static void
+gst_sctp_dec_pad_init (GstSctpDecPad * self)
+{
+  self->packet_queue = gst_data_queue_new (data_queue_check_full_cb,
+      data_queue_full_cb, data_queue_empty_cb, NULL);
+}
+
+static void gst_sctp_dec_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+static void gst_sctp_dec_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+static GstStateChangeReturn gst_sctp_dec_change_state (GstElement * element,
+    GstStateChange transition);
+static GstFlowReturn gst_sctp_dec_packet_chain (GstPad * pad, GstSctpDec * self,
+    GstBuffer * buf);
+static gboolean gst_sctp_dec_packet_event (GstPad * pad, GstSctpDec * self,
+    GstEvent * event);
+static void gst_sctp_data_srcpad_loop (GstPad * pad);
+
+static gboolean configure_association (GstSctpDec * self);
+static void on_gst_sctp_association_stream_reset (GstSctpAssociation *
+    gst_sctp_association, guint16 stream_id, GstSctpDec * self);
+static void on_receive (GstSctpAssociation * gst_sctp_association, guint8 * buf,
+    gsize length, guint16 stream_id, guint ppid, gpointer user_data);
+static void stop_srcpad_task (GstPad * pad);
+static void stop_all_srcpad_tasks (GstSctpDec * self);
+static void sctpdec_cleanup (GstSctpDec * self);
+static GstPad *get_pad_for_stream_id (GstSctpDec * self, guint16 stream_id);
+static void remove_pad (GstElement * element, GstPad * pad);
+static void on_reset_stream (GstSctpDec * self, guint stream_id);
+
+static void
+gst_sctp_dec_class_init (GstSctpDecClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *element_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  element_class = GST_ELEMENT_CLASS (klass);
+
+  GST_DEBUG_CATEGORY_INIT (gst_sctp_dec_debug_category,
+      "sctpdec", 0, "debug category for sctpdec element");
+
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&src_template));
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&sink_template));
+
+  gobject_class->set_property = gst_sctp_dec_set_property;
+  gobject_class->get_property = gst_sctp_dec_get_property;
+
+  element_class->change_state = GST_DEBUG_FUNCPTR (gst_sctp_dec_change_state);
+
+  klass->on_reset_stream = on_reset_stream;
+
+  properties[PROP_GST_SCTP_ASSOCIATION_ID] =
+      g_param_spec_uint ("sctp-association-id",
+      "SCTP Association ID",
+      "Every encoder/decoder pair should have the same, unique, sctp-association-id. "
+      "This value must be set before any pads are requested.",
+      0, MAX_GST_SCTP_ASSOCIATION_ID, DEFAULT_GST_SCTP_ASSOCIATION_ID,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+
+  properties[PROP_LOCAL_SCTP_PORT] =
+      g_param_spec_uint ("local-sctp-port",
+      "Local SCTP port",
+      "Local sctp port for the sctp association. The remote port is configured via the "
+      "GstSctpEnc element.",
+      0, MAX_SCTP_PORT, DEFAULT_LOCAL_SCTP_PORT,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+
+  g_object_class_install_properties (gobject_class, NUM_PROPERTIES, properties);
+
+  signals[SIGNAL_RESET_STREAM] = g_signal_new ("reset-stream",
+      G_TYPE_FROM_CLASS (gobject_class), G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_STRUCT_OFFSET (GstSctpDecClass, on_reset_stream), NULL, NULL,
+      g_cclosure_marshal_generic, G_TYPE_NONE, 1, G_TYPE_UINT);
+
+  gst_element_class_set_static_metadata (element_class,
+      "SCTP Decoder",
+      "Decoder/Network/SCTP",
+      "Decodes packets with SCTP",
+      "George Kiagiadakis <george.kiagiadakis@collabora.com>");
+}
+
+static void
+gst_sctp_dec_init (GstSctpDec * self)
+{
+  self->sctp_association_id = DEFAULT_GST_SCTP_ASSOCIATION_ID;
+  self->local_sctp_port = DEFAULT_LOCAL_SCTP_PORT;
+
+  self->sink_pad = gst_pad_new_from_static_template (&sink_template, "sink");
+  gst_pad_set_chain_function (self->sink_pad,
+      GST_DEBUG_FUNCPTR ((GstPadChainFunction) gst_sctp_dec_packet_chain));
+  gst_pad_set_event_function (self->sink_pad,
+      GST_DEBUG_FUNCPTR ((GstPadEventFunction) gst_sctp_dec_packet_event));
+
+  gst_element_add_pad (GST_ELEMENT (self), self->sink_pad);
+}
+
+static void
+gst_sctp_dec_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstSctpDec *self = GST_SCTP_DEC (object);
+
+  switch (prop_id) {
+    case PROP_GST_SCTP_ASSOCIATION_ID:
+      self->sctp_association_id = g_value_get_uint (value);
+      break;
+    case PROP_LOCAL_SCTP_PORT:
+      self->local_sctp_port = g_value_get_uint (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_sctp_dec_get_property (GObject * object, guint prop_id, GValue * value,
+    GParamSpec * pspec)
+{
+  GstSctpDec *self = GST_SCTP_DEC (object);
+
+  switch (prop_id) {
+    case PROP_GST_SCTP_ASSOCIATION_ID:
+      g_value_set_uint (value, self->sctp_association_id);
+      break;
+    case PROP_LOCAL_SCTP_PORT:
+      g_value_set_uint (value, self->local_sctp_port);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
+      break;
+  }
+}
+
+static GstStateChangeReturn
+gst_sctp_dec_change_state (GstElement * element, GstStateChange transition)
+{
+  GstSctpDec *self = GST_SCTP_DEC (element);
+  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      if (!configure_association (self))
+        ret = GST_STATE_CHANGE_FAILURE;
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      sctpdec_cleanup (self);
+      break;
+    default:
+      break;
+  }
+
+  if (ret != GST_STATE_CHANGE_FAILURE)
+    ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  return ret;
+}
+
+static GstFlowReturn
+gst_sctp_dec_packet_chain (GstPad * pad, GstSctpDec * self, GstBuffer * buf)
+{
+  GstMapInfo map;
+
+  if (!gst_buffer_map (buf, &map, GST_MAP_READ)) {
+    GST_WARNING_OBJECT (self, "Could not map GstBuffer");
+    gst_buffer_unref (buf);
+    return GST_FLOW_ERROR;
+  }
+
+  gst_sctp_association_incoming_packet (self->sctp_association,
+      (guint8 *) map.data, (guint32) map.size);
+  gst_buffer_unmap (buf, &map);
+  gst_buffer_unref (buf);
+
+  return GST_FLOW_OK;
+}
+
+static void
+flush_srcpad (const GValue * item, gpointer user_data)
+{
+  GstSctpDecPad *sctpdec_pad = g_value_get_object (item);
+  gboolean flush = GPOINTER_TO_INT (user_data);
+
+  if (flush) {
+    gst_data_queue_set_flushing (sctpdec_pad->packet_queue, TRUE);
+    gst_data_queue_flush (sctpdec_pad->packet_queue);
+  } else {
+    gst_data_queue_set_flushing (sctpdec_pad->packet_queue, FALSE);
+    gst_pad_start_task (GST_PAD (sctpdec_pad),
+        (GstTaskFunction) gst_sctp_data_srcpad_loop, sctpdec_pad, NULL);
+  }
+}
+
+static gboolean
+gst_sctp_dec_packet_event (GstPad * pad, GstSctpDec * self, GstEvent * event)
+{
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_STREAM_START:
+    case GST_EVENT_CAPS:
+      /* We create our own stream-start events and the caps event does not
+       * make sense */
+      gst_event_unref (event);
+      return TRUE;
+    case GST_EVENT_EOS:
+      /* Drop this, we're never EOS until shut down */
+      gst_event_unref (event);
+      return TRUE;
+    case GST_EVENT_FLUSH_START:{
+      GstIterator *it;
+
+      it = gst_element_iterate_src_pads (GST_ELEMENT (self));
+      while (gst_iterator_foreach (it, flush_srcpad,
+              GINT_TO_POINTER (TRUE)) == GST_ITERATOR_RESYNC)
+        gst_iterator_resync (it);
+      gst_iterator_free (it);
+
+      return gst_pad_event_default (pad, GST_OBJECT (self), event);
+    }
+    case GST_EVENT_FLUSH_STOP:{
+      GstIterator *it;
+
+      it = gst_element_iterate_src_pads (GST_ELEMENT (self));
+      while (gst_iterator_foreach (it, flush_srcpad,
+              GINT_TO_POINTER (FALSE)) == GST_ITERATOR_RESYNC)
+        gst_iterator_resync (it);
+      gst_iterator_free (it);
+
+      return gst_pad_event_default (pad, GST_OBJECT (self), event);
+    }
+    default:
+      return gst_pad_event_default (pad, GST_OBJECT (self), event);
+  }
+}
+
+static void
+gst_sctp_data_srcpad_loop (GstPad * pad)
+{
+  GstSctpDecPad *sctpdec_pad = GST_SCTP_DEC_PAD (pad);
+  GstDataQueueItem *item;
+
+  if (gst_data_queue_pop (sctpdec_pad->packet_queue, &item)) {
+    GstFlowReturn flow_ret;
+
+    flow_ret = gst_pad_push (pad, GST_BUFFER (item->object));
+    item->object = NULL;
+    if (G_UNLIKELY (flow_ret == GST_FLOW_FLUSHING
+            || flow_ret == GST_FLOW_NOT_LINKED)) {
+      GST_DEBUG_OBJECT (pad, "Push failed on packet source pad. Error: %s",
+          gst_flow_get_name (flow_ret));
+    } else if (G_UNLIKELY (flow_ret != GST_FLOW_OK)) {
+      GST_ERROR_OBJECT (pad, "Push failed on packet source pad. Error: %s",
+          gst_flow_get_name (flow_ret));
+    }
+
+    if (G_UNLIKELY (flow_ret != GST_FLOW_OK)) {
+      GST_DEBUG_OBJECT (pad, "Pausing task because of an error");
+      gst_data_queue_set_flushing (sctpdec_pad->packet_queue, TRUE);
+      gst_data_queue_flush (sctpdec_pad->packet_queue);
+      gst_pad_pause_task (pad);
+    }
+
+    item->destroy (item);
+  } else {
+    GST_DEBUG_OBJECT (pad, "Pausing task because we're flushing");
+    gst_pad_pause_task (pad);
+  }
+}
+
+static gboolean
+configure_association (GstSctpDec * self)
+{
+  gint state;
+
+  self->sctp_association = gst_sctp_association_get (self->sctp_association_id);
+
+  g_object_get (self->sctp_association, "state", &state, NULL);
+
+  if (state != GST_SCTP_ASSOCIATION_STATE_NEW) {
+    GST_WARNING_OBJECT (self,
+        "Could not configure SCTP association. Association already in use!");
+    g_object_unref (self->sctp_association);
+    self->sctp_association = NULL;
+    goto error;
+  }
+
+  self->signal_handler_stream_reset =
+      g_signal_connect_object (self->sctp_association, "stream-reset",
+      G_CALLBACK (on_gst_sctp_association_stream_reset), self, 0);
+
+  g_object_bind_property (self, "local-sctp-port", self->sctp_association,
+      "local-port", G_BINDING_SYNC_CREATE);
+
+  gst_sctp_association_set_on_packet_received (self->sctp_association,
+      on_receive, self);
+
+  return TRUE;
+error:
+  return FALSE;
+}
+
+static gboolean
+gst_sctp_dec_src_event (GstPad * pad, GstSctpDec * self, GstEvent * event)
+{
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_RECONFIGURE:
+    case GST_EVENT_FLUSH_STOP:{
+      GstSctpDecPad *sctpdec_pad = GST_SCTP_DEC_PAD (pad);
+
+      /* Unflush and start task again */
+      gst_data_queue_set_flushing (sctpdec_pad->packet_queue, FALSE);
+      gst_pad_start_task (pad, (GstTaskFunction) gst_sctp_data_srcpad_loop, pad,
+          NULL);
+
+      return gst_pad_event_default (pad, GST_OBJECT (self), event);
+    }
+    case GST_EVENT_FLUSH_START:{
+      GstSctpDecPad *sctpdec_pad = GST_SCTP_DEC_PAD (pad);
+
+      gst_data_queue_set_flushing (sctpdec_pad->packet_queue, TRUE);
+      gst_data_queue_flush (sctpdec_pad->packet_queue);
+
+      return gst_pad_event_default (pad, GST_OBJECT (self), event);
+    }
+    default:
+      return gst_pad_event_default (pad, GST_OBJECT (self), event);
+  }
+}
+
+static gboolean
+copy_sticky_events (GstPad * pad, GstEvent ** event, gpointer user_data)
+{
+  GstPad *new_pad = user_data;
+
+  if (GST_EVENT_TYPE (*event) != GST_EVENT_CAPS
+      && GST_EVENT_TYPE (*event) != GST_EVENT_STREAM_START)
+    gst_pad_store_sticky_event (new_pad, *event);
+
+  return TRUE;
+}
+
+static GstPad *
+get_pad_for_stream_id (GstSctpDec * self, guint16 stream_id)
+{
+  GstPad *new_pad = NULL;
+  gint state;
+  gchar *pad_name, *pad_stream_id;
+  GstPadTemplate *template;
+
+  pad_name = g_strdup_printf ("src_%hu", stream_id);
+  new_pad = gst_element_get_static_pad (GST_ELEMENT (self), pad_name);
+  if (new_pad) {
+    g_free (pad_name);
+    return new_pad;
+  }
+
+  g_object_get (self->sctp_association, "state", &state, NULL);
+
+  if (state != GST_SCTP_ASSOCIATION_STATE_CONNECTED) {
+    GST_WARNING_OBJECT (self,
+        "The SCTP association must be established before a new stream can be created");
+    return NULL;
+  }
+
+  if (stream_id > MAX_STREAM_ID)
+    return NULL;
+
+  template = gst_static_pad_template_get (&src_template);
+  new_pad = g_object_new (GST_TYPE_SCTP_DEC_PAD, "name", pad_name,
+      "direction", template->direction, "template", template, NULL);
+  g_free (pad_name);
+
+  gst_pad_set_event_function (new_pad,
+      GST_DEBUG_FUNCPTR ((GstPadEventFunction) gst_sctp_dec_src_event));
+
+  if (!gst_pad_set_active (new_pad, TRUE))
+    goto error_cleanup;
+
+  pad_stream_id =
+      gst_pad_create_stream_id_printf (new_pad, GST_ELEMENT (self), "%hu",
+      stream_id);
+  gst_pad_push_event (new_pad, gst_event_new_stream_start (pad_stream_id));
+  g_free (pad_stream_id);
+  gst_pad_sticky_events_foreach (self->sink_pad, copy_sticky_events, new_pad);
+
+  if (!gst_element_add_pad (GST_ELEMENT (self), new_pad))
+    goto error_cleanup;
+
+  gst_pad_start_task (new_pad, (GstTaskFunction) gst_sctp_data_srcpad_loop,
+      new_pad, NULL);
+
+  gst_object_ref (new_pad);
+
+  return new_pad;
+
+error_cleanup:
+  gst_object_unref (new_pad);
+  return NULL;
+}
+
+static void
+remove_pad (GstElement * element, GstPad * pad)
+{
+  stop_srcpad_task (pad);
+  gst_pad_set_active (pad, FALSE);
+  gst_element_remove_pad (element, pad);
+}
+
+static void
+on_gst_sctp_association_stream_reset (GstSctpAssociation * gst_sctp_association,
+    guint16 stream_id, GstSctpDec * self)
+{
+  gchar *pad_name;
+  GstPad *srcpad;
+
+  pad_name = g_strdup_printf ("src_%hu", stream_id);
+  srcpad = gst_element_get_static_pad (GST_ELEMENT (self), pad_name);
+  g_free (pad_name);
+  if (!srcpad) {
+    GST_WARNING_OBJECT (self, "Reset called on stream without a srcpad");
+    return;
+  }
+  remove_pad (GST_ELEMENT (self), srcpad);
+  gst_object_unref (srcpad);
+}
+
+static void
+data_queue_item_free (GstDataQueueItem * item)
+{
+  if (item->object)
+    gst_mini_object_unref (item->object);
+  g_free (item);
+}
+
+static void
+on_receive (GstSctpAssociation * sctp_association, guint8 * buf, gsize length,
+    guint16 stream_id, guint ppid, gpointer user_data)
+{
+  GstSctpDec *self = user_data;
+  GstSctpDecPad *sctpdec_pad;
+  GstPad *src_pad;
+  GstDataQueueItem *item;
+  GstBuffer *gstbuf;
+
+  src_pad = get_pad_for_stream_id (self, stream_id);
+  g_assert (src_pad);
+
+  sctpdec_pad = GST_SCTP_DEC_PAD (src_pad);
+  gstbuf = gst_buffer_new_wrapped (buf, length);
+  gst_sctp_buffer_add_receive_meta (gstbuf, ppid);
+
+  item = g_new0 (GstDataQueueItem, 1);
+  item->object = GST_MINI_OBJECT (gstbuf);
+  item->size = length;
+  item->visible = TRUE;
+  item->destroy = (GDestroyNotify) data_queue_item_free;
+  if (!gst_data_queue_push (sctpdec_pad->packet_queue, item)) {
+    item->destroy (item);
+    GST_DEBUG_OBJECT (src_pad, "Failed to push item because we're flushing");
+  }
+
+  gst_object_unref (src_pad);
+}
+
+static void
+stop_srcpad_task (GstPad * pad)
+{
+  GstSctpDecPad *sctpdec_pad = GST_SCTP_DEC_PAD (pad);
+
+  gst_data_queue_set_flushing (sctpdec_pad->packet_queue, TRUE);
+  gst_data_queue_flush (sctpdec_pad->packet_queue);
+  gst_pad_stop_task (pad);
+}
+
+static void
+remove_pad_it (const GValue * item, gpointer user_data)
+{
+  GstPad *pad = g_value_get_object (item);
+  GstSctpDec *self = user_data;
+
+  remove_pad (GST_ELEMENT (self), pad);
+}
+
+static void
+stop_all_srcpad_tasks (GstSctpDec * self)
+{
+  GstIterator *it;
+
+  it = gst_element_iterate_src_pads (GST_ELEMENT (self));
+  while (gst_iterator_foreach (it, remove_pad_it, self) == GST_ITERATOR_RESYNC)
+    gst_iterator_resync (it);
+  gst_iterator_free (it);
+}
+
+static void
+sctpdec_cleanup (GstSctpDec * self)
+{
+  if (self->sctp_association) {
+    /* FIXME: make this threadsafe */
+    /* gst_sctp_association_set_on_packet_received (self->sctp_association, NULL,
+       NULL); */
+    g_signal_handler_disconnect (self->sctp_association,
+        self->signal_handler_stream_reset);
+    stop_all_srcpad_tasks (self);
+    gst_sctp_association_force_close (self->sctp_association);
+    g_object_unref (self->sctp_association);
+    self->sctp_association = NULL;
+  }
+}
+
+static void
+on_reset_stream (GstSctpDec * self, guint stream_id)
+{
+  if (self->sctp_association) {
+    gst_sctp_association_reset_stream (self->sctp_association, stream_id);
+    on_gst_sctp_association_stream_reset (self->sctp_association, stream_id,
+        self);
+  }
+}
diff --git a/ext/sctp/gstsctpdec.h b/ext/sctp/gstsctpdec.h
new file mode 100644
index 000000000..845fac4d4
--- /dev/null
+++ b/ext/sctp/gstsctpdec.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2015, Collabora Ltd.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this
+ * list of conditions and the following disclaimer in the documentation and/or other
+ * materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ */
+
+#ifndef __GST_SCTP_DEC_H__
+#define __GST_SCTP_DEC_H__
+
+#include <gst/gst.h>
+
+#include "sctpassociation.h"
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_SCTP_DEC (gst_sctp_dec_get_type())
+#define GST_SCTP_DEC(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_SCTP_DEC, GstSctpDec))
+#define GST_SCTP_DEC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_SCTP_DEC, GstSctpDecClass))
+#define GST_IS_SCTP_DEC(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_SCTP_DEC))
+#define GST_IS_SCTP_DEC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_SCTP_DEC))
+typedef struct _GstSctpDec GstSctpDec;
+typedef struct _GstSctpDecClass GstSctpDecClass;
+
+struct _GstSctpDec
+{
+  GstElement element;
+
+  GstPad *sink_pad;
+  guint sctp_association_id;
+  guint local_sctp_port;
+
+  GstSctpAssociation *sctp_association;
+  gulong signal_handler_stream_reset;
+};
+
+struct _GstSctpDecClass
+{
+  GstElementClass parent_class;
+
+  void (*on_reset_stream) (GstSctpDec * sctp_dec, guint stream_id);
+};
+
+GType gst_sctp_dec_get_type (void);
+
+G_END_DECLS
+
+#endif /* __GST_SCTP_DEC_H__ */
diff --git a/ext/sctp/gstsctpenc.c b/ext/sctp/gstsctpenc.c
new file mode 100644
index 000000000..ec33ca9ae
--- /dev/null
+++ b/ext/sctp/gstsctpenc.c
@@ -0,0 +1,954 @@
+/*
+ * Copyright (c) 2015, Collabora Ltd.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this
+ * list of conditions and the following disclaimer in the documentation and/or other
+ * materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include "gstsctpenc.h"
+
+#include <gst/sctp/sctpsendmeta.h>
+#include <stdio.h>
+
+GST_DEBUG_CATEGORY_STATIC (gst_sctp_enc_debug_category);
+#define GST_CAT_DEFAULT gst_sctp_enc_debug_category
+
+#define gst_sctp_enc_parent_class parent_class
+G_DEFINE_TYPE (GstSctpEnc, gst_sctp_enc, GST_TYPE_ELEMENT);
+
+static GstStaticPadTemplate sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink_%u", GST_PAD_SINK,
+    GST_PAD_REQUEST, GST_STATIC_CAPS_ANY);
+
+static GstStaticPadTemplate src_template =
+GST_STATIC_PAD_TEMPLATE ("src", GST_PAD_SRC,
+    GST_PAD_ALWAYS, GST_STATIC_CAPS ("application/x-sctp"));
+
+enum
+{
+  SIGNAL_SCTP_ASSOCIATION_ESTABLISHED,
+  SIGNAL_GET_STREAM_BYTES_SENT,
+  NUM_SIGNALS
+};
+
+static guint signals[NUM_SIGNALS];
+
+enum
+{
+  PROP_0,
+
+  PROP_GST_SCTP_ASSOCIATION_ID,
+  PROP_REMOTE_SCTP_PORT,
+  PROP_USE_SOCK_STREAM,
+
+  NUM_PROPERTIES
+};
+
+static GParamSpec *properties[NUM_PROPERTIES];
+
+#define DEFAULT_GST_SCTP_ASSOCIATION_ID 1
+#define DEFAULT_REMOTE_SCTP_PORT 0
+#define DEFAULT_GST_SCTP_ORDERED TRUE
+#define DEFAULT_SCTP_PPID 1
+#define DEFAULT_USE_SOCK_STREAM FALSE
+
+#define BUFFER_FULL_SLEEP_TIME 100000
+
+GType gst_sctp_enc_pad_get_type (void);
+
+#define GST_TYPE_SCTP_ENC_PAD (gst_sctp_enc_pad_get_type())
+#define GST_SCTP_ENC_PAD(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_SCTP_ENC_PAD, GstSctpEncPad))
+#define GST_SCTP_ENC_PAD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_SCTP_ENC_PAD, GstSctpEncPadClass))
+#define GST_IS_SCTP_ENC_PAD(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_SCTP_ENC_PAD))
+#define GST_IS_SCTP_ENC_PAD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_SCTP_ENC_PAD))
+
+typedef struct _GstSctpEncPad GstSctpEncPad;
+typedef GstPadClass GstSctpEncPadClass;
+
+struct _GstSctpEncPad
+{
+  GstPad parent;
+
+  guint16 stream_id;
+  gboolean ordered;
+  guint32 ppid;
+  GstSctpAssociationPartialReliability reliability;
+  guint32 reliability_param;
+
+  guint64 bytes_sent;
+
+  GMutex lock;
+  GCond cond;
+  gboolean flushing;
+};
+
+G_DEFINE_TYPE (GstSctpEncPad, gst_sctp_enc_pad, GST_TYPE_PAD);
+
+static void
+gst_sctp_enc_pad_finalize (GObject * object)
+{
+  GstSctpEncPad *self = GST_SCTP_ENC_PAD (object);
+
+  g_cond_clear (&self->cond);
+  g_mutex_clear (&self->lock);
+
+  G_OBJECT_CLASS (gst_sctp_enc_pad_parent_class)->finalize (object);
+}
+
+static void
+gst_sctp_enc_pad_class_init (GstSctpEncPadClass * klass)
+{
+  GObjectClass *gobject_class = (GObjectClass *) klass;
+
+  gobject_class->finalize = gst_sctp_enc_pad_finalize;
+}
+
+static void
+gst_sctp_enc_pad_init (GstSctpEncPad * self)
+{
+  g_mutex_init (&self->lock);
+  g_cond_init (&self->cond);
+  self->flushing = FALSE;
+}
+
+static void gst_sctp_enc_finalize (GObject * object);
+static void gst_sctp_enc_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+static void gst_sctp_enc_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+static GstStateChangeReturn gst_sctp_enc_change_state (GstElement * element,
+    GstStateChange transition);
+static GstPad *gst_sctp_enc_request_new_pad (GstElement * element,
+    GstPadTemplate * template, const gchar * name, const GstCaps * caps);
+static void gst_sctp_enc_release_pad (GstElement * element, GstPad * pad);
+static void gst_sctp_enc_srcpad_loop (GstPad * pad);
+static GstFlowReturn gst_sctp_enc_sink_chain (GstPad * pad, GstObject * parent,
+    GstBuffer * buffer);
+static gboolean gst_sctp_enc_sink_event (GstPad * pad, GstObject * parent,
+    GstEvent * event);
+static gboolean gst_sctp_enc_src_event (GstPad * pad, GstObject * parent,
+    GstEvent * event);
+static void on_sctp_association_state_changed (GstSctpAssociation *
+    sctp_association, GParamSpec * pspec, GstSctpEnc * self);
+
+static gboolean configure_association (GstSctpEnc * self);
+static void on_sctp_packet_out (GstSctpAssociation * sctp_association,
+    const guint8 * buf, gsize length, gpointer user_data);
+static void stop_srcpad_task (GstPad * pad, GstSctpEnc * self);
+static void sctpenc_cleanup (GstSctpEnc * self);
+static void get_config_from_caps (const GstCaps * caps, gboolean * ordered,
+    GstSctpAssociationPartialReliability * reliability,
+    guint32 * reliability_param, guint32 * ppid, gboolean * ppid_available);
+static guint64 on_get_stream_bytes_sent (GstSctpEnc * self, guint stream_id);
+
+static void
+gst_sctp_enc_class_init (GstSctpEncClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *element_class;
+
+  gobject_class = (GObjectClass *) klass;
+  element_class = (GstElementClass *) klass;
+
+  GST_DEBUG_CATEGORY_INIT (gst_sctp_enc_debug_category,
+      "sctpenc", 0, "debug category for sctpenc element");
+
+  gst_element_class_add_pad_template (GST_ELEMENT_CLASS (klass),
+      gst_static_pad_template_get (&src_template));
+  gst_element_class_add_pad_template (GST_ELEMENT_CLASS (klass),
+      gst_static_pad_template_get (&sink_template));
+
+  gobject_class->finalize = GST_DEBUG_FUNCPTR (gst_sctp_enc_finalize);
+  gobject_class->set_property = GST_DEBUG_FUNCPTR (gst_sctp_enc_set_property);
+  gobject_class->get_property = GST_DEBUG_FUNCPTR (gst_sctp_enc_get_property);
+
+  element_class->change_state = GST_DEBUG_FUNCPTR (gst_sctp_enc_change_state);
+  element_class->request_new_pad =
+      GST_DEBUG_FUNCPTR (gst_sctp_enc_request_new_pad);
+  element_class->release_pad = GST_DEBUG_FUNCPTR (gst_sctp_enc_release_pad);
+
+  properties[PROP_GST_SCTP_ASSOCIATION_ID] =
+      g_param_spec_uint ("sctp-association-id",
+      "SCTP Association ID",
+      "Every encoder/decoder pair should have the same, unique, sctp-association-id. "
+      "This value must be set before any pads are requested.",
+      0, G_MAXUINT, DEFAULT_GST_SCTP_ASSOCIATION_ID,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+
+  properties[PROP_REMOTE_SCTP_PORT] =
+      g_param_spec_uint ("remote-sctp-port",
+      "Remote SCTP port",
+      "Sctp remote sctp port for the sctp association. The local port is configured via the "
+      "GstSctpDec element.",
+      0, G_MAXUSHORT, DEFAULT_REMOTE_SCTP_PORT,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+
+  properties[PROP_USE_SOCK_STREAM] =
+      g_param_spec_boolean ("use-sock-stream",
+      "Use sock-stream",
+      "When set to TRUE, a sequenced, reliable, connection-based connection is used."
+      "When TRUE the partial reliability parameters of the channel are ignored.",
+      DEFAULT_USE_SOCK_STREAM, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+
+  g_object_class_install_properties (gobject_class, NUM_PROPERTIES, properties);
+
+  signals[SIGNAL_SCTP_ASSOCIATION_ESTABLISHED] =
+      g_signal_new ("sctp-association-established",
+      G_TYPE_FROM_CLASS (gobject_class), G_SIGNAL_RUN_LAST,
+      G_STRUCT_OFFSET (GstSctpEncClass, on_sctp_association_is_established),
+      NULL, NULL, g_cclosure_marshal_generic, G_TYPE_NONE, 1, G_TYPE_BOOLEAN);
+
+  signals[SIGNAL_GET_STREAM_BYTES_SENT] = g_signal_new ("bytes-sent",
+      G_TYPE_FROM_CLASS (gobject_class), G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_STRUCT_OFFSET (GstSctpEncClass, on_get_stream_bytes_sent), NULL, NULL,
+      g_cclosure_marshal_generic, G_TYPE_UINT64, 1, G_TYPE_UINT);
+
+  klass->on_get_stream_bytes_sent =
+      GST_DEBUG_FUNCPTR (on_get_stream_bytes_sent);
+
+  gst_element_class_set_static_metadata (element_class,
+      "SCTP Encoder",
+      "Encoder/Network/SCTP",
+      "Encodes packets with SCTP",
+      "George Kiagiadakis <george.kiagiadakis@collabora.com>");
+}
+
+static gboolean
+data_queue_check_full_cb (GstDataQueue * queue, guint visible, guint bytes,
+    guint64 time, gpointer user_data)
+{
+  /* TODO: When are we considered full? */
+  return FALSE;
+}
+
+static void
+data_queue_empty_cb (GstDataQueue * queue, gpointer user_data)
+{
+}
+
+static void
+data_queue_full_cb (GstDataQueue * queue, gpointer user_data)
+{
+}
+
+static void
+gst_sctp_enc_init (GstSctpEnc * self)
+{
+  self->sctp_association_id = DEFAULT_GST_SCTP_ASSOCIATION_ID;
+  self->remote_sctp_port = DEFAULT_REMOTE_SCTP_PORT;
+
+  self->sctp_association = NULL;
+  self->outbound_sctp_packet_queue =
+      gst_data_queue_new (data_queue_check_full_cb, data_queue_full_cb,
+      data_queue_empty_cb, NULL);
+
+  self->src_pad = gst_pad_new_from_static_template (&src_template, "src");
+  gst_pad_set_event_function (self->src_pad,
+      GST_DEBUG_FUNCPTR ((GstPadEventFunction) gst_sctp_enc_src_event));
+  gst_element_add_pad (GST_ELEMENT (self), self->src_pad);
+
+  g_queue_init (&self->pending_pads);
+}
+
+static void
+gst_sctp_enc_finalize (GObject * object)
+{
+  GstSctpEnc *self = GST_SCTP_ENC (object);
+
+  g_queue_clear (&self->pending_pads);
+  gst_object_unref (self->outbound_sctp_packet_queue);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gst_sctp_enc_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstSctpEnc *self = GST_SCTP_ENC (object);
+
+  switch (prop_id) {
+    case PROP_GST_SCTP_ASSOCIATION_ID:
+      self->sctp_association_id = g_value_get_uint (value);
+      break;
+    case PROP_REMOTE_SCTP_PORT:
+      self->remote_sctp_port = g_value_get_uint (value);
+      break;
+    case PROP_USE_SOCK_STREAM:
+      self->use_sock_stream = g_value_get_boolean (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_sctp_enc_get_property (GObject * object, guint prop_id, GValue * value,
+    GParamSpec * pspec)
+{
+  GstSctpEnc *self = GST_SCTP_ENC (object);
+
+  switch (prop_id) {
+    case PROP_GST_SCTP_ASSOCIATION_ID:
+      g_value_set_uint (value, self->sctp_association_id);
+      break;
+    case PROP_REMOTE_SCTP_PORT:
+      g_value_set_uint (value, self->remote_sctp_port);
+      break;
+    case PROP_USE_SOCK_STREAM:
+      g_value_set_boolean (value, self->use_sock_stream);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
+      break;
+  }
+}
+
+static GstStateChangeReturn
+gst_sctp_enc_change_state (GstElement * element, GstStateChange transition)
+{
+  GstSctpEnc *self = GST_SCTP_ENC (element);
+  GstStateChangeReturn ret = GST_STATE_CHANGE_FAILURE;
+  gboolean res = TRUE;
+
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      break;
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      self->need_segment = self->need_stream_start_caps = TRUE;
+      gst_data_queue_set_flushing (self->outbound_sctp_packet_queue, FALSE);
+      res = configure_association (self);
+      break;
+    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      sctpenc_cleanup (self);
+      break;
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      break;
+    default:
+      break;
+  }
+
+  if (res)
+    ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      break;
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      gst_pad_start_task (self->src_pad,
+          (GstTaskFunction) gst_sctp_enc_srcpad_loop, self->src_pad, NULL);
+      break;
+    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      break;
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
+
+static GstPad *
+gst_sctp_enc_request_new_pad (GstElement * element, GstPadTemplate * template,
+    const gchar * new_pad_name, const GstCaps * caps)
+{
+  GstSctpEnc *self = GST_SCTP_ENC (element);
+  GstPad *new_pad = NULL;
+  GstSctpEncPad *sctpenc_pad;
+  guint32 stream_id;
+  gint state;
+  guint32 new_ppid;
+  gboolean is_new_ppid;
+
+  g_object_get (self->sctp_association, "state", &state, NULL);
+
+  if (state != GST_SCTP_ASSOCIATION_STATE_CONNECTED) {
+    g_warning
+        ("The SCTP association must be established before a new stream can be created");
+    goto invalid_state;
+  }
+
+  if (!template)
+    goto invalid_parameter;
+
+  if (!new_pad_name || (sscanf (new_pad_name, "sink_%u", &stream_id) != 1)
+      || stream_id > 65534)     /* 65535 is not a valid stream id */
+    goto invalid_parameter;
+
+  new_pad = gst_element_get_static_pad (element, new_pad_name);
+  if (new_pad) {
+    gst_object_unref (new_pad);
+    new_pad = NULL;
+    goto invalid_parameter;
+  }
+
+  new_pad =
+      g_object_new (GST_TYPE_SCTP_ENC_PAD, "name", new_pad_name, "direction",
+      template->direction, "template", template, NULL);
+  gst_pad_set_chain_function (new_pad,
+      GST_DEBUG_FUNCPTR (gst_sctp_enc_sink_chain));
+  gst_pad_set_event_function (new_pad,
+      GST_DEBUG_FUNCPTR (gst_sctp_enc_sink_event));
+
+  sctpenc_pad = GST_SCTP_ENC_PAD (new_pad);
+  sctpenc_pad->stream_id = stream_id;
+  sctpenc_pad->ppid = DEFAULT_SCTP_PPID;
+
+  if (caps) {
+    get_config_from_caps (caps, &sctpenc_pad->ordered,
+        &sctpenc_pad->reliability, &sctpenc_pad->reliability_param, &new_ppid,
+        &is_new_ppid);
+
+    if (is_new_ppid)
+      sctpenc_pad->ppid = new_ppid;
+  }
+
+  sctpenc_pad->flushing = FALSE;
+
+  if (!gst_pad_set_active (new_pad, TRUE))
+    goto error_cleanup;
+
+  if (!gst_element_add_pad (element, new_pad))
+    goto error_cleanup;
+
+invalid_state:
+invalid_parameter:
+  return new_pad;
+error_cleanup:
+  gst_object_unref (new_pad);
+  return NULL;
+}
+
+static void
+gst_sctp_enc_release_pad (GstElement * element, GstPad * pad)
+{
+  GstSctpEncPad *sctpenc_pad = GST_SCTP_ENC_PAD (pad);
+  GstSctpEnc *self;
+  guint stream_id = 0;
+
+  self = GST_SCTP_ENC (element);
+
+  g_mutex_lock (&sctpenc_pad->lock);
+  sctpenc_pad->flushing = TRUE;
+  g_cond_signal (&sctpenc_pad->cond);
+  g_mutex_unlock (&sctpenc_pad->lock);
+
+  stream_id = sctpenc_pad->stream_id;
+  gst_pad_set_active (pad, FALSE);
+
+  if (self->sctp_association)
+    gst_sctp_association_reset_stream (self->sctp_association, stream_id);
+
+  gst_element_remove_pad (element, pad);
+}
+
+static void
+gst_sctp_enc_srcpad_loop (GstPad * pad)
+{
+  GstSctpEnc *self = GST_SCTP_ENC (GST_PAD_PARENT (pad));
+  GstFlowReturn flow_ret;
+  GstDataQueueItem *item;
+
+  if (self->need_stream_start_caps) {
+    gchar s_id[32];
+    GstCaps *caps;
+
+    g_snprintf (s_id, sizeof (s_id), "sctpenc-%08x", g_random_int ());
+    gst_pad_push_event (self->src_pad, gst_event_new_stream_start (s_id));
+
+    caps = gst_caps_new_empty_simple ("application/x-sctp");
+    gst_pad_set_caps (self->src_pad, caps);
+    gst_caps_unref (caps);
+
+    self->need_stream_start_caps = FALSE;
+  }
+
+  if (self->need_segment) {
+    GstSegment segment;
+
+    gst_segment_init (&segment, GST_FORMAT_BYTES);
+    gst_pad_push_event (self->src_pad, gst_event_new_segment (&segment));
+
+    self->need_segment = FALSE;
+  }
+
+  if (gst_data_queue_pop (self->outbound_sctp_packet_queue, &item)) {
+    flow_ret = gst_pad_push (self->src_pad, GST_BUFFER (item->object));
+    item->object = NULL;
+
+    if (G_UNLIKELY (flow_ret == GST_FLOW_FLUSHING
+            || flow_ret == GST_FLOW_NOT_LINKED)) {
+      GST_DEBUG_OBJECT (pad, "Push failed on packet source pad. Error: %s",
+          gst_flow_get_name (flow_ret));
+    } else if (G_UNLIKELY (flow_ret != GST_FLOW_OK)) {
+      GST_ERROR_OBJECT (pad, "Push failed on packet source pad. Error: %s",
+          gst_flow_get_name (flow_ret));
+    }
+
+    if (G_UNLIKELY (flow_ret != GST_FLOW_OK)) {
+      GST_DEBUG_OBJECT (pad, "Pausing task because of an error");
+      gst_data_queue_set_flushing (self->outbound_sctp_packet_queue, TRUE);
+      gst_data_queue_flush (self->outbound_sctp_packet_queue);
+      gst_pad_pause_task (pad);
+    }
+
+    item->destroy (item);
+  } else {
+    GST_DEBUG_OBJECT (pad, "Pausing task because we're flushing");
+    gst_pad_pause_task (pad);
+  }
+}
+
+static GstFlowReturn
+gst_sctp_enc_sink_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
+{
+  GstSctpEnc *self = GST_SCTP_ENC (parent);
+  GstSctpEncPad *sctpenc_pad = GST_SCTP_ENC_PAD (pad);
+  GstMapInfo map;
+  guint32 ppid;
+  gboolean ordered;
+  GstSctpAssociationPartialReliability pr;
+  guint32 pr_param;
+  gpointer state = NULL;
+  GstMeta *meta;
+  const GstMetaInfo *meta_info = GST_SCTP_SEND_META_INFO;
+  GstFlowReturn flow_ret = GST_FLOW_ERROR;
+
+  ppid = sctpenc_pad->ppid;
+  ordered = sctpenc_pad->ordered;
+  pr = sctpenc_pad->reliability;
+  pr_param = sctpenc_pad->reliability_param;
+
+  while ((meta = gst_buffer_iterate_meta (buffer, &state))) {
+    if (meta->info->api == meta_info->api) {
+      GstSctpSendMeta *sctp_send_meta = (GstSctpSendMeta *) meta;
+
+      ppid = sctp_send_meta->ppid;
+      ordered = sctp_send_meta->ordered;
+      pr_param = sctp_send_meta->pr_param;
+      switch (sctp_send_meta->pr) {
+        case GST_SCTP_SEND_META_PARTIAL_RELIABILITY_NONE:
+          pr = GST_SCTP_ASSOCIATION_PARTIAL_RELIABILITY_NONE;
+          break;
+        case GST_SCTP_SEND_META_PARTIAL_RELIABILITY_RTX:
+          pr = GST_SCTP_ASSOCIATION_PARTIAL_RELIABILITY_RTX;
+          break;
+        case GST_SCTP_SEND_META_PARTIAL_RELIABILITY_BUF:
+          pr = GST_SCTP_ASSOCIATION_PARTIAL_RELIABILITY_BUF;
+          break;
+        case GST_SCTP_SEND_META_PARTIAL_RELIABILITY_TTL:
+          pr = GST_SCTP_ASSOCIATION_PARTIAL_RELIABILITY_TTL;
+          break;
+      }
+      break;
+    }
+  }
+
+  if (!gst_buffer_map (buffer, &map, GST_MAP_READ)) {
+    g_warning ("Could not map GstBuffer");
+    goto error;
+  }
+
+  g_mutex_lock (&sctpenc_pad->lock);
+  while (!sctpenc_pad->flushing) {
+    gboolean data_sent = FALSE;
+
+    g_mutex_unlock (&sctpenc_pad->lock);
+
+    data_sent =
+        gst_sctp_association_send_data (self->sctp_association, map.data,
+        map.size, sctpenc_pad->stream_id, ppid, ordered, pr, pr_param);
+
+    g_mutex_lock (&sctpenc_pad->lock);
+    if (data_sent) {
+      sctpenc_pad->bytes_sent += map.size;
+      break;
+    } else if (!sctpenc_pad->flushing) {
+      gint64 end_time = g_get_monotonic_time () + BUFFER_FULL_SLEEP_TIME;
+
+      /* The buffer was probably full. Retry in a while */
+      GST_OBJECT_LOCK (self);
+      g_queue_push_tail (&self->pending_pads, sctpenc_pad);
+      GST_OBJECT_UNLOCK (self);
+
+      g_cond_wait_until (&sctpenc_pad->cond, &sctpenc_pad->lock, end_time);
+
+      GST_OBJECT_LOCK (self);
+      g_queue_remove (&self->pending_pads, sctpenc_pad);
+      GST_OBJECT_UNLOCK (self);
+    }
+  }
+  flow_ret = sctpenc_pad->flushing ? GST_FLOW_FLUSHING : GST_FLOW_OK;
+  g_mutex_unlock (&sctpenc_pad->lock);
+
+  gst_buffer_unmap (buffer, &map);
+error:
+  gst_buffer_unref (buffer);
+  return flow_ret;
+}
+
+static gboolean
+gst_sctp_enc_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
+{
+  GstSctpEncPad *sctpenc_pad = GST_SCTP_ENC_PAD (pad);
+  gboolean ret, is_new_ppid;
+  guint32 new_ppid;
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_CAPS:{
+      GstCaps *caps;
+
+      gst_event_parse_caps (event, &caps);
+      get_config_from_caps (caps, &sctpenc_pad->ordered,
+          &sctpenc_pad->reliability, &sctpenc_pad->reliability_param, &new_ppid,
+          &is_new_ppid);
+      if (is_new_ppid)
+        sctpenc_pad->ppid = new_ppid;
+      gst_event_unref (event);
+      ret = TRUE;
+      break;
+    }
+    case GST_EVENT_STREAM_START:
+    case GST_EVENT_SEGMENT:
+      /* Drop these, we create our own */
+      ret = TRUE;
+      gst_event_unref (event);
+      break;
+    case GST_EVENT_EOS:
+      /* Drop this, we're never EOS until shut down */
+      ret = TRUE;
+      gst_event_unref (event);
+      break;
+    case GST_EVENT_FLUSH_START:
+      g_mutex_lock (&sctpenc_pad->lock);
+      sctpenc_pad->flushing = TRUE;
+      g_cond_signal (&sctpenc_pad->cond);
+      g_mutex_unlock (&sctpenc_pad->lock);
+
+      ret = gst_pad_event_default (pad, parent, event);
+      break;
+    case GST_EVENT_FLUSH_STOP:
+      sctpenc_pad->flushing = FALSE;
+      ret = gst_pad_event_default (pad, parent, event);
+      break;
+    default:
+      ret = gst_pad_event_default (pad, parent, event);
+      break;
+  }
+  return ret;
+}
+
+static void
+flush_sinkpad (const GValue * item, gpointer user_data)
+{
+  GstSctpEncPad *sctpenc_pad = g_value_get_object (item);
+  gboolean flush = GPOINTER_TO_INT (user_data);
+
+  if (flush) {
+    g_mutex_lock (&sctpenc_pad->lock);
+    sctpenc_pad->flushing = TRUE;
+    g_cond_signal (&sctpenc_pad->cond);
+    g_mutex_unlock (&sctpenc_pad->lock);
+  } else {
+    sctpenc_pad->flushing = FALSE;
+  }
+}
+
+static gboolean
+gst_sctp_enc_src_event (GstPad * pad, GstObject * parent, GstEvent * event)
+{
+  GstSctpEnc *self = GST_SCTP_ENC (parent);
+  gboolean ret;
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_FLUSH_START:{
+      GstIterator *it;
+
+      gst_data_queue_set_flushing (self->outbound_sctp_packet_queue, TRUE);
+      gst_data_queue_flush (self->outbound_sctp_packet_queue);
+
+      it = gst_element_iterate_sink_pads (GST_ELEMENT (self));
+      while (gst_iterator_foreach (it, flush_sinkpad,
+              GINT_TO_POINTER (TRUE)) == GST_ITERATOR_RESYNC)
+        gst_iterator_resync (it);
+      gst_iterator_free (it);
+
+      ret = gst_pad_event_default (pad, parent, event);
+      break;
+    }
+    case GST_EVENT_RECONFIGURE:
+    case GST_EVENT_FLUSH_STOP:{
+      GstIterator *it;
+
+      it = gst_element_iterate_sink_pads (GST_ELEMENT (self));
+      while (gst_iterator_foreach (it, flush_sinkpad,
+              GINT_TO_POINTER (FALSE)) == GST_ITERATOR_RESYNC)
+        gst_iterator_resync (it);
+      gst_iterator_free (it);
+
+      gst_data_queue_set_flushing (self->outbound_sctp_packet_queue, FALSE);
+      self->need_segment = TRUE;
+      gst_pad_start_task (self->src_pad,
+          (GstTaskFunction) gst_sctp_enc_srcpad_loop, self->src_pad, NULL);
+
+      ret = gst_pad_event_default (pad, parent, event);
+      break;
+    }
+    default:
+      ret = gst_pad_event_default (pad, parent, event);
+      break;
+  }
+  return ret;
+}
+
+static gboolean
+configure_association (GstSctpEnc * self)
+{
+  gint state;
+
+  self->sctp_association = gst_sctp_association_get (self->sctp_association_id);
+
+  g_object_get (self->sctp_association, "state", &state, NULL);
+
+  if (state != GST_SCTP_ASSOCIATION_STATE_NEW) {
+    GST_WARNING_OBJECT (self,
+        "Could not configure SCTP association. Association already in use!");
+    g_object_unref (self->sctp_association);
+    self->sctp_association = NULL;
+    goto error;
+  }
+
+  self->signal_handler_state_changed =
+      g_signal_connect_object (self->sctp_association, "notify::state",
+      G_CALLBACK (on_sctp_association_state_changed), self, 0);
+
+  g_object_bind_property (self, "remote-sctp-port", self->sctp_association,
+      "remote-port", G_BINDING_SYNC_CREATE);
+
+  g_object_bind_property (self, "use-sock-stream", self->sctp_association,
+      "use-sock-stream", G_BINDING_SYNC_CREATE);
+
+  gst_sctp_association_set_on_packet_out (self->sctp_association,
+      on_sctp_packet_out, self);
+
+  return TRUE;
+error:
+  return FALSE;
+}
+
+static void
+on_sctp_association_state_changed (GstSctpAssociation * sctp_association,
+    GParamSpec * pspec, GstSctpEnc * self)
+{
+  gint state;
+
+  g_object_get (sctp_association, "state", &state, NULL);
+  switch (state) {
+    case GST_SCTP_ASSOCIATION_STATE_NEW:
+      break;
+    case GST_SCTP_ASSOCIATION_STATE_READY:
+      gst_sctp_association_start (sctp_association);
+      break;
+    case GST_SCTP_ASSOCIATION_STATE_CONNECTING:
+      break;
+    case GST_SCTP_ASSOCIATION_STATE_CONNECTED:
+      g_signal_emit_by_name (self, "sctp-association-established", TRUE);
+      break;
+    case GST_SCTP_ASSOCIATION_STATE_DISCONNECTING:
+      g_signal_emit (self, signals[SIGNAL_SCTP_ASSOCIATION_ESTABLISHED], 0,
+          FALSE);
+      break;
+    case GST_SCTP_ASSOCIATION_STATE_DISCONNECTED:
+      break;
+    case GST_SCTP_ASSOCIATION_STATE_ERROR:
+      break;
+  }
+}
+
+static void
+data_queue_item_free (GstDataQueueItem * item)
+{
+  if (item->object)
+    gst_mini_object_unref (item->object);
+  g_free (item);
+}
+
+static void
+on_sctp_packet_out (GstSctpAssociation * _association, const guint8 * buf,
+    gsize length, gpointer user_data)
+{
+  GstSctpEnc *self = user_data;
+  GstBuffer *gstbuf;
+  GstDataQueueItem *item;
+  GList *pending_pads, *l;
+  GstSctpEncPad *sctpenc_pad;
+
+  gstbuf = gst_buffer_new_wrapped (g_memdup (buf, length), length);
+
+  item = g_new0 (GstDataQueueItem, 1);
+  item->object = GST_MINI_OBJECT (gstbuf);
+  item->size = length;
+  item->visible = TRUE;
+  item->destroy = (GDestroyNotify) data_queue_item_free;
+
+  if (!gst_data_queue_push (self->outbound_sctp_packet_queue, item)) {
+    item->destroy (item);
+    GST_DEBUG_OBJECT (self, "Failed to push item because we're flushing");
+  }
+
+  /* Wake up pads in the order they waited, oldest pad first */
+  GST_OBJECT_LOCK (self);
+  pending_pads = NULL;
+  while ((sctpenc_pad = g_queue_pop_tail (&self->pending_pads))) {
+    pending_pads = g_list_prepend (pending_pads, sctpenc_pad);
+  }
+  GST_OBJECT_UNLOCK (self);
+
+  for (l = pending_pads; l; l = l->next) {
+    sctpenc_pad = l->data;
+    g_mutex_lock (&sctpenc_pad->lock);
+    g_cond_signal (&sctpenc_pad->cond);
+    g_mutex_unlock (&sctpenc_pad->lock);
+  }
+  g_list_free (pending_pads);
+}
+
+static void
+stop_srcpad_task (GstPad * pad, GstSctpEnc * self)
+{
+  gst_data_queue_set_flushing (self->outbound_sctp_packet_queue, TRUE);
+  gst_data_queue_flush (self->outbound_sctp_packet_queue);
+  gst_pad_stop_task (pad);
+}
+
+static void
+remove_sinkpad (const GValue * item, gpointer user_data)
+{
+  GstSctpEncPad *sctpenc_pad = g_value_get_object (item);
+  GstSctpEnc *self = user_data;
+
+  gst_sctp_enc_release_pad (GST_ELEMENT (self), GST_PAD (sctpenc_pad));
+}
+
+static void
+sctpenc_cleanup (GstSctpEnc * self)
+{
+  GstIterator *it;
+
+  /* FIXME: make this threadsafe */
+  /* gst_sctp_association_set_on_packet_out (self->sctp_association, NULL, NULL); */
+
+  g_signal_handler_disconnect (self->sctp_association,
+      self->signal_handler_state_changed);
+  stop_srcpad_task (self->src_pad, self);
+  gst_sctp_association_force_close (self->sctp_association);
+  g_object_unref (self->sctp_association);
+  self->sctp_association = NULL;
+
+  it = gst_element_iterate_sink_pads (GST_ELEMENT (self));
+  while (gst_iterator_foreach (it, remove_sinkpad, self) == GST_ITERATOR_RESYNC)
+    gst_iterator_resync (it);
+  gst_iterator_free (it);
+  g_queue_clear (&self->pending_pads);
+}
+
+static void
+get_config_from_caps (const GstCaps * caps, gboolean * ordered,
+    GstSctpAssociationPartialReliability * reliability,
+    guint32 * reliability_param, guint32 * ppid, gboolean * ppid_available)
+{
+  GstStructure *s;
+  guint i, n;
+
+  *ordered = TRUE;
+  *reliability = GST_SCTP_ASSOCIATION_PARTIAL_RELIABILITY_NONE;
+  *reliability_param = 0;
+  *ppid_available = FALSE;
+
+  n = gst_caps_get_size (caps);
+  for (i = 0; i < n; i++) {
+    s = gst_caps_get_structure (caps, i);
+    if (gst_structure_has_field (s, "ordered")) {
+      const GValue *v = gst_structure_get_value (s, "ordered");
+      *ordered = g_value_get_boolean (v);
+    }
+    if (gst_structure_has_field (s, "partially-reliability")) {
+      const GValue *v = gst_structure_get_value (s, "partially-reliability");
+      const gchar *reliability_string = g_value_get_string (v);
+
+      if (!g_strcmp0 (reliability_string, "none"))
+        *reliability = GST_SCTP_ASSOCIATION_PARTIAL_RELIABILITY_NONE;
+      else if (!g_strcmp0 (reliability_string, "ttl"))
+        *reliability = GST_SCTP_ASSOCIATION_PARTIAL_RELIABILITY_TTL;
+      else if (!g_strcmp0 (reliability_string, "buf"))
+        *reliability = GST_SCTP_ASSOCIATION_PARTIAL_RELIABILITY_BUF;
+      else if (!g_strcmp0 (reliability_string, "rtx"))
+        *reliability = GST_SCTP_ASSOCIATION_PARTIAL_RELIABILITY_RTX;
+    }
+    if (gst_structure_has_field (s, "reliability-parameter")) {
+      const GValue *v = gst_structure_get_value (s, "reliability-parameter");
+      *reliability_param = g_value_get_uint (v);
+    }
+    if (gst_structure_has_field (s, "ppid")) {
+      const GValue *v = gst_structure_get_value (s, "ppid");
+      *ppid = g_value_get_uint (v);
+      *ppid_available = TRUE;
+    }
+  }
+}
+
+static guint64
+on_get_stream_bytes_sent (GstSctpEnc * self, guint stream_id)
+{
+  gchar *pad_name;
+  GstPad *pad;
+  GstSctpEncPad *sctpenc_pad;
+  guint64 bytes_sent;
+
+  pad_name = g_strdup_printf ("sink_%u", stream_id);
+  pad = gst_element_get_static_pad (GST_ELEMENT (self), pad_name);
+  g_free (pad_name);
+
+  if (!pad) {
+    GST_DEBUG_OBJECT (self,
+        "Buffered amount requested on a stream that does not exist!");
+    return 0;
+  }
+
+  sctpenc_pad = GST_SCTP_ENC_PAD (pad);
+
+  g_mutex_lock (&sctpenc_pad->lock);
+  bytes_sent = sctpenc_pad->bytes_sent;
+  g_mutex_unlock (&sctpenc_pad->lock);
+
+  gst_object_unref (sctpenc_pad);
+
+  return bytes_sent;
+}
diff --git a/ext/sctp/gstsctpenc.h b/ext/sctp/gstsctpenc.h
new file mode 100644
index 000000000..a05bd4e8d
--- /dev/null
+++ b/ext/sctp/gstsctpenc.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2015, Collabora Ltd.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this
+ * list of conditions and the following disclaimer in the documentation and/or other
+ * materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ */
+
+#ifndef __GST_SCTP_ENC_H__
+#define __GST_SCTP_ENC_H__
+
+#include <gst/gst.h>
+#include <gst/base/base.h>
+#include "sctpassociation.h"
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_SCTP_ENC (gst_sctp_enc_get_type())
+#define GST_SCTP_ENC(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_SCTP_ENC, GstSctpEnc))
+#define GST_SCTP_ENC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_SCTP_ENC, GstSctpEncClass))
+#define GST_IS_SCTP_ENC(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_SCTP_ENC))
+#define GST_IS_SCTP_ENC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_SCTP_ENC))
+typedef struct _GstSctpEnc GstSctpEnc;
+typedef struct _GstSctpEncClass GstSctpEncClass;
+typedef struct _GstSctpEncPrivate GstSctpEncPrivate;
+
+struct _GstSctpEnc
+{
+  GstElement element;
+
+  GstPad *src_pad;
+  gboolean need_stream_start_caps, need_segment;
+  guint32 sctp_association_id;
+  guint16 remote_sctp_port;
+  gboolean use_sock_stream;
+
+  GstSctpAssociation *sctp_association;
+  GstDataQueue *outbound_sctp_packet_queue;
+
+  GQueue pending_pads;
+
+  gulong signal_handler_state_changed;
+};
+
+struct _GstSctpEncClass
+{
+  GstElementClass parent_class;
+
+  void (*on_sctp_association_is_established) (GstSctpEnc * sctp_enc,
+      gboolean established);
+    guint64 (*on_get_stream_bytes_sent) (GstSctpEnc * sctp_enc,
+      guint stream_id);
+
+};
+
+GType gst_sctp_enc_get_type (void);
+
+G_END_DECLS
+
+#endif /* __GST_SCTP_ENC_H__ */
diff --git a/ext/sctp/gstsctpplugin.c b/ext/sctp/gstsctpplugin.c
new file mode 100644
index 000000000..888a94c84
--- /dev/null
+++ b/ext/sctp/gstsctpplugin.c
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2015, Collabora Ltd.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this
+ * list of conditions and the following disclaimer in the documentation and/or other
+ * materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstsctpdec.h"
+#include "gstsctpenc.h"
+
+#include <gst/gst.h>
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  return gst_element_register (plugin, "sctpenc", GST_RANK_NONE,
+      GST_TYPE_SCTP_ENC)
+      && gst_element_register (plugin, "sctpdec", GST_RANK_NONE,
+      GST_TYPE_SCTP_DEC);
+}
+
+
+#ifndef PACKAGE
+#define PACKAGE "sctp"
+#endif
+
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    sctp,
+    "SCTP encoder/decoder plugin",
+    plugin_init, PACKAGE_VERSION, "BSD", GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
diff --git a/ext/sctp/meson.build b/ext/sctp/meson.build
new file mode 100644
index 000000000..c83047ec4
--- /dev/null
+++ b/ext/sctp/meson.build
@@ -0,0 +1,37 @@
+sctp_sources = [
+  'gstsctpdec.c',
+  'gstsctpenc.c',
+  'gstsctpplugin.c',
+  'sctpassociation.c'
+]
+
+if get_option('sctp').disabled()
+  subdir_done()
+endif
+
+sctp_platform_deps = []
+
+sctp_dep = cc.find_library('usrsctp', required : get_option('sctp').enabled())
+sctp_header = cc.has_header('usrsctp.h')
+if host_system == 'windows'
+  sctp_platform_deps += [cc.find_library('ws2_32')]
+endif
+
+if get_option('sctp').enabled()
+  if not sctp_dep.found() or not sctp_header
+    error('sctp plugin enabled but could not find libusrsctp')
+  endif
+endif
+
+if sctp_dep.found() and sctp_header
+  gstsctp = library('gstsctp',
+    sctp_sources,
+    c_args : gst_plugins_bad_args,
+    include_directories : [configinc],
+    dependencies : [sctp_dep, gst_dep, gstbase_dep, gstsctp_dep, sctp_platform_deps],
+    install : true,
+    install_dir : plugins_install_dir,
+  )
+  pkgconfig.generate(gstsctp, install_dir : plugins_pkgconfig_install_dir)
+  plugins += [gstsctp]
+endif
diff --git a/ext/sctp/sctpassociation.c b/ext/sctp/sctpassociation.c
new file mode 100644
index 000000000..50a3ed374
--- /dev/null
+++ b/ext/sctp/sctpassociation.c
@@ -0,0 +1,841 @@
+/*
+ * Copyright (c) 2015, Collabora Ltd.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this
+ * list of conditions and the following disclaimer in the documentation and/or other
+ * materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "sctpassociation.h"
+
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+#define GST_SCTP_ASSOCIATION_STATE_TYPE (gst_sctp_association_state_get_type())
+static GType
+gst_sctp_association_state_get_type (void)
+{
+  static const GEnumValue values[] = {
+    {GST_SCTP_ASSOCIATION_STATE_NEW, "state-new", "state-new"},
+    {GST_SCTP_ASSOCIATION_STATE_READY, "state-ready", "state-ready"},
+    {GST_SCTP_ASSOCIATION_STATE_CONNECTING, "state-connecting",
+        "state-connecting"},
+    {GST_SCTP_ASSOCIATION_STATE_CONNECTED, "state-connected",
+        "state-connected"},
+    {GST_SCTP_ASSOCIATION_STATE_DISCONNECTING, "state-disconnecting",
+        "state-disconnecting"},
+    {GST_SCTP_ASSOCIATION_STATE_DISCONNECTED, "state-disconnected",
+        "state-disconnected"},
+    {GST_SCTP_ASSOCIATION_STATE_ERROR, "state-error", "state-error"},
+    {0, NULL, NULL}
+  };
+  static volatile GType id = 0;
+
+  if (g_once_init_enter ((gsize *) & id)) {
+    GType _id;
+    _id = g_enum_register_static ("GstSctpAssociationState", values);
+    g_once_init_leave ((gsize *) & id, _id);
+  }
+
+  return id;
+}
+
+G_DEFINE_TYPE (GstSctpAssociation, gst_sctp_association, G_TYPE_OBJECT);
+
+enum
+{
+  SIGNAL_STREAM_RESET,
+  LAST_SIGNAL
+};
+
+
+enum
+{
+  PROP_0,
+
+  PROP_ASSOCIATION_ID,
+  PROP_LOCAL_PORT,
+  PROP_REMOTE_PORT,
+  PROP_STATE,
+  PROP_USE_SOCK_STREAM,
+
+  NUM_PROPERTIES
+};
+
+static guint signals[LAST_SIGNAL] = { 0 };
+
+static GParamSpec *properties[NUM_PROPERTIES];
+
+#define DEFAULT_NUMBER_OF_SCTP_STREAMS 1024
+#define DEFAULT_LOCAL_SCTP_PORT 0
+#define DEFAULT_REMOTE_SCTP_PORT 0
+
+static GHashTable *associations = NULL;
+G_LOCK_DEFINE_STATIC (associations_lock);
+static guint32 number_of_associations = 0;
+
+/* Interface implementations */
+static void gst_sctp_association_finalize (GObject * object);
+static void gst_sctp_association_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+static void gst_sctp_association_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+
+static struct socket *create_sctp_socket (GstSctpAssociation *
+    gst_sctp_association);
+static struct sockaddr_conn get_sctp_socket_address (GstSctpAssociation *
+    gst_sctp_association, guint16 port);
+static gpointer connection_thread_func (GstSctpAssociation * self);
+static gboolean client_role_connect (GstSctpAssociation * self);
+static int sctp_packet_out (void *addr, void *buffer, size_t length, guint8 tos,
+    guint8 set_df);
+static int receive_cb (struct socket *sock, union sctp_sockstore addr,
+    void *data, size_t datalen, struct sctp_rcvinfo rcv_info, gint flags,
+    void *ulp_info);
+static void handle_notification (GstSctpAssociation * self,
+    const union sctp_notification *notification, size_t length);
+static void handle_association_changed (GstSctpAssociation * self,
+    const struct sctp_assoc_change *sac);
+static void handle_stream_reset_event (GstSctpAssociation * self,
+    const struct sctp_stream_reset_event *ssr);
+static void handle_message (GstSctpAssociation * self, guint8 * data,
+    guint32 datalen, guint16 stream_id, guint32 ppid);
+
+static void maybe_set_state_to_ready (GstSctpAssociation * self);
+static void gst_sctp_association_change_state (GstSctpAssociation * self,
+    GstSctpAssociationState new_state, gboolean notify);
+
+static void
+gst_sctp_association_class_init (GstSctpAssociationClass * klass)
+{
+  GObjectClass *gobject_class;
+
+  gobject_class = (GObjectClass *) klass;
+
+  gobject_class->finalize = gst_sctp_association_finalize;
+  gobject_class->set_property = gst_sctp_association_set_property;
+  gobject_class->get_property = gst_sctp_association_get_property;
+
+  signals[SIGNAL_STREAM_RESET] =
+      g_signal_new ("stream-reset", G_OBJECT_CLASS_TYPE (klass),
+      G_SIGNAL_RUN_FIRST, G_STRUCT_OFFSET (GstSctpAssociationClass,
+          on_sctp_stream_reset), NULL, NULL, g_cclosure_marshal_generic,
+      G_TYPE_NONE, 1, G_TYPE_UINT);
+
+  properties[PROP_ASSOCIATION_ID] = g_param_spec_uint ("association-id",
+      "The SCTP association-id", "The SCTP association-id.", 0, G_MAXUSHORT,
+      DEFAULT_LOCAL_SCTP_PORT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+
+  properties[PROP_LOCAL_PORT] = g_param_spec_uint ("local-port", "Local SCTP",
+      "The local SCTP port for this association", 0, G_MAXUSHORT,
+      DEFAULT_LOCAL_SCTP_PORT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+
+  properties[PROP_REMOTE_PORT] =
+      g_param_spec_uint ("remote-port", "Remote SCTP",
+      "The remote SCTP port for this association", 0, G_MAXUSHORT,
+      DEFAULT_LOCAL_SCTP_PORT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+
+  properties[PROP_STATE] = g_param_spec_enum ("state", "SCTP Association state",
+      "The state of the SCTP association", GST_SCTP_ASSOCIATION_STATE_TYPE,
+      GST_SCTP_ASSOCIATION_STATE_NEW,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+
+  properties[PROP_USE_SOCK_STREAM] =
+      g_param_spec_boolean ("use-sock-stream", "Use sock-stream",
+      "When set to TRUE, a sequenced, reliable, connection-based connection is used."
+      "When TRUE the partial reliability parameters of the channel is ignored.",
+      FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+
+  g_object_class_install_properties (gobject_class, NUM_PROPERTIES, properties);
+}
+
+static void
+gst_sctp_association_init (GstSctpAssociation * self)
+{
+  /* No need to lock mutex here as long as the function is only called from gst_sctp_association_get */
+  if (number_of_associations == 0) {
+    usrsctp_init (0, sctp_packet_out, g_print);
+
+    /* Explicit Congestion Notification */
+    usrsctp_sysctl_set_sctp_ecn_enable (0);
+
+    usrsctp_sysctl_set_sctp_nr_outgoing_streams_default
+        (DEFAULT_NUMBER_OF_SCTP_STREAMS);
+  }
+  number_of_associations++;
+
+  self->local_port = DEFAULT_LOCAL_SCTP_PORT;
+  self->remote_port = DEFAULT_REMOTE_SCTP_PORT;
+  self->sctp_ass_sock = NULL;
+
+  self->connection_thread = NULL;
+  g_mutex_init (&self->association_mutex);
+
+  self->state = GST_SCTP_ASSOCIATION_STATE_NEW;
+
+  self->use_sock_stream = FALSE;
+
+  usrsctp_register_address ((void *) self);
+}
+
+static void
+gst_sctp_association_finalize (GObject * object)
+{
+  GstSctpAssociation *self = GST_SCTP_ASSOCIATION (object);
+
+  G_LOCK (associations_lock);
+
+  g_hash_table_remove (associations, GUINT_TO_POINTER (self->association_id));
+
+  usrsctp_deregister_address ((void *) self);
+  number_of_associations--;
+  if (number_of_associations == 0) {
+    usrsctp_finish ();
+  }
+  G_UNLOCK (associations_lock);
+
+  if (self->connection_thread)
+    g_thread_join (self->connection_thread);
+
+  G_OBJECT_CLASS (gst_sctp_association_parent_class)->finalize (object);
+}
+
+static void
+gst_sctp_association_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstSctpAssociation *self = GST_SCTP_ASSOCIATION (object);
+
+  g_mutex_lock (&self->association_mutex);
+  if (self->state != GST_SCTP_ASSOCIATION_STATE_NEW) {
+    switch (prop_id) {
+      case PROP_LOCAL_PORT:
+      case PROP_REMOTE_PORT:
+        g_warning ("These properties cannot be set in this state");
+        goto error;
+    }
+  }
+
+  switch (prop_id) {
+    case PROP_ASSOCIATION_ID:
+      self->association_id = g_value_get_uint (value);
+      break;
+    case PROP_LOCAL_PORT:
+      self->local_port = g_value_get_uint (value);
+      break;
+    case PROP_REMOTE_PORT:
+      self->remote_port = g_value_get_uint (value);
+      break;
+    case PROP_STATE:
+      self->state = g_value_get_enum (value);
+      break;
+    case PROP_USE_SOCK_STREAM:
+      self->use_sock_stream = g_value_get_boolean (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
+      break;
+  }
+
+  g_mutex_unlock (&self->association_mutex);
+  if (prop_id == PROP_LOCAL_PORT || prop_id == PROP_REMOTE_PORT)
+    maybe_set_state_to_ready (self);
+
+  return;
+
+error:
+  g_mutex_unlock (&self->association_mutex);
+}
+
+static void
+maybe_set_state_to_ready (GstSctpAssociation * self)
+{
+  gboolean signal_ready_state = FALSE;
+
+  g_mutex_lock (&self->association_mutex);
+  if ((self->state == GST_SCTP_ASSOCIATION_STATE_NEW) &&
+      (self->local_port != 0 && self->remote_port != 0)
+      && (self->packet_out_cb != NULL) && (self->packet_received_cb != NULL)) {
+    signal_ready_state = TRUE;
+    gst_sctp_association_change_state (self, GST_SCTP_ASSOCIATION_STATE_READY,
+        FALSE);
+  }
+  g_mutex_unlock (&self->association_mutex);
+
+  /* The reason the state is changed twice is that we do not want to change state with
+   * notification while the association_mutex is locked. If someone listens
+   * on property change and call this object a deadlock might occur.*/
+  if (signal_ready_state)
+    gst_sctp_association_change_state (self, GST_SCTP_ASSOCIATION_STATE_READY,
+        TRUE);
+
+}
+
+static void
+gst_sctp_association_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstSctpAssociation *self = GST_SCTP_ASSOCIATION (object);
+
+  switch (prop_id) {
+    case PROP_ASSOCIATION_ID:
+      g_value_set_uint (value, self->association_id);
+      break;
+    case PROP_LOCAL_PORT:
+      g_value_set_uint (value, self->local_port);
+      break;
+    case PROP_REMOTE_PORT:
+      g_value_set_uint (value, self->remote_port);
+      break;
+    case PROP_STATE:
+      g_value_set_enum (value, self->state);
+      break;
+    case PROP_USE_SOCK_STREAM:
+      g_value_set_boolean (value, self->use_sock_stream);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
+      break;
+  }
+}
+
+/* Public functions */
+
+GstSctpAssociation *
+gst_sctp_association_get (guint32 association_id)
+{
+  GstSctpAssociation *association;
+
+  G_LOCK (associations_lock);
+  if (!associations) {
+    associations =
+        g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, NULL);
+  }
+
+  association =
+      g_hash_table_lookup (associations, GUINT_TO_POINTER (association_id));
+  if (!association) {
+    association =
+        g_object_new (GST_SCTP_TYPE_ASSOCIATION, "association-id",
+        association_id, NULL);
+    g_hash_table_insert (associations, GUINT_TO_POINTER (association_id),
+        association);
+  } else {
+    g_object_ref (association);
+  }
+  G_UNLOCK (associations_lock);
+  return association;
+}
+
+gboolean
+gst_sctp_association_start (GstSctpAssociation * self)
+{
+  gchar *thread_name;
+
+  g_mutex_lock (&self->association_mutex);
+  if (self->state != GST_SCTP_ASSOCIATION_STATE_READY) {
+    g_warning ("SCTP association is in wrong state and cannot be started");
+    goto configure_required;
+  }
+
+  if ((self->sctp_ass_sock = create_sctp_socket (self)) == NULL)
+    goto error;
+
+  gst_sctp_association_change_state (self,
+      GST_SCTP_ASSOCIATION_STATE_CONNECTING, FALSE);
+  g_mutex_unlock (&self->association_mutex);
+
+  /* The reason the state is changed twice is that we do not want to change state with
+   * notification while the association_mutex is locked. If someone listens
+   * on property change and call this object a deadlock might occur.*/
+  gst_sctp_association_change_state (self,
+      GST_SCTP_ASSOCIATION_STATE_CONNECTING, TRUE);
+
+  thread_name = g_strdup_printf ("connection_thread_%u", self->association_id);
+  self->connection_thread = g_thread_new (thread_name,
+      (GThreadFunc) connection_thread_func, self);
+  g_free (thread_name);
+
+  return TRUE;
+error:
+  g_mutex_unlock (&self->association_mutex);
+  gst_sctp_association_change_state (self, GST_SCTP_ASSOCIATION_STATE_ERROR,
+      TRUE);
+configure_required:
+  g_mutex_unlock (&self->association_mutex);
+  return FALSE;
+}
+
+void
+gst_sctp_association_set_on_packet_out (GstSctpAssociation * self,
+    GstSctpAssociationPacketOutCb packet_out_cb, gpointer user_data)
+{
+  g_return_if_fail (GST_SCTP_IS_ASSOCIATION (self));
+
+  g_mutex_lock (&self->association_mutex);
+  if (self->state == GST_SCTP_ASSOCIATION_STATE_NEW) {
+    self->packet_out_cb = packet_out_cb;
+    self->packet_out_user_data = user_data;
+  } else {
+    /* This is to be thread safe. The Association might try to write to the closure already */
+    g_warning ("It is not possible to change packet callback in this state");
+  }
+  g_mutex_unlock (&self->association_mutex);
+
+  maybe_set_state_to_ready (self);
+}
+
+void
+gst_sctp_association_set_on_packet_received (GstSctpAssociation * self,
+    GstSctpAssociationPacketReceivedCb packet_received_cb, gpointer user_data)
+{
+  g_return_if_fail (GST_SCTP_IS_ASSOCIATION (self));
+
+  g_mutex_lock (&self->association_mutex);
+  if (self->state == GST_SCTP_ASSOCIATION_STATE_NEW) {
+    self->packet_received_cb = packet_received_cb;
+    self->packet_received_user_data = user_data;
+  } else {
+    /* This is to be thread safe. The Association might try to write to the closure already */
+    g_warning ("It is not possible to change receive callback in this state");
+  }
+  g_mutex_unlock (&self->association_mutex);
+
+  maybe_set_state_to_ready (self);
+}
+
+void
+gst_sctp_association_incoming_packet (GstSctpAssociation * self, guint8 * buf,
+    guint32 length)
+{
+  usrsctp_conninput ((void *) self, (const void *) buf, (size_t) length, 0);
+}
+
+gboolean
+gst_sctp_association_send_data (GstSctpAssociation * self, guint8 * buf,
+    guint32 length, guint16 stream_id, guint32 ppid, gboolean ordered,
+    GstSctpAssociationPartialReliability pr, guint32 reliability_param)
+{
+  struct sctp_sendv_spa spa;
+  gint32 bytes_sent;
+  gboolean result = FALSE;
+  struct sockaddr_conn remote_addr;
+
+  g_mutex_lock (&self->association_mutex);
+  if (self->state != GST_SCTP_ASSOCIATION_STATE_CONNECTED)
+    goto end;
+
+  memset (&spa, 0, sizeof (spa));
+
+  spa.sendv_sndinfo.snd_ppid = g_htonl (ppid);
+  spa.sendv_sndinfo.snd_sid = stream_id;
+  spa.sendv_sndinfo.snd_flags = ordered ? 0 : SCTP_UNORDERED;
+  spa.sendv_sndinfo.snd_context = 0;
+  spa.sendv_sndinfo.snd_assoc_id = 0;
+  spa.sendv_flags = SCTP_SEND_SNDINFO_VALID;
+  if (pr != GST_SCTP_ASSOCIATION_PARTIAL_RELIABILITY_NONE) {
+    spa.sendv_flags |= SCTP_SEND_PRINFO_VALID;
+    spa.sendv_prinfo.pr_value = g_htonl (reliability_param);
+    if (pr == GST_SCTP_ASSOCIATION_PARTIAL_RELIABILITY_TTL)
+      spa.sendv_prinfo.pr_policy = SCTP_PR_SCTP_TTL;
+    else if (pr == GST_SCTP_ASSOCIATION_PARTIAL_RELIABILITY_RTX)
+      spa.sendv_prinfo.pr_policy = SCTP_PR_SCTP_RTX;
+    else if (pr == GST_SCTP_ASSOCIATION_PARTIAL_RELIABILITY_BUF)
+      spa.sendv_prinfo.pr_policy = SCTP_PR_SCTP_BUF;
+  }
+
+  remote_addr = get_sctp_socket_address (self, self->remote_port);
+  bytes_sent =
+      usrsctp_sendv (self->sctp_ass_sock, buf, length,
+      (struct sockaddr *) &remote_addr, 1, (void *) &spa,
+      (socklen_t) sizeof (struct sctp_sendv_spa), SCTP_SENDV_SPA, 0);
+  if (bytes_sent < 0) {
+    if (errno == EAGAIN || errno == EWOULDBLOCK) {
+      /* Resending this buffer is taken care of by the gstsctpenc */
+      goto end;
+    } else {
+      g_warning ("Error sending data on stream %u: (%u) %s", stream_id, errno,
+          strerror (errno));
+      goto end;
+    }
+  }
+
+  result = TRUE;
+end:
+  g_mutex_unlock (&self->association_mutex);
+  return result;
+}
+
+
+void
+gst_sctp_association_reset_stream (GstSctpAssociation * self, guint16 stream_id)
+{
+  struct sctp_reset_streams *srs;
+  socklen_t length;
+
+  length = (socklen_t) (sizeof (struct sctp_reset_streams) + sizeof (guint16));
+  srs = (struct sctp_reset_streams *) g_malloc0 (length);
+  srs->srs_flags = SCTP_STREAM_RESET_OUTGOING;
+  srs->srs_number_streams = 1;
+  srs->srs_stream_list[0] = stream_id;
+
+  g_mutex_lock (&self->association_mutex);
+  usrsctp_setsockopt (self->sctp_ass_sock, IPPROTO_SCTP, SCTP_RESET_STREAMS,
+      srs, length);
+  g_mutex_unlock (&self->association_mutex);
+
+  g_free (srs);
+}
+
+void
+gst_sctp_association_force_close (GstSctpAssociation * self)
+{
+  g_mutex_lock (&self->association_mutex);
+  if (self->sctp_ass_sock) {
+    usrsctp_close (self->sctp_ass_sock);
+    self->sctp_ass_sock = NULL;
+
+  }
+  g_mutex_unlock (&self->association_mutex);
+}
+
+static struct socket *
+create_sctp_socket (GstSctpAssociation * self)
+{
+  struct socket *sock;
+  struct linger l;
+  struct sctp_event event;
+  struct sctp_assoc_value stream_reset;
+  int value = 1;
+  guint16 event_types[] = {
+    SCTP_ASSOC_CHANGE,
+    SCTP_PEER_ADDR_CHANGE,
+    SCTP_REMOTE_ERROR,
+    SCTP_SEND_FAILED,
+    SCTP_SHUTDOWN_EVENT,
+    SCTP_ADAPTATION_INDICATION,
+    /*SCTP_PARTIAL_DELIVERY_EVENT, */
+    /*SCTP_AUTHENTICATION_EVENT, */
+    SCTP_STREAM_RESET_EVENT,
+    /*SCTP_SENDER_DRY_EVENT, */
+    /*SCTP_NOTIFICATIONS_STOPPED_EVENT, */
+    /*SCTP_ASSOC_RESET_EVENT, */
+    SCTP_STREAM_CHANGE_EVENT
+  };
+  guint32 i;
+  guint sock_type = self->use_sock_stream ? SOCK_STREAM : SOCK_SEQPACKET;
+
+  if ((sock =
+          usrsctp_socket (AF_CONN, sock_type, IPPROTO_SCTP, receive_cb, NULL, 0,
+              (void *) self)) == NULL)
+    goto error;
+
+  if (usrsctp_set_non_blocking (sock, 1) < 0) {
+    g_warning ("Could not set non-blocking mode on SCTP socket");
+    goto error;
+  }
+
+  memset (&l, 0, sizeof (l));
+  l.l_onoff = 1;
+  l.l_linger = 0;
+  if (usrsctp_setsockopt (sock, SOL_SOCKET, SO_LINGER, (const void *) &l,
+          (socklen_t) sizeof (struct linger)) < 0) {
+    g_warning ("Could not set SO_LINGER on SCTP socket");
+    goto error;
+  }
+
+  if (usrsctp_setsockopt (sock, IPPROTO_SCTP, SCTP_NODELAY, &value,
+          sizeof (int))) {
+    g_warning ("Could not set SCTP_NODELAY");
+    goto error;
+  }
+
+  memset (&stream_reset, 0, sizeof (stream_reset));
+  stream_reset.assoc_id = SCTP_ALL_ASSOC;
+  stream_reset.assoc_value = 1;
+  if (usrsctp_setsockopt (sock, IPPROTO_SCTP, SCTP_ENABLE_STREAM_RESET,
+          &stream_reset, sizeof (stream_reset))) {
+    g_warning ("Could not set SCTP_ENABLE_STREAM_RESET");
+    goto error;
+  }
+
+  memset (&event, 0, sizeof (event));
+  event.se_assoc_id = SCTP_ALL_ASSOC;
+  event.se_on = 1;
+  for (i = 0; i < sizeof (event_types) / sizeof (event_types[0]); i++) {
+    event.se_type = event_types[i];
+    if (usrsctp_setsockopt (sock, IPPROTO_SCTP, SCTP_EVENT,
+            &event, sizeof (event)) < 0) {
+      g_warning ("Failed to register event %u", event_types[i]);
+    }
+  }
+
+  return sock;
+error:
+  if (sock) {
+    usrsctp_close (sock);
+    g_warning ("Could not create socket. Error: (%u) %s", errno,
+        strerror (errno));
+    errno = 0;
+    sock = NULL;
+  }
+  return NULL;
+}
+
+static struct sockaddr_conn
+get_sctp_socket_address (GstSctpAssociation * gst_sctp_association,
+    guint16 port)
+{
+  struct sockaddr_conn addr;
+
+  memset ((void *) &addr, 0, sizeof (struct sockaddr_conn));
+#ifdef __APPLE__
+  addr.sconn_len = sizeof (struct sockaddr_conn);
+#endif
+  addr.sconn_family = AF_CONN;
+  addr.sconn_port = g_htons (port);
+  addr.sconn_addr = (void *) gst_sctp_association;
+
+  return addr;
+}
+
+static gpointer
+connection_thread_func (GstSctpAssociation * self)
+{
+  /* TODO: Support both server and client role */
+  client_role_connect (self);
+  return NULL;
+}
+
+static gboolean
+client_role_connect (GstSctpAssociation * self)
+{
+  struct sockaddr_conn addr;
+  gint ret;
+
+  g_mutex_lock (&self->association_mutex);
+  addr = get_sctp_socket_address (self, self->local_port);
+  ret =
+      usrsctp_bind (self->sctp_ass_sock, (struct sockaddr *) &addr,
+      sizeof (struct sockaddr_conn));
+  if (ret < 0) {
+    g_warning ("usrsctp_bind() error: (%u) %s", errno, strerror (errno));
+    goto error;
+  }
+
+  addr = get_sctp_socket_address (self, self->remote_port);
+  ret =
+      usrsctp_connect (self->sctp_ass_sock, (struct sockaddr *) &addr,
+      sizeof (struct sockaddr_conn));
+  if (ret < 0 && errno != EINPROGRESS) {
+    g_warning ("usrsctp_connect() error: (%u) %s", errno, strerror (errno));
+    goto error;
+  }
+  g_mutex_unlock (&self->association_mutex);
+  return TRUE;
+error:
+  g_mutex_unlock (&self->association_mutex);
+  return FALSE;
+}
+
+static int
+sctp_packet_out (void *addr, void *buffer, size_t length, guint8 tos,
+    guint8 set_df)
+{
+  GstSctpAssociation *self = GST_SCTP_ASSOCIATION (addr);
+
+  if (self->packet_out_cb) {
+    self->packet_out_cb (self, buffer, length, self->packet_out_user_data);
+  }
+
+  return 0;
+}
+
+static int
+receive_cb (struct socket *sock, union sctp_sockstore addr, void *data,
+    size_t datalen, struct sctp_rcvinfo rcv_info, gint flags, void *ulp_info)
+{
+  GstSctpAssociation *self = GST_SCTP_ASSOCIATION (ulp_info);
+
+  if (!data) {
+    /* Not sure if this can happend. */
+    g_warning ("Received empty data buffer");
+  } else {
+    if (flags & MSG_NOTIFICATION) {
+      handle_notification (self, (const union sctp_notification *) data,
+          datalen);
+      /* We use this instead of a bare `free()` so that we use the `free` from
+       * the C runtime that usrsctp was built with. This makes a difference on
+       * Windows where libusrstcp and GStreamer can be linked to two different
+       * CRTs. */
+      usrsctp_freedumpbuffer (data);
+    } else {
+      handle_message (self, data, datalen, rcv_info.rcv_sid,
+          ntohl (rcv_info.rcv_ppid));
+    }
+  }
+
+  return 1;
+}
+
+static void
+handle_notification (GstSctpAssociation * self,
+    const union sctp_notification *notification, size_t length)
+{
+  g_assert (notification->sn_header.sn_length == length);
+
+  switch (notification->sn_header.sn_type) {
+    case SCTP_ASSOC_CHANGE:
+      g_log (G_LOG_DOMAIN, G_LOG_LEVEL_INFO, "Event: SCTP_ASSOC_CHANGE");
+      handle_association_changed (self, &notification->sn_assoc_change);
+      break;
+    case SCTP_PEER_ADDR_CHANGE:
+      g_log (G_LOG_DOMAIN, G_LOG_LEVEL_INFO, "Event: SCTP_PEER_ADDR_CHANGE");
+      break;
+    case SCTP_REMOTE_ERROR:
+      g_log (G_LOG_DOMAIN, G_LOG_LEVEL_INFO, "Event: SCTP_REMOTE_ERROR");
+      break;
+    case SCTP_SEND_FAILED:
+      g_log (G_LOG_DOMAIN, G_LOG_LEVEL_INFO, "Event: SCTP_SEND_FAILED");
+      break;
+    case SCTP_SHUTDOWN_EVENT:
+      g_log (G_LOG_DOMAIN, G_LOG_LEVEL_INFO, "Event: SCTP_SHUTDOWN_EVENT");
+      break;
+    case SCTP_ADAPTATION_INDICATION:
+      g_log (G_LOG_DOMAIN, G_LOG_LEVEL_INFO,
+          "Event: SCTP_ADAPTATION_INDICATION");
+      break;
+    case SCTP_PARTIAL_DELIVERY_EVENT:
+      g_log (G_LOG_DOMAIN, G_LOG_LEVEL_INFO,
+          "Event: SCTP_PARTIAL_DELIVERY_EVENT");
+      break;
+    case SCTP_AUTHENTICATION_EVENT:
+      g_log (G_LOG_DOMAIN, G_LOG_LEVEL_INFO,
+          "Event: SCTP_AUTHENTICATION_EVENT");
+      break;
+    case SCTP_STREAM_RESET_EVENT:
+      g_log (G_LOG_DOMAIN, G_LOG_LEVEL_INFO, "Event: SCTP_STREAM_RESET_EVENT");
+      handle_stream_reset_event (self, &notification->sn_strreset_event);
+      break;
+    case SCTP_SENDER_DRY_EVENT:
+      g_log (G_LOG_DOMAIN, G_LOG_LEVEL_INFO, "Event: SCTP_SENDER_DRY_EVENT");
+      break;
+    case SCTP_NOTIFICATIONS_STOPPED_EVENT:
+      g_log (G_LOG_DOMAIN, G_LOG_LEVEL_INFO,
+          "Event: SCTP_NOTIFICATIONS_STOPPED_EVENT");
+      break;
+    case SCTP_ASSOC_RESET_EVENT:
+      g_log (G_LOG_DOMAIN, G_LOG_LEVEL_INFO, "Event: SCTP_ASSOC_RESET_EVENT");
+      break;
+    case SCTP_STREAM_CHANGE_EVENT:
+      g_log (G_LOG_DOMAIN, G_LOG_LEVEL_INFO, "Event: SCTP_STREAM_CHANGE_EVENT");
+      break;
+    case SCTP_SEND_FAILED_EVENT:
+      g_log (G_LOG_DOMAIN, G_LOG_LEVEL_INFO, "Event: SCTP_SEND_FAILED_EVENT");
+      break;
+    default:
+      break;
+  }
+}
+
+static void
+handle_association_changed (GstSctpAssociation * self,
+    const struct sctp_assoc_change *sac)
+{
+  gboolean change_state = FALSE;
+  GstSctpAssociationState new_state;
+
+  switch (sac->sac_state) {
+    case SCTP_COMM_UP:
+      g_log (G_LOG_DOMAIN, G_LOG_LEVEL_INFO, "SCTP_COMM_UP()");
+      g_mutex_lock (&self->association_mutex);
+      if (self->state == GST_SCTP_ASSOCIATION_STATE_CONNECTING) {
+        change_state = TRUE;
+        new_state = GST_SCTP_ASSOCIATION_STATE_CONNECTED;
+        g_log (G_LOG_DOMAIN, G_LOG_LEVEL_INFO, "SCTP association connected!");
+      } else if (self->state == GST_SCTP_ASSOCIATION_STATE_CONNECTED) {
+        g_warning ("SCTP association already open");
+      } else {
+        g_warning ("SCTP association in unexpected state");
+      }
+      g_mutex_unlock (&self->association_mutex);
+      break;
+    case SCTP_COMM_LOST:
+      g_warning ("SCTP event SCTP_COMM_LOST received");
+      /* TODO: Tear down association and signal that this has happend */
+      break;
+    case SCTP_RESTART:
+      g_log (G_LOG_DOMAIN, G_LOG_LEVEL_INFO,
+          "SCTP event SCTP_RESTART received");
+      break;
+    case SCTP_SHUTDOWN_COMP:
+      g_warning ("SCTP event SCTP_SHUTDOWN_COMP received");
+      /* TODO: Tear down association and signal that this has happend */
+      break;
+    case SCTP_CANT_STR_ASSOC:
+      g_warning ("SCTP event SCTP_CANT_STR_ASSOC received");
+      break;
+  }
+
+  if (change_state)
+    gst_sctp_association_change_state (self, new_state, TRUE);
+}
+
+static void
+handle_stream_reset_event (GstSctpAssociation * self,
+    const struct sctp_stream_reset_event *sr)
+{
+  guint32 i, n;
+  if (!(sr->strreset_flags & SCTP_STREAM_RESET_DENIED) &&
+      !(sr->strreset_flags & SCTP_STREAM_RESET_DENIED)) {
+    n = (sr->strreset_length -
+        sizeof (struct sctp_stream_reset_event)) / sizeof (uint16_t);
+    for (i = 0; i < n; i++) {
+      if (sr->strreset_flags & SCTP_STREAM_RESET_INCOMING_SSN) {
+        g_signal_emit (self, signals[SIGNAL_STREAM_RESET], 0,
+            sr->strreset_stream_list[i]);
+      }
+    }
+  }
+}
+
+static void
+handle_message (GstSctpAssociation * self, guint8 * data, guint32 datalen,
+    guint16 stream_id, guint32 ppid)
+{
+  if (self->packet_received_cb) {
+    self->packet_received_cb (self, data, datalen, stream_id, ppid,
+        self->packet_received_user_data);
+  }
+}
+
+static void
+gst_sctp_association_change_state (GstSctpAssociation * self,
+    GstSctpAssociationState new_state, gboolean notify)
+{
+  self->state = new_state;
+  if (notify)
+    g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_STATE]);
+}
diff --git a/ext/sctp/sctpassociation.h b/ext/sctp/sctpassociation.h
new file mode 100644
index 000000000..4510ba70f
--- /dev/null
+++ b/ext/sctp/sctpassociation.h
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2015, Collabora Ltd.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this
+ * list of conditions and the following disclaimer in the documentation and/or other
+ * materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ */
+
+#ifndef __GST_SCTP_ASSOCIATION_H__
+#define __GST_SCTP_ASSOCIATION_H__
+
+#include <glib-object.h>
+#define INET
+#define INET6
+#include <usrsctp.h>
+
+G_BEGIN_DECLS
+
+#define GST_SCTP_TYPE_ASSOCIATION                  (gst_sctp_association_get_type ())
+#define GST_SCTP_ASSOCIATION(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_SCTP_TYPE_ASSOCIATION, GstSctpAssociation))
+#define GST_SCTP_IS_ASSOCIATION(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_SCTP_TYPE_ASSOCIATION))
+#define GST_SCTP_ASSOCIATION_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), GST_SCTP_TYPE_ASSOCIATION, GstSctpAssociationClass))
+#define GST_SCTP_IS_ASSOCIATION_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_SCTP_TYPE_ASSOCIATION))
+#define GST_SCTP_ASSOCIATION_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_SCTP_TYPE_ASSOCIATION, GstSctpAssociationClass))
+
+typedef struct _GstSctpAssociation GstSctpAssociation;
+typedef struct _GstSctpAssociationClass GstSctpAssociationClass;
+
+typedef enum
+{
+  GST_SCTP_ASSOCIATION_STATE_NEW,
+  GST_SCTP_ASSOCIATION_STATE_READY,
+  GST_SCTP_ASSOCIATION_STATE_CONNECTING,
+  GST_SCTP_ASSOCIATION_STATE_CONNECTED,
+  GST_SCTP_ASSOCIATION_STATE_DISCONNECTING,
+  GST_SCTP_ASSOCIATION_STATE_DISCONNECTED,
+  GST_SCTP_ASSOCIATION_STATE_ERROR
+} GstSctpAssociationState;
+
+typedef enum
+{
+  GST_SCTP_ASSOCIATION_PARTIAL_RELIABILITY_NONE = 0x0000,
+  GST_SCTP_ASSOCIATION_PARTIAL_RELIABILITY_TTL = 0x0001,
+  GST_SCTP_ASSOCIATION_PARTIAL_RELIABILITY_BUF = 0x0002,
+  GST_SCTP_ASSOCIATION_PARTIAL_RELIABILITY_RTX = 0x0003
+} GstSctpAssociationPartialReliability;
+
+typedef void (*GstSctpAssociationPacketReceivedCb) (GstSctpAssociation *
+    sctp_association, guint8 * data, gsize length, guint16 stream_id,
+    guint ppid, gpointer user_data);
+typedef void (*GstSctpAssociationPacketOutCb) (GstSctpAssociation *
+    sctp_association, const guint8 * data, gsize length, gpointer user_data);
+
+struct _GstSctpAssociation
+{
+  GObject parent_instance;
+
+  guint32 association_id;
+  guint16 local_port;
+  guint16 remote_port;
+  gboolean use_sock_stream;
+  struct socket *sctp_ass_sock;
+
+  GMutex association_mutex;
+
+  GstSctpAssociationState state;
+
+  GThread *connection_thread;
+
+  GstSctpAssociationPacketReceivedCb packet_received_cb;
+  gpointer packet_received_user_data;
+
+  GstSctpAssociationPacketOutCb packet_out_cb;
+  gpointer packet_out_user_data;
+};
+
+struct _GstSctpAssociationClass
+{
+  GObjectClass parent_class;
+
+  void (*on_sctp_stream_reset) (GstSctpAssociation * sctp_association,
+      guint16 stream_id);
+};
+
+GType gst_sctp_association_get_type (void);
+
+GstSctpAssociation *gst_sctp_association_get (guint32 association_id);
+
+gboolean gst_sctp_association_start (GstSctpAssociation * self);
+void gst_sctp_association_set_on_packet_out (GstSctpAssociation * self,
+    GstSctpAssociationPacketOutCb packet_out_cb, gpointer user_data);
+void gst_sctp_association_set_on_packet_received (GstSctpAssociation * self,
+    GstSctpAssociationPacketReceivedCb packet_received_cb, gpointer user_data);
+void gst_sctp_association_incoming_packet (GstSctpAssociation * self,
+    guint8 * buf, guint32 length);
+gboolean gst_sctp_association_send_data (GstSctpAssociation * self,
+    guint8 * buf, guint32 length, guint16 stream_id, guint32 ppid,
+    gboolean ordered, GstSctpAssociationPartialReliability pr,
+    guint32 reliability_param);
+void gst_sctp_association_reset_stream (GstSctpAssociation * self,
+    guint16 stream_id);
+void gst_sctp_association_force_close (GstSctpAssociation * self);
+
+G_END_DECLS
+
+#endif /* __GST_SCTP_ASSOCIATION_H__ */
diff --git a/ext/webrtc/Makefile.am b/ext/webrtc/Makefile.am
index 5f9a71488..778f112d0 100644
--- a/ext/webrtc/Makefile.am
+++ b/ext/webrtc/Makefile.am
@@ -7,11 +7,13 @@ noinst_HEADERS = \
 	gstwebrtcstats.h \
 	icestream.h \
 	nicetransport.h \
+	sctptransport.h \
 	transportstream.h \
 	transportsendbin.h \
 	transportreceivebin.h \
 	utils.h \
 	webrtcsdp.h \
+	webrtcdatachannel.h \
 	webrtctransceiver.h
 
 libgstwebrtc_la_SOURCES = \
@@ -21,11 +23,13 @@ libgstwebrtc_la_SOURCES = \
 	gstwebrtcstats.c \
 	icestream.c \
 	nicetransport.c \
+	sctptransport.c \
 	transportstream.c \
 	transportsendbin.c \
 	transportreceivebin.c \
 	utils.c \
 	webrtcsdp.c \
+	webrtcdatachannel.c \
 	webrtctransceiver.c
 
 libgstwebrtc_la_SOURCES += $(BUILT_SOURCES)
@@ -40,12 +44,14 @@ libgstwebrtc_la_CFLAGS = \
 	$(GST_SDP_CFLAGS) \
 	$(NICE_CFLAGS)
 libgstwebrtc_la_LIBADD = \
+	-lgstapp-@GST_API_VERSION@ \
 	$(GST_PLUGINS_BASE_LIBS) \
 	$(GST_BASE_LIBS) \
 	$(GST_LIBS) \
 	$(GST_SDP_LIBS) \
 	$(NICE_LIBS) \
-	$(top_builddir)/gst-libs/gst/webrtc/libgstwebrtc-@GST_API_VERSION@.la
+	$(top_builddir)/gst-libs/gst/webrtc/libgstwebrtc-@GST_API_VERSION@.la \
+	$(top_builddir)/gst-libs/gst/sctp/libgstsctp-@GST_API_VERSION@.la
 
 libgstwebrtc_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
 libgstwebrtc_la_LIBTOOLFLAGS = $(GST_PLUGIN_LIBTOOLFLAGS)
diff --git a/ext/webrtc/fwd.h b/ext/webrtc/fwd.h
index 903145fbf..aa26ec6de 100644
--- a/ext/webrtc/fwd.h
+++ b/ext/webrtc/fwd.h
@@ -41,6 +41,10 @@ typedef struct _GstWebRTCNiceTransport GstWebRTCNiceTransport;
 typedef struct _GstWebRTCNiceTransportClass GstWebRTCNiceTransportClass;
 typedef struct _GstWebRTCNiceTransportPrivate GstWebRTCNiceTransportPrivate;
 
+typedef struct _GstWebRTCSCTPTransport GstWebRTCSCTPTransport;
+typedef struct _GstWebRTCSCTPTransportClass GstWebRTCSCTPTransportClass;
+typedef struct _GstWebRTCSCTPTransportPrivate GstWebRTCSCTPTransportPrivate;
+
 typedef struct _TransportStream TransportStream;
 typedef struct _TransportStreamClass TransportStreamClass;
 
diff --git a/ext/webrtc/gstwebrtcbin.c b/ext/webrtc/gstwebrtcbin.c
index b3746bf3e..4d2d95f49 100644
--- a/ext/webrtc/gstwebrtcbin.c
+++ b/ext/webrtc/gstwebrtcbin.c
@@ -28,6 +28,8 @@
 #include "utils.h"
 #include "webrtcsdp.h"
 #include "webrtctransceiver.h"
+#include "webrtcdatachannel.h"
+#include "sctptransport.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -50,8 +52,8 @@
 /*
  * This webrtcbin implements the majority of the W3's peerconnection API and
  * implementation guide where possible. Generating offers, answers and setting
- * local and remote SDP's are all supported.  To start with, only the media
- * interface has been implemented (no datachannel yet).
+ * local and remote SDP's are all supported.  Both media descriptions and
+ * descriptions involving data channels are supported.
  *
  * Each input/output pad is equivalent to a Track in W3 parlance which are
  * added/removed from the bin.  The number of requested sink pads is the number
@@ -60,7 +62,21 @@
  *
  * On the receiving side, RTPTransceiver's are created in response to setting
  * a remote description.  Output pads for the receiving streams in the set
- * description are also created.
+ * description are also created when data is received.
+ *
+ * A TransportStream is created when needed in order to transport the data over
+ * the necessary DTLS/ICE channel to the peer.  The exact configuration depends
+ * on the negotiated SDP's between the peers based on the bundle and rtcp
+ * configuration.  Some cases are outlined below for a simple single
+ * audio/video/data session:
+ *
+ * - max-bundle (requires rtcp-muxing) uses a single transport for all
+ *   media/data transported.  Renegotiation involves adding/removing the
+ *   necessary streams to the existing transports.
+ * - max-compat without rtcp-mux involves two TransportStream per media stream
+ *   to transport the rtp and the rtcp packets and a single TransportStream for
+ *   all data channels.  Each stream change involves modifying the associated
+ *   TransportStream/s as necessary.
  */
 
 /*
@@ -68,9 +84,8 @@
  * assert sending payload type matches the stream
  * reconfiguration (of anything)
  * LS groups
- * bundling
+ * balanced bundle policy
  * setting custom DTLS certificates
- * data channel
  *
  * seperate session id's from mlineindex properly
  * how to deal with replacing a input/output track/stream
@@ -81,10 +96,111 @@ static void _update_need_negotiation (GstWebRTCBin * webrtc);
 #define GST_CAT_DEFAULT gst_webrtc_bin_debug
 GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
 
-GQuark
-gst_webrtc_bin_error_quark (void)
+enum
+{
+  PROP_PAD_TRANSCEIVER = 1,
+};
+
+static gboolean
+_have_nice_elements (GstWebRTCBin * webrtc)
+{
+  GstPluginFeature *feature;
+
+  feature = gst_registry_lookup_feature (gst_registry_get (), "nicesrc");
+  if (feature) {
+    gst_object_unref (feature);
+  } else {
+    GST_ELEMENT_ERROR (webrtc, CORE, MISSING_PLUGIN, NULL,
+        ("%s", "libnice elements are not available"));
+    return FALSE;
+  }
+
+  feature = gst_registry_lookup_feature (gst_registry_get (), "nicesink");
+  if (feature) {
+    gst_object_unref (feature);
+  } else {
+    GST_ELEMENT_ERROR (webrtc, CORE, MISSING_PLUGIN, NULL,
+        ("%s", "libnice elements are not available"));
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+_have_sctp_elements (GstWebRTCBin * webrtc)
+{
+  GstPluginFeature *feature;
+
+
+  printf("%s, %d\n", __func__, __LINE__);
+
+  feature = gst_registry_lookup_feature (gst_registry_get (), "sctpdec");
+  if (feature) {
+    gst_object_unref (feature);
+  } else {
+    GST_ELEMENT_ERROR (webrtc, CORE, MISSING_PLUGIN, NULL,
+        ("%s", "sctp elements are not available"));
+
+    printf("%s, %d\n", __func__, __LINE__);
+
+    return FALSE;
+  }
+
+  feature = gst_registry_lookup_feature (gst_registry_get (), "sctpenc");
+  if (feature) {
+    gst_object_unref (feature);
+  } else {
+    GST_ELEMENT_ERROR (webrtc, CORE, MISSING_PLUGIN, NULL,
+        ("%s", "sctp elements are not available"));
+
+    printf("%s, %d\n", __func__, __LINE__);
+
+    return FALSE;
+  }
+
+
+  printf("%s, %d\n", __func__, __LINE__);
+
+  return TRUE;
+}
+
+static gboolean
+_have_dtls_elements (GstWebRTCBin * webrtc)
 {
-  return g_quark_from_static_string ("gst-webrtc-bin-error-quark");
+  GstPluginFeature *feature;
+
+
+  printf("%s, %d\n", __func__, __LINE__);
+
+  feature = gst_registry_lookup_feature (gst_registry_get (), "dtlsdec");
+  if (feature) {
+    gst_object_unref (feature);
+  } else {
+    GST_ELEMENT_ERROR (webrtc, CORE, MISSING_PLUGIN, NULL,
+        ("%s", "dtls elements are not available"));
+
+    printf("%s, %d\n", __func__, __LINE__);
+
+    return FALSE;
+  }
+
+  feature = gst_registry_lookup_feature (gst_registry_get (), "dtlsenc");
+  if (feature) {
+    gst_object_unref (feature);
+  } else {
+    GST_ELEMENT_ERROR (webrtc, CORE, MISSING_PLUGIN, NULL,
+        ("%s", "dtls elements are not available"));
+
+    printf("%s, %d\n", __func__, __LINE__);
+
+    return FALSE;
+  }
+
+  printf("%s, %d\n", __func__, __LINE__);
+
+
+  return TRUE;
 }
 
 G_DEFINE_TYPE (GstWebRTCBinPad, gst_webrtc_bin_pad, GST_TYPE_GHOST_PAD);
@@ -104,7 +220,12 @@ static void
 gst_webrtc_bin_pad_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * pspec)
 {
+  GstWebRTCBinPad *pad = GST_WEBRTC_BIN_PAD (object);
+
   switch (prop_id) {
+    case PROP_PAD_TRANSCEIVER:
+      g_value_set_object (value, pad->trans);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -135,59 +256,41 @@ gst_webrtc_bin_pad_class_init (GstWebRTCBinPadClass * klass)
   gobject_class->get_property = gst_webrtc_bin_pad_get_property;
   gobject_class->set_property = gst_webrtc_bin_pad_set_property;
   gobject_class->finalize = gst_webrtc_bin_pad_finalize;
-}
-
-static GstCaps *
-_transport_stream_get_caps_for_pt (TransportStream * stream, guint pt)
-{
-  guint i, len;
-
-  len = stream->ptmap->len;
-  for (i = 0; i < len; i++) {
-    PtMapItem *item = &g_array_index (stream->ptmap, PtMapItem, i);
-    if (item->pt == pt)
-      return item->caps;
-  }
-  return NULL;
-}
-
-static gint
-_transport_stream_get_pt (TransportStream * stream, const gchar * encoding_name)
-{
-  guint i;
-  gint ret = 0;
-
-  for (i = 0; i < stream->ptmap->len; i++) {
-    PtMapItem *item = &g_array_index (stream->ptmap, PtMapItem, i);
-    if (!gst_caps_is_empty (item->caps)) {
-      GstStructure *s = gst_caps_get_structure (item->caps, 0);
-      if (!g_strcmp0 (gst_structure_get_string (s, "encoding-name"),
-              encoding_name)) {
-        ret = item->pt;
-        break;
-      }
-    }
-  }
 
-  return ret;
+  g_object_class_install_property (gobject_class,
+      PROP_PAD_TRANSCEIVER,
+      g_param_spec_object ("transceiver", "Transceiver",
+          "Transceiver associated with this pad",
+          GST_TYPE_WEBRTC_RTP_TRANSCEIVER,
+          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 }
 
 static gboolean
 gst_webrtcbin_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
 {
   GstWebRTCBinPad *wpad = GST_WEBRTC_BIN_PAD (pad);
+  GstWebRTCBin *webrtc = GST_WEBRTC_BIN (parent);
+  gboolean check_negotiation = FALSE;
 
   if (GST_EVENT_TYPE (event) == GST_EVENT_CAPS) {
     GstCaps *caps;
-    gboolean do_update;
 
     gst_event_parse_caps (event, &caps);
-    do_update = (!wpad->received_caps
+    check_negotiation = (!wpad->received_caps
         || gst_caps_is_equal (wpad->received_caps, caps));
     gst_caps_replace (&wpad->received_caps, caps);
 
-    if (do_update)
-      _update_need_negotiation (GST_WEBRTC_BIN (parent));
+    GST_DEBUG_OBJECT (parent,
+        "On %" GST_PTR_FORMAT " checking negotiation? %u, caps %"
+        GST_PTR_FORMAT, pad, check_negotiation, caps);
+  } else if (GST_EVENT_TYPE (event) == GST_EVENT_EOS) {
+    check_negotiation = TRUE;
+  }
+
+  if (check_negotiation) {
+    PC_LOCK (webrtc);
+    _update_need_negotiation (webrtc);
+    PC_UNLOCK (webrtc);
   }
 
   return gst_pad_event_default (pad, parent, event);
@@ -219,8 +322,10 @@ gst_webrtc_bin_pad_new (const gchar * name, GstPadDirection direction)
 
 #define gst_webrtc_bin_parent_class parent_class
 G_DEFINE_TYPE_WITH_CODE (GstWebRTCBin, gst_webrtc_bin, GST_TYPE_BIN,
+    G_ADD_PRIVATE (GstWebRTCBin)
     GST_DEBUG_CATEGORY_INIT (gst_webrtc_bin_debug, "webrtcbin", 0,
-        "webrtcbin element"););
+        "webrtcbin element");
+    );
 
 static GstPad *_connect_input_stream (GstWebRTCBin * webrtc,
     GstWebRTCBinPad * pad);
@@ -248,7 +353,11 @@ enum
   ON_NEW_TRANSCEIVER_SIGNAL,
   GET_STATS_SIGNAL,
   ADD_TRANSCEIVER_SIGNAL,
+  GET_TRANSCEIVER_SIGNAL,
   GET_TRANSCEIVERS_SIGNAL,
+  ADD_TURN_SERVER_SIGNAL,
+  CREATE_DATA_CHANNEL_SIGNAL,
+  ON_DATA_CHANNEL_SIGNAL,
   LAST_SIGNAL,
 };
 
@@ -267,34 +376,12 @@ enum
   PROP_PENDING_REMOTE_DESCRIPTION,
   PROP_STUN_SERVER,
   PROP_TURN_SERVER,
+  PROP_BUNDLE_POLICY,
+  PROP_ICE_TRANSPORT_POLICY,
 };
 
 static guint gst_webrtc_bin_signals[LAST_SIGNAL] = { 0 };
 
-static GstWebRTCDTLSTransport *
-_transceiver_get_transport (GstWebRTCRTPTransceiver * trans)
-{
-  if (trans->sender) {
-    return trans->sender->transport;
-  } else if (trans->receiver) {
-    return trans->receiver->transport;
-  }
-
-  return NULL;
-}
-
-static GstWebRTCDTLSTransport *
-_transceiver_get_rtcp_transport (GstWebRTCRTPTransceiver * trans)
-{
-  if (trans->sender) {
-    return trans->sender->rtcp_transport;
-  } else if (trans->receiver) {
-    return trans->receiver->rtcp_transport;
-  }
-
-  return NULL;
-}
-
 typedef struct
 {
   guint session_id;
@@ -470,6 +557,47 @@ _find_pad (GstWebRTCBin * webrtc, gconstpointer data, FindPadFunc func)
   return NULL;
 }
 
+typedef gboolean (*FindDataChannelFunc) (GstWebRTCDataChannel * p1,
+    gconstpointer data);
+
+static GstWebRTCDataChannel *
+_find_data_channel (GstWebRTCBin * webrtc, gconstpointer data,
+    FindDataChannelFunc func)
+{
+  int i;
+
+  for (i = 0; i < webrtc->priv->data_channels->len; i++) {
+    GstWebRTCDataChannel *channel =
+        g_array_index (webrtc->priv->data_channels, GstWebRTCDataChannel *,
+        i);
+
+    if (func (channel, data))
+      return channel;
+  }
+
+  return NULL;
+}
+
+static gboolean
+data_channel_match_for_id (GstWebRTCDataChannel * channel, gint * id)
+{
+  return channel->id == *id;
+}
+
+static GstWebRTCDataChannel *
+_find_data_channel_for_id (GstWebRTCBin * webrtc, gint id)
+{
+  GstWebRTCDataChannel *channel;
+
+  channel = _find_data_channel (webrtc, &id,
+      (FindDataChannelFunc) data_channel_match_for_id);
+
+  GST_TRACE_OBJECT (webrtc,
+      "Found data channel %" GST_PTR_FORMAT " for id %i", channel, id);
+
+  return channel;
+}
+
 static void
 _add_pad_to_list (GstWebRTCBin * webrtc, GstWebRTCBinPad * pad)
 {
@@ -701,7 +829,7 @@ _collate_ice_connection_states (GstWebRTCBin * webrtc)
 
     g_object_get (stream, "rtcp-mux", &rtcp_mux, NULL);
 
-    transport = _transceiver_get_transport (rtp_trans)->transport;
+    transport = webrtc_transceiver_get_dtls_transport (rtp_trans)->transport;
 
     /* get transport state */
     g_object_get (transport, "state", &ice_state, NULL);
@@ -709,7 +837,8 @@ _collate_ice_connection_states (GstWebRTCBin * webrtc)
     if (ice_state != STATE (CLOSED))
       all_closed = FALSE;
 
-    rtcp_transport = _transceiver_get_rtcp_transport (rtp_trans)->transport;
+    rtcp_transport =
+        webrtc_transceiver_get_rtcp_dtls_transport (rtp_trans)->transport;
 
     if (!rtcp_mux && rtcp_transport && transport != rtcp_transport) {
       g_object_get (rtcp_transport, "state", &ice_state, NULL);
@@ -795,7 +924,7 @@ _collate_ice_gathering_states (GstWebRTCBin * webrtc)
 
     g_object_get (stream, "rtcp-mux", &rtcp_mux, NULL);
 
-    transport = _transceiver_get_transport (rtp_trans)->transport;
+    transport = webrtc_transceiver_get_dtls_transport (rtp_trans)->transport;
 
     /* get gathering state */
     g_object_get (transport, "gathering-state", &ice_state, NULL);
@@ -803,7 +932,8 @@ _collate_ice_gathering_states (GstWebRTCBin * webrtc)
     if (ice_state != STATE (COMPLETE))
       all_completed = FALSE;
 
-    rtcp_transport = _transceiver_get_rtcp_transport (rtp_trans)->transport;
+    rtcp_transport =
+        webrtc_transceiver_get_rtcp_dtls_transport (rtp_trans)->transport;
 
     if (!rtcp_mux && rtcp_transport && rtcp_transport != transport) {
       g_object_get (rtcp_transport, "gathering-state", &ice_state, NULL);
@@ -862,7 +992,7 @@ _collate_peer_connection_states (GstWebRTCBin * webrtc)
       continue;
 
     g_object_get (stream, "rtcp-mux", &rtcp_mux, NULL);
-    transport = _transceiver_get_transport (rtp_trans);
+    transport = webrtc_transceiver_get_dtls_transport (rtp_trans);
 
     /* get transport state */
     g_object_get (transport, "state", &dtls_state, NULL);
@@ -870,7 +1000,7 @@ _collate_peer_connection_states (GstWebRTCBin * webrtc)
     g_object_get (transport->transport, "state", &ice_state, NULL);
     any_ice_state |= (1 << ice_state);
 
-    rtcp_transport = _transceiver_get_rtcp_transport (rtp_trans);
+    rtcp_transport = webrtc_transceiver_get_rtcp_dtls_transport (rtp_trans);
 
     if (!rtcp_mux && rtcp_transport && rtcp_transport != transport) {
       g_object_get (rtcp_transport, "state", &dtls_state, NULL);
@@ -1068,16 +1198,23 @@ _all_sinks_have_caps (GstWebRTCBin * webrtc)
   GST_OBJECT_LOCK (webrtc);
   l = GST_ELEMENT (webrtc)->pads;
   for (; l; l = g_list_next (l)) {
+    GstWebRTCBinPad *wpad;
+
     if (!GST_IS_WEBRTC_BIN_PAD (l->data))
       continue;
-    if (!GST_WEBRTC_BIN_PAD (l->data)->received_caps)
+
+    wpad = GST_WEBRTC_BIN_PAD (l->data);
+    if (GST_PAD_DIRECTION (l->data) == GST_PAD_SINK && !wpad->received_caps
+        && (!wpad->trans || !wpad->trans->stopped)) {
       goto done;
+    }
   }
 
   l = webrtc->priv->pending_pads;
   for (; l; l = g_list_next (l)) {
-    if (!GST_IS_WEBRTC_BIN_PAD (l->data))
+    if (!GST_IS_WEBRTC_BIN_PAD (l->data)) {
       goto done;
+    }
   }
 
   res = TRUE;
@@ -1108,10 +1245,6 @@ _check_if_negotiation_is_needed (GstWebRTCBin * webrtc)
    * FIXME */
   /* FIXME: emit when input caps/format changes? */
 
-  /* If connection has created any RTCDataChannel's, and no m= section has
-   * been negotiated yet for data, return "true". 
-   * FIXME */
-
   if (!webrtc->current_local_description) {
     GST_LOG_OBJECT (webrtc, "no local description set");
     return TRUE;
@@ -1122,6 +1255,18 @@ _check_if_negotiation_is_needed (GstWebRTCBin * webrtc)
     return TRUE;
   }
 
+  /* If connection has created any RTCDataChannel's, and no m= section has
+   * been negotiated yet for data, return "true". */
+  if (webrtc->priv->data_channels->len > 0) {
+    if (_message_get_datachannel_index (webrtc->current_local_description->
+            sdp) >= G_MAXUINT) {
+      GST_LOG_OBJECT (webrtc,
+          "no data channel media section and have %u " "transports",
+          webrtc->priv->data_channels->len);
+      return TRUE;
+    }
+  }
+
   for (i = 0; i < webrtc->priv->transceivers->len; i++) {
     GstWebRTCRTPTransceiver *trans;
 
@@ -1140,9 +1285,9 @@ _check_if_negotiation_is_needed (GstWebRTCBin * webrtc)
       const GstSDPMedia *media;
       GstWebRTCRTPTransceiverDirection local_dir, remote_dir;
 
-      if (trans->mline == -1) {
-        GST_LOG_OBJECT (webrtc, "unassociated transceiver %i %" GST_PTR_FORMAT,
-            i, trans);
+      if (trans->mline == -1 || trans->mid == NULL) {
+        GST_LOG_OBJECT (webrtc, "unassociated transceiver %i %" GST_PTR_FORMAT
+            " mid %s", i, trans, trans->mid);
         return TRUE;
       }
       /* internal inconsistency */
@@ -1172,8 +1317,26 @@ _check_if_negotiation_is_needed (GstWebRTCBin * webrtc)
          * nor answer matches t's direction, return "true". */
 
         if (local_dir != trans->direction && remote_dir != trans->direction) {
-          GST_LOG_OBJECT (webrtc,
-              "transceiver direction doesn't match description");
+          gchar *local_str, *remote_str, *dir_str;
+
+          local_str =
+              _enum_value_to_string (GST_TYPE_WEBRTC_RTP_TRANSCEIVER_DIRECTION,
+              local_dir);
+          remote_str =
+              _enum_value_to_string (GST_TYPE_WEBRTC_RTP_TRANSCEIVER_DIRECTION,
+              remote_dir);
+          dir_str =
+              _enum_value_to_string (GST_TYPE_WEBRTC_RTP_TRANSCEIVER_DIRECTION,
+              trans->direction);
+
+          GST_LOG_OBJECT (webrtc, "transceiver direction (%s) doesn't match "
+              "description (local %s remote %s)", dir_str, local_str,
+              remote_str);
+
+          g_free (dir_str);
+          g_free (local_str);
+          g_free (remote_str);
+
           return TRUE;
         }
       } else if (webrtc->current_local_description->type ==
@@ -1189,8 +1352,30 @@ _check_if_negotiation_is_needed (GstWebRTCBin * webrtc)
         intersect_dir = _intersect_answer_directions (remote_dir, local_dir);
 
         if (intersect_dir != trans->direction) {
-          GST_LOG_OBJECT (webrtc,
-              "transceiver direction doesn't match description");
+          gchar *local_str, *remote_str, *inter_str, *dir_str;
+
+          local_str =
+              _enum_value_to_string (GST_TYPE_WEBRTC_RTP_TRANSCEIVER_DIRECTION,
+              local_dir);
+          remote_str =
+              _enum_value_to_string (GST_TYPE_WEBRTC_RTP_TRANSCEIVER_DIRECTION,
+              remote_dir);
+          dir_str =
+              _enum_value_to_string (GST_TYPE_WEBRTC_RTP_TRANSCEIVER_DIRECTION,
+              trans->direction);
+          inter_str =
+              _enum_value_to_string (GST_TYPE_WEBRTC_RTP_TRANSCEIVER_DIRECTION,
+              intersect_dir);
+
+          GST_LOG_OBJECT (webrtc, "transceiver direction (%s) doesn't match "
+              "description intersected direction %s (local %s remote %s)",
+              dir_str, local_str, inter_str, remote_str);
+
+          g_free (dir_str);
+          g_free (local_str);
+          g_free (remote_str);
+          g_free (inter_str);
+
           return TRUE;
         }
       }
@@ -1243,21 +1428,32 @@ _update_need_negotiation (GstWebRTCBin * webrtc)
 }
 
 static GstCaps *
-_find_codec_preferences (GstWebRTCBin * webrtc, GstWebRTCRTPTransceiver * trans,
-    GstPadDirection direction, guint media_idx)
+_find_codec_preferences (GstWebRTCBin * webrtc,
+    GstWebRTCRTPTransceiver * rtp_trans, GstPadDirection direction,
+    guint media_idx)
 {
+  WebRTCTransceiver *trans = (WebRTCTransceiver *) rtp_trans;
   GstCaps *ret = NULL;
 
   GST_LOG_OBJECT (webrtc, "retreiving codec preferences from %" GST_PTR_FORMAT,
       trans);
 
-  if (trans && trans->codec_preferences) {
+  if (rtp_trans && rtp_trans->codec_preferences) {
     GST_LOG_OBJECT (webrtc, "Using codec preferences: %" GST_PTR_FORMAT,
-        trans->codec_preferences);
-    ret = gst_caps_ref (trans->codec_preferences);
+        rtp_trans->codec_preferences);
+    ret = gst_caps_ref (rtp_trans->codec_preferences);
   } else {
-    GstWebRTCBinPad *pad = _find_pad_for_mline (webrtc, direction, media_idx);
-    if (pad) {
+    GstWebRTCBinPad *pad = NULL;
+
+    /* try to find a pad */
+    if (!trans
+        || !(pad = _find_pad_for_transceiver (webrtc, direction, rtp_trans)))
+      pad = _find_pad_for_mline (webrtc, direction, media_idx);
+
+    if (!pad) {
+      if (trans && trans->last_configured_caps)
+        ret = gst_caps_ref (trans->last_configured_caps);
+    } else {
       GstCaps *caps = NULL;
 
       if (pad->received_caps) {
@@ -1270,12 +1466,20 @@ _find_codec_preferences (GstWebRTCBin * webrtc, GstWebRTCRTPTransceiver * trans,
           GST_LOG_OBJECT (webrtc, "Using peer query caps: %" GST_PTR_FORMAT,
               caps);
       }
-      if (caps)
+      if (caps) {
+        if (trans)
+          gst_caps_replace (&trans->last_configured_caps, caps);
+
         ret = caps;
+      }
+
       gst_object_unref (pad);
     }
   }
 
+  if (!ret)
+    GST_DEBUG_OBJECT (trans, "Could not find caps for mline %u", media_idx);
+
   return ret;
 }
 
@@ -1361,7 +1565,6 @@ _create_transport_channel (GstWebRTCBin * webrtc, guint session_id)
 {
   GstWebRTCDTLSTransport *transport;
   TransportStream *ret;
-  gchar *pad_name;
 
   /* FIXME: how to parametrize the sender and the receiver */
   ret = transport_stream_new (webrtc, session_id);
@@ -1385,25 +1588,38 @@ _create_transport_channel (GstWebRTCBin * webrtc, guint session_id)
         G_CALLBACK (_on_dtls_transport_notify_state), webrtc);
   }
 
-  gst_bin_add (GST_BIN (webrtc), GST_ELEMENT (ret->send_bin));
-  gst_bin_add (GST_BIN (webrtc), GST_ELEMENT (ret->receive_bin));
+  GST_TRACE_OBJECT (webrtc,
+      "Create transport %" GST_PTR_FORMAT " for session %u", ret, session_id);
 
-  pad_name = g_strdup_printf ("recv_rtcp_sink_%u", ret->session_id);
-  if (!gst_element_link_pads (GST_ELEMENT (ret->receive_bin), "rtcp_src",
-          GST_ELEMENT (webrtc->rtpbin), pad_name))
-    g_warn_if_reached ();
-  g_free (pad_name);
+  return ret;
+}
 
-  pad_name = g_strdup_printf ("send_rtcp_src_%u", ret->session_id);
-  if (!gst_element_link_pads (GST_ELEMENT (webrtc->rtpbin), pad_name,
-          GST_ELEMENT (ret->send_bin), "rtcp_sink"))
-    g_warn_if_reached ();
-  g_free (pad_name);
+static TransportStream *
+_get_or_create_rtp_transport_channel (GstWebRTCBin * webrtc, guint session_id)
+{
+  TransportStream *ret;
+  gchar *pad_name;
 
-  g_array_append_val (webrtc->priv->transports, ret);
+  ret = _find_transport_for_session (webrtc, session_id);
 
-  GST_TRACE_OBJECT (webrtc,
-      "Create transport %" GST_PTR_FORMAT " for session %u", ret, session_id);
+  if (!ret) {
+    ret = _create_transport_channel (webrtc, session_id);
+    gst_bin_add (GST_BIN (webrtc), GST_ELEMENT (ret->send_bin));
+    gst_bin_add (GST_BIN (webrtc), GST_ELEMENT (ret->receive_bin));
+    g_array_append_val (webrtc->priv->transports, ret);
+
+    pad_name = g_strdup_printf ("recv_rtcp_sink_%u", ret->session_id);
+    if (!gst_element_link_pads (GST_ELEMENT (ret->receive_bin), "rtcp_src",
+            GST_ELEMENT (webrtc->rtpbin), pad_name))
+      g_warn_if_reached ();
+    g_free (pad_name);
+
+    pad_name = g_strdup_printf ("send_rtcp_src_%u", ret->session_id);
+    if (!gst_element_link_pads (GST_ELEMENT (webrtc->rtpbin), pad_name,
+            GST_ELEMENT (ret->send_bin), "rtcp_sink"))
+      g_warn_if_reached ();
+    g_free (pad_name);
+  }
 
   gst_element_sync_state_with_parent (GST_ELEMENT (ret->send_bin));
   gst_element_sync_state_with_parent (GST_ELEMENT (ret->receive_bin));
@@ -1411,81 +1627,270 @@ _create_transport_channel (GstWebRTCBin * webrtc, guint session_id)
   return ret;
 }
 
-static guint
-g_array_find_uint (GArray * array, guint val)
+/* this is called from the webrtc thread with the pc lock held */
+static void
+_on_data_channel_ready_state (GstWebRTCDataChannel * channel,
+    GParamSpec * pspec, GstWebRTCBin * webrtc)
 {
+  GstWebRTCDataChannelState ready_state;
   guint i;
 
-  for (i = 0; i < array->len; i++) {
-    if (g_array_index (array, guint, i) == val)
-      return i;
-  }
+  g_object_get (channel, "ready-state", &ready_state, NULL);
 
-  return G_MAXUINT;
-}
+  if (ready_state == GST_WEBRTC_DATA_CHANNEL_STATE_OPEN) {
+    gboolean found = FALSE;
 
-static gboolean
-_pick_available_pt (GArray * reserved_pts, guint * i)
-{
-  gboolean ret = FALSE;
+    for (i = 0; i < webrtc->priv->pending_data_channels->len; i++) {
+      GstWebRTCDataChannel *c;
 
-  for (*i = 96; *i <= 127; (*i)++) {
-    if (g_array_find_uint (reserved_pts, *i) == G_MAXUINT) {
-      g_array_append_val (reserved_pts, *i);
-      ret = TRUE;
-      break;
+      c = g_array_index (webrtc->priv->pending_data_channels,
+          GstWebRTCDataChannel *, i);
+      if (c == channel) {
+        found = TRUE;
+        g_array_remove_index (webrtc->priv->pending_data_channels, i);
+        break;
+      }
+    }
+    if (found == FALSE) {
+      GST_FIXME_OBJECT (webrtc, "Received open for unknown data channel");
+      return;
     }
-  }
 
-  return ret;
+    g_array_append_val (webrtc->priv->data_channels, channel);
+
+    g_signal_emit (webrtc, gst_webrtc_bin_signals[ON_DATA_CHANNEL_SIGNAL], 0,
+        gst_object_ref (channel));
+  }
 }
 
-static gboolean
-_pick_fec_payload_types (GstWebRTCBin * webrtc, WebRTCTransceiver * trans,
-    GArray * reserved_pts, gint clockrate, gint * rtx_target_pt,
-    GstSDPMedia * media)
+static void
+_on_sctpdec_pad_added (GstElement * sctpdec, GstPad * pad,
+    GstWebRTCBin * webrtc)
 {
-  gboolean ret = TRUE;
-
-  if (trans->fec_type == GST_WEBRTC_FEC_TYPE_NONE)
-    goto done;
-
-  if (trans->fec_type == GST_WEBRTC_FEC_TYPE_ULP_RED && clockrate != -1) {
-    guint pt;
-    gchar *str;
+  GstWebRTCDataChannel *channel;
+  guint stream_id;
+  GstPad *sink_pad;
 
-    if (!(ret = _pick_available_pt (reserved_pts, &pt)))
-      goto done;
+  if (sscanf (GST_PAD_NAME (pad), "src_%u", &stream_id) != 1)
+    return;
 
-    /* https://tools.ietf.org/html/rfc5109#section-14.1 */
+  PC_LOCK (webrtc);
+  channel = _find_data_channel_for_id (webrtc, stream_id);
+  if (!channel) {
+    channel = g_object_new (GST_TYPE_WEBRTC_DATA_CHANNEL, NULL);
+    channel->id = stream_id;
+    channel->webrtcbin = webrtc;
 
-    str = g_strdup_printf ("%u", pt);
-    gst_sdp_media_add_format (media, str);
-    g_free (str);
-    str = g_strdup_printf ("%u red/%d", pt, clockrate);
-    gst_sdp_media_add_attribute (media, "rtpmap", str);
-    g_free (str);
+    gst_bin_add (GST_BIN (webrtc), channel->appsrc);
+    gst_bin_add (GST_BIN (webrtc), channel->appsink);
 
-    *rtx_target_pt = pt;
+    gst_element_sync_state_with_parent (channel->appsrc);
+    gst_element_sync_state_with_parent (channel->appsink);
 
-    if (!(ret = _pick_available_pt (reserved_pts, &pt)))
-      goto done;
+    gst_webrtc_data_channel_link_to_sctp (channel,
+        webrtc->priv->sctp_transport);
 
-    str = g_strdup_printf ("%u", pt);
-    gst_sdp_media_add_format (media, str);
-    g_free (str);
-    str = g_strdup_printf ("%u ulpfec/%d", pt, clockrate);
-    gst_sdp_media_add_attribute (media, "rtpmap", str);
-    g_free (str);
+    g_array_append_val (webrtc->priv->pending_data_channels, channel);
   }
 
-done:
-  return ret;
+  g_signal_connect (channel, "notify::ready-state",
+      G_CALLBACK (_on_data_channel_ready_state), webrtc);
+
+  sink_pad = gst_element_get_static_pad (channel->appsink, "sink");
+  if (gst_pad_link (pad, sink_pad) != GST_PAD_LINK_OK)
+    GST_WARNING_OBJECT (channel, "Failed to link sctp pad %s with channel %"
+        GST_PTR_FORMAT, GST_PAD_NAME (pad), channel);
+  gst_object_unref (sink_pad);
+  PC_UNLOCK (webrtc);
 }
 
-static gboolean
-_pick_rtx_payload_types (GstWebRTCBin * webrtc, WebRTCTransceiver * trans,
-    GArray * reserved_pts, gint clockrate, gint target_pt, guint target_ssrc,
+static void
+_on_sctp_state_notify (GstWebRTCSCTPTransport * sctp, GParamSpec * pspec,
+    GstWebRTCBin * webrtc)
+{
+  GstWebRTCSCTPTransportState state;
+
+  g_object_get (sctp, "state", &state, NULL);
+
+  if (state == GST_WEBRTC_SCTP_TRANSPORT_STATE_CONNECTED) {
+    int i;
+
+    PC_LOCK (webrtc);
+    GST_DEBUG_OBJECT (webrtc, "SCTP association established");
+
+    for (i = 0; i < webrtc->priv->data_channels->len; i++) {
+      GstWebRTCDataChannel *channel;
+
+      channel =
+          g_array_index (webrtc->priv->data_channels, GstWebRTCDataChannel *,
+          i);
+
+      gst_webrtc_data_channel_link_to_sctp (channel,
+          webrtc->priv->sctp_transport);
+
+      if (!channel->negotiated && !channel->opened)
+        gst_webrtc_data_channel_start_negotiation (channel);
+    }
+    PC_UNLOCK (webrtc);
+  }
+}
+
+static TransportStream *
+_get_or_create_data_channel_transports (GstWebRTCBin * webrtc, guint session_id)
+{
+  if (!webrtc->priv->data_channel_transport) {
+    TransportStream *stream;
+    GstWebRTCSCTPTransport *sctp_transport;
+    int i;
+
+    stream = _find_transport_for_session (webrtc, session_id);
+
+    if (!stream) {
+      stream = _create_transport_channel (webrtc, session_id);
+      gst_bin_add (GST_BIN (webrtc), GST_ELEMENT (stream->send_bin));
+      gst_bin_add (GST_BIN (webrtc), GST_ELEMENT (stream->receive_bin));
+      g_array_append_val (webrtc->priv->transports, stream);
+    }
+
+    webrtc->priv->data_channel_transport = stream;
+
+    g_object_set (stream, "rtcp-mux", TRUE, NULL);
+
+    if (!(sctp_transport = webrtc->priv->sctp_transport)) {
+      sctp_transport = gst_webrtc_sctp_transport_new ();
+      sctp_transport->transport =
+          g_object_ref (webrtc->priv->data_channel_transport->transport);
+      sctp_transport->webrtcbin = webrtc;
+
+      gst_bin_add (GST_BIN (webrtc), sctp_transport->sctpdec);
+      gst_bin_add (GST_BIN (webrtc), sctp_transport->sctpenc);
+    }
+
+    g_signal_connect (sctp_transport->sctpdec, "pad-added",
+        G_CALLBACK (_on_sctpdec_pad_added), webrtc);
+    g_signal_connect (sctp_transport, "notify::state",
+        G_CALLBACK (_on_sctp_state_notify), webrtc);
+
+    if (!gst_element_link_pads (GST_ELEMENT (stream->receive_bin), "data_src",
+            GST_ELEMENT (sctp_transport->sctpdec), "sink"))
+      g_warn_if_reached ();
+
+    if (!gst_element_link_pads (GST_ELEMENT (sctp_transport->sctpenc), "src",
+            GST_ELEMENT (stream->send_bin), "data_sink"))
+      g_warn_if_reached ();
+
+    for (i = 0; i < webrtc->priv->data_channels->len; i++) {
+      GstWebRTCDataChannel *channel;
+
+      channel =
+          g_array_index (webrtc->priv->data_channels, GstWebRTCDataChannel *,
+          i);
+
+      gst_webrtc_data_channel_link_to_sctp (channel,
+          webrtc->priv->sctp_transport);
+    }
+
+    gst_element_sync_state_with_parent (GST_ELEMENT (stream->send_bin));
+    gst_element_sync_state_with_parent (GST_ELEMENT (stream->receive_bin));
+
+    if (!webrtc->priv->sctp_transport) {
+      gst_element_sync_state_with_parent (GST_ELEMENT
+          (sctp_transport->sctpdec));
+      gst_element_sync_state_with_parent (GST_ELEMENT
+          (sctp_transport->sctpenc));
+    }
+
+    webrtc->priv->sctp_transport = sctp_transport;
+  }
+
+  return webrtc->priv->data_channel_transport;
+}
+
+static TransportStream *
+_get_or_create_transport_stream (GstWebRTCBin * webrtc, guint session_id,
+    gboolean is_datachannel)
+{
+  if (is_datachannel)
+    return _get_or_create_data_channel_transports (webrtc, session_id);
+  else
+    return _get_or_create_rtp_transport_channel (webrtc, session_id);
+}
+
+static guint
+g_array_find_uint (GArray * array, guint val)
+{
+  guint i;
+
+  for (i = 0; i < array->len; i++) {
+    if (g_array_index (array, guint, i) == val)
+      return i;
+  }
+
+  return G_MAXUINT;
+}
+
+static gboolean
+_pick_available_pt (GArray * reserved_pts, guint * i)
+{
+  gboolean ret = FALSE;
+
+  for (*i = 96; *i <= 127; (*i)++) {
+    if (g_array_find_uint (reserved_pts, *i) == G_MAXUINT) {
+      g_array_append_val (reserved_pts, *i);
+      ret = TRUE;
+      break;
+    }
+  }
+
+  return ret;
+}
+
+static gboolean
+_pick_fec_payload_types (GstWebRTCBin * webrtc, WebRTCTransceiver * trans,
+    GArray * reserved_pts, gint clockrate, gint * rtx_target_pt,
+    GstSDPMedia * media)
+{
+  gboolean ret = TRUE;
+
+  if (trans->fec_type == GST_WEBRTC_FEC_TYPE_NONE)
+    goto done;
+
+  if (trans->fec_type == GST_WEBRTC_FEC_TYPE_ULP_RED && clockrate != -1) {
+    guint pt;
+    gchar *str;
+
+    if (!(ret = _pick_available_pt (reserved_pts, &pt)))
+      goto done;
+
+    /* https://tools.ietf.org/html/rfc5109#section-14.1 */
+
+    str = g_strdup_printf ("%u", pt);
+    gst_sdp_media_add_format (media, str);
+    g_free (str);
+    str = g_strdup_printf ("%u red/%d", pt, clockrate);
+    gst_sdp_media_add_attribute (media, "rtpmap", str);
+    g_free (str);
+
+    *rtx_target_pt = pt;
+
+    if (!(ret = _pick_available_pt (reserved_pts, &pt)))
+      goto done;
+
+    str = g_strdup_printf ("%u", pt);
+    gst_sdp_media_add_format (media, str);
+    g_free (str);
+    str = g_strdup_printf ("%u ulpfec/%d", pt, clockrate);
+    gst_sdp_media_add_attribute (media, "rtpmap", str);
+    g_free (str);
+  }
+
+done:
+  return ret;
+}
+
+static gboolean
+_pick_rtx_payload_types (GstWebRTCBin * webrtc, WebRTCTransceiver * trans,
+    GArray * reserved_pts, gint clockrate, gint target_pt, guint target_ssrc,
     GstSDPMedia * media)
 {
   gboolean ret = TRUE;
@@ -1622,10 +2027,32 @@ _media_add_ssrcs (GstSDPMedia * media, GstCaps * caps, GstWebRTCBin * webrtc,
         (GstStructureForeachFunc) _media_add_rtx_ssrc, &data);
 }
 
+static void
+_add_fingerprint_to_media (GstWebRTCDTLSTransport * transport,
+    GstSDPMedia * media)
+{
+  gchar *cert, *fingerprint, *val;
+
+  g_object_get (transport, "certificate", &cert, NULL);
+
+  fingerprint =
+      _generate_fingerprint_from_certificate (cert, G_CHECKSUM_SHA256);
+  g_free (cert);
+  val =
+      g_strdup_printf ("%s %s",
+      _g_checksum_to_webrtc_string (G_CHECKSUM_SHA256), fingerprint);
+  g_free (fingerprint);
+
+  gst_sdp_media_add_attribute (media, "fingerprint", val);
+  g_free (val);
+}
+
 /* based off https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-18#section-5.2.1 */
 static gboolean
 sdp_media_from_transceiver (GstWebRTCBin * webrtc, GstSDPMedia * media,
-    GstWebRTCRTPTransceiver * trans, GstWebRTCSDPType type, guint media_idx)
+    GstWebRTCRTPTransceiver * trans, GstWebRTCSDPType type, guint media_idx,
+    GString * bundled_mids, guint bundle_idx, gchar * bundle_ufrag,
+    gchar * bundle_pwd, GArray * reserved_pts)
 {
   /* TODO:
    * rtp header extensions
@@ -1637,39 +2064,74 @@ sdp_media_from_transceiver (GstWebRTCBin * webrtc, GstSDPMedia * media,
    * dtls fingerprints
    * multiple dtls fingerprints https://tools.ietf.org/html/draft-ietf-mmusic-4572-update-05
    */
-  gchar *direction, *sdp_mid;
+  GstSDPMessage *last_offer = _get_latest_self_generated_sdp (webrtc);
+  gchar *direction, *sdp_mid, *ufrag, *pwd;
+  gboolean bundle_only;
   GstCaps *caps;
   int i;
 
-  /* "An m= section is generated for each RtpTransceiver that has been added
-   * to the Bin, excluding any stopped RtpTransceivers." */
-  if (trans->stopped)
-    return FALSE;
   if (trans->direction == GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_NONE
       || trans->direction == GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_INACTIVE)
     return FALSE;
 
-  gst_sdp_media_set_port_info (media, 9, 0);
+  g_assert (trans->mline == -1 || trans->mline == media_idx);
+
+  bundle_only = bundled_mids && bundle_idx != media_idx
+      && webrtc->bundle_policy == GST_WEBRTC_BUNDLE_POLICY_MAX_BUNDLE;
+
+  /* mandated by JSEP */
+  gst_sdp_media_add_attribute (media, "setup", "actpass");
+
+  /* FIXME: deal with ICE restarts */
+  if (last_offer && trans->mline != -1 && trans->mid) {
+    ufrag = g_strdup (_media_get_ice_ufrag (last_offer, trans->mline));
+    pwd = g_strdup (_media_get_ice_pwd (last_offer, trans->mline));
+    GST_DEBUG_OBJECT (trans, "%u Using previous ice parameters", media_idx);
+  } else {
+    GST_DEBUG_OBJECT (trans,
+        "%u Generating new ice parameters mline %i, mid %s", media_idx,
+        trans->mline, trans->mid);
+    if (webrtc->bundle_policy == GST_WEBRTC_BUNDLE_POLICY_NONE) {
+      _generate_ice_credentials (&ufrag, &pwd);
+    } else {
+      g_assert (bundle_ufrag && bundle_pwd);
+      ufrag = g_strdup (bundle_ufrag);
+      pwd = g_strdup (bundle_pwd);
+    }
+  }
+
+  gst_sdp_media_add_attribute (media, "ice-ufrag", ufrag);
+  gst_sdp_media_add_attribute (media, "ice-pwd", pwd);
+  g_free (ufrag);
+  g_free (pwd);
+
+  gst_sdp_media_set_port_info (media, bundle_only || trans->stopped ? 0 : 9, 0);
   gst_sdp_media_set_proto (media, "UDP/TLS/RTP/SAVPF");
   gst_sdp_media_add_connection (media, "IN", "IP4", "0.0.0.0", 0, 0);
 
+  if (bundle_only) {
+    gst_sdp_media_add_attribute (media, "bundle-only", NULL);
+  }
+
+  /* FIXME: negotiate this */
+  /* FIXME: when bundle_only, these should not be added:
+   * https://tools.ietf.org/html/draft-ietf-mmusic-sdp-bundle-negotiation-52#section-7.1.3
+   * However, this causes incompatibilities with current versions
+   * of the major browsers */
+  gst_sdp_media_add_attribute (media, "rtcp-mux", "");
+  gst_sdp_media_add_attribute (media, "rtcp-rsize", NULL);
+
   direction =
       _enum_value_to_string (GST_TYPE_WEBRTC_RTP_TRANSCEIVER_DIRECTION,
       trans->direction);
   gst_sdp_media_add_attribute (media, direction, "");
   g_free (direction);
-  /* FIXME: negotiate this */
-  gst_sdp_media_add_attribute (media, "rtcp-mux", "");
-  gst_sdp_media_add_attribute (media, "rtcp-rsize", NULL);
 
   if (type == GST_WEBRTC_SDP_TYPE_OFFER) {
     caps = _find_codec_preferences (webrtc, trans, GST_PAD_SINK, media_idx);
     caps =
         _add_supported_attributes_to_caps (webrtc, WEBRTC_TRANSCEIVER (trans),
         caps);
-  } else if (type == GST_WEBRTC_SDP_TYPE_ANSWER) {
-    caps = _find_codec_preferences (webrtc, trans, GST_PAD_SRC, media_idx);
-    /* FIXME: add rtcp-fb paramaters */
   } else {
     g_assert_not_reached ();
   }
@@ -1698,20 +2160,24 @@ sdp_media_from_transceiver (GstWebRTCBin * webrtc, GstSDPMedia * media,
   }
 
   if (type == GST_WEBRTC_SDP_TYPE_OFFER) {
-    GArray *reserved_pts = g_array_new (FALSE, FALSE, sizeof (guint));
     const GstStructure *s = gst_caps_get_structure (caps, 0);
     gint clockrate = -1;
     gint rtx_target_pt;
     gint original_rtx_target_pt;        /* Workaround chrome bug: https://bugs.chromium.org/p/webrtc/issues/detail?id=6196 */
-    guint rtx_target_ssrc;
+    guint rtx_target_ssrc = -1;
 
-    if (gst_structure_get_int (s, "payload", &rtx_target_pt))
+    if (gst_structure_get_int (s, "payload", &rtx_target_pt) &&
+        webrtc->bundle_policy == GST_WEBRTC_BUNDLE_POLICY_NONE)
       g_array_append_val (reserved_pts, rtx_target_pt);
 
     original_rtx_target_pt = rtx_target_pt;
 
-    gst_structure_get_int (s, "clock-rate", &clockrate);
-    gst_structure_get_uint (s, "ssrc", &rtx_target_ssrc);
+    if (!gst_structure_get_int (s, "clock-rate", &clockrate))
+      GST_WARNING_OBJECT (webrtc,
+          "Caps %" GST_PTR_FORMAT " are missing clock-rate", caps);
+    if (!gst_structure_get_uint (s, "ssrc", &rtx_target_ssrc))
+      GST_WARNING_OBJECT (webrtc, "Caps %" GST_PTR_FORMAT " are missing ssrc",
+          caps);
 
     _pick_fec_payload_types (webrtc, WEBRTC_TRANSCEIVER (trans), reserved_pts,
         clockrate, &rtx_target_pt, media);
@@ -1720,41 +2186,43 @@ sdp_media_from_transceiver (GstWebRTCBin * webrtc, GstSDPMedia * media,
     if (original_rtx_target_pt != rtx_target_pt)
       _pick_rtx_payload_types (webrtc, WEBRTC_TRANSCEIVER (trans), reserved_pts,
           clockrate, original_rtx_target_pt, rtx_target_ssrc, media);
-    g_array_free (reserved_pts, TRUE);
   }
 
   _media_add_ssrcs (media, caps, webrtc, WEBRTC_TRANSCEIVER (trans));
 
   /* Some identifier; we also add the media name to it so it's identifiable */
-  sdp_mid = g_strdup_printf ("%s%u", gst_sdp_media_get_media (media),
-      webrtc->priv->media_counter++);
-  gst_sdp_media_add_attribute (media, "mid", sdp_mid);
-  g_free (sdp_mid);
+  if (trans->mid) {
+    gst_sdp_media_add_attribute (media, "mid", trans->mid);
+  } else {
+    sdp_mid = g_strdup_printf ("%s%u", gst_sdp_media_get_media (media),
+        webrtc->priv->media_counter++);
+    gst_sdp_media_add_attribute (media, "mid", sdp_mid);
+    g_free (sdp_mid);
+  }
 
-  if (trans->sender) {
-    gchar *cert, *fingerprint, *val;
+  /* TODO:
+   * - add a=candidate lines for gathered candidates
+   */
 
+  if (trans->sender) {
     if (!trans->sender->transport) {
       TransportStream *item;
-      /* FIXME: bundle */
-      item = _find_transport_for_session (webrtc, media_idx);
-      if (!item)
-        item = _create_transport_channel (webrtc, media_idx);
+
+      item =
+          _get_or_create_transport_stream (webrtc,
+          bundled_mids ? bundle_idx : media_idx, FALSE);
+
       webrtc_transceiver_set_transport (WEBRTC_TRANSCEIVER (trans), item);
     }
 
-    g_object_get (trans->sender->transport, "certificate", &cert, NULL);
+    _add_fingerprint_to_media (trans->sender->transport, media);
+  }
 
-    fingerprint =
-        _generate_fingerprint_from_certificate (cert, G_CHECKSUM_SHA256);
-    g_free (cert);
-    val =
-        g_strdup_printf ("%s %s",
-        _g_checksum_to_webrtc_string (G_CHECKSUM_SHA256), fingerprint);
-    g_free (fingerprint);
+  if (bundled_mids) {
+    const gchar *mid = gst_sdp_media_get_attribute_val (media, "mid");
 
-    gst_sdp_media_add_attribute (media, "fingerprint", val);
-    g_free (val);
+    g_assert (mid);
+    g_string_append_printf (bundled_mids, " %s", mid);
   }
 
   gst_caps_unref (caps);
@@ -1762,64 +2230,336 @@ sdp_media_from_transceiver (GstWebRTCBin * webrtc, GstSDPMedia * media,
   return TRUE;
 }
 
+static void
+gather_pad_pt (GstWebRTCBinPad * pad, GArray * reserved_pts)
+{
+  if (pad->received_caps) {
+    GstStructure *s = gst_caps_get_structure (pad->received_caps, 0);
+    gint pt;
+
+    if (gst_structure_get_int (s, "payload", &pt)) {
+      g_array_append_val (reserved_pts, pt);
+    }
+  }
+}
+
+static GArray *
+gather_reserved_pts (GstWebRTCBin * webrtc)
+{
+  GstElement *element = GST_ELEMENT (webrtc);
+  GArray *reserved_pts = g_array_new (FALSE, FALSE, sizeof (guint));
+
+  GST_OBJECT_LOCK (webrtc);
+  g_list_foreach (element->sinkpads, (GFunc) gather_pad_pt, reserved_pts);
+  g_list_foreach (webrtc->priv->pending_pads, (GFunc) gather_pad_pt,
+      reserved_pts);
+  GST_OBJECT_UNLOCK (webrtc);
+
+  return reserved_pts;
+}
+
+static gboolean
+_add_data_channel_offer (GstWebRTCBin * webrtc, GstSDPMessage * msg,
+    GstSDPMedia * media, GString * bundled_mids, guint bundle_idx,
+    gchar * bundle_ufrag, gchar * bundle_pwd)
+{
+  GstSDPMessage *last_offer = _get_latest_self_generated_sdp (webrtc);
+  gchar *ufrag, *pwd, *sdp_mid;
+  gboolean bundle_only = bundled_mids
+      && webrtc->bundle_policy == GST_WEBRTC_BUNDLE_POLICY_MAX_BUNDLE
+      && gst_sdp_message_medias_len (msg) != bundle_idx;
+  guint last_data_index = G_MAXUINT;
+
+  /* add data channel support */
+  if (webrtc->priv->data_channels->len == 0)
+    return FALSE;
+
+  if (last_offer) {
+    last_data_index = _message_get_datachannel_index (last_offer);
+    if (last_data_index < G_MAXUINT) {
+      g_assert (last_data_index < gst_sdp_message_medias_len (last_offer));
+      /* XXX: is this always true when recycling transceivers?
+       * i.e. do we always put the data channel in the same mline */
+      g_assert (last_data_index == gst_sdp_message_medias_len (msg));
+    }
+  }
+
+  /* mandated by JSEP */
+  gst_sdp_media_add_attribute (media, "setup", "actpass");
+
+  /* FIXME: only needed when restarting ICE */
+  if (last_offer && last_data_index < G_MAXUINT) {
+    ufrag = g_strdup (_media_get_ice_ufrag (last_offer, last_data_index));
+    pwd = g_strdup (_media_get_ice_pwd (last_offer, last_data_index));
+  } else {
+    if (webrtc->bundle_policy == GST_WEBRTC_BUNDLE_POLICY_NONE) {
+      _generate_ice_credentials (&ufrag, &pwd);
+    } else {
+      ufrag = g_strdup (bundle_ufrag);
+      pwd = g_strdup (bundle_pwd);
+    }
+  }
+  gst_sdp_media_add_attribute (media, "ice-ufrag", ufrag);
+  gst_sdp_media_add_attribute (media, "ice-pwd", pwd);
+  g_free (ufrag);
+  g_free (pwd);
+
+  gst_sdp_media_set_media (media, "application");
+  gst_sdp_media_set_port_info (media, bundle_only ? 0 : 9, 0);
+  gst_sdp_media_set_proto (media, "UDP/DTLS/SCTP");
+  gst_sdp_media_add_connection (media, "IN", "IP4", "0.0.0.0", 0, 0);
+  gst_sdp_media_add_format (media, "webrtc-datachannel");
+
+  if (bundle_idx != gst_sdp_message_medias_len (msg))
+    gst_sdp_media_add_attribute (media, "bundle-only", NULL);
+
+  if (last_offer && last_data_index < G_MAXUINT) {
+    const GstSDPMedia *last_data_media;
+    const gchar *mid;
+
+    last_data_media = gst_sdp_message_get_media (last_offer, last_data_index);
+    mid = gst_sdp_media_get_attribute_val (last_data_media, "mid");
+
+    gst_sdp_media_add_attribute (media, "mid", mid);
+  } else {
+    sdp_mid = g_strdup_printf ("%s%u", gst_sdp_media_get_media (media),
+        webrtc->priv->media_counter++);
+    gst_sdp_media_add_attribute (media, "mid", sdp_mid);
+    g_free (sdp_mid);
+  }
+
+  if (bundled_mids) {
+    const gchar *mid = gst_sdp_media_get_attribute_val (media, "mid");
+
+    g_assert (mid);
+    g_string_append_printf (bundled_mids, " %s", mid);
+  }
+
+  /* FIXME: negotiate this properly */
+  gst_sdp_media_add_attribute (media, "sctp-port", "5000");
+
+  _get_or_create_data_channel_transports (webrtc,
+      bundled_mids ? 0 : webrtc->priv->transceivers->len);
+  _add_fingerprint_to_media (webrtc->priv->sctp_transport->transport, media);
+
+  return TRUE;
+}
+
+/* TODO: use the options argument */
 static GstSDPMessage *
 _create_offer_task (GstWebRTCBin * webrtc, const GstStructure * options)
 {
   GstSDPMessage *ret;
+  GString *bundled_mids = NULL;
+  gchar *bundle_ufrag = NULL;
+  gchar *bundle_pwd = NULL;
+  GArray *reserved_pts = NULL;
+  GstSDPMessage *last_offer = _get_latest_self_generated_sdp (webrtc);
+  GList *seen_transceivers = NULL;
+  guint media_idx = 0;
   int i;
-  gchar *str;
 
   gst_sdp_message_new (&ret);
 
   gst_sdp_message_set_version (ret, "0");
   {
-    /* FIXME: session id and version need special handling depending on the state we're in */
-    gchar *sess_id = g_strdup_printf ("%" G_GUINT64_FORMAT, RANDOM_SESSION_ID);
-    gst_sdp_message_set_origin (ret, "-", sess_id, "0", "IN", "IP4", "0.0.0.0");
+    gchar *v, *sess_id;
+    v = g_strdup_printf ("%u", webrtc->priv->offer_count++);
+    if (last_offer) {
+      const GstSDPOrigin *origin = gst_sdp_message_get_origin (last_offer);
+      sess_id = g_strdup (origin->sess_id);
+    } else {
+      sess_id = g_strdup_printf ("%" G_GUINT64_FORMAT, RANDOM_SESSION_ID);
+    }
+    gst_sdp_message_set_origin (ret, "-", sess_id, v, "IN", "IP4", "0.0.0.0");
     g_free (sess_id);
+    g_free (v);
   }
   gst_sdp_message_set_session_name (ret, "-");
   gst_sdp_message_add_time (ret, "0", "0", NULL);
   gst_sdp_message_add_attribute (ret, "ice-options", "trickle");
 
-  /* https://tools.ietf.org/html/draft-ietf-mmusic-msid-05#section-3 */
-  str = g_strdup_printf ("WMS %s", GST_OBJECT (webrtc)->name);
-  gst_sdp_message_add_attribute (ret, "msid-semantic", str);
-  g_free (str);
+  if (webrtc->bundle_policy == GST_WEBRTC_BUNDLE_POLICY_MAX_BUNDLE) {
+    bundled_mids = g_string_new ("BUNDLE");
+  } else if (webrtc->bundle_policy == GST_WEBRTC_BUNDLE_POLICY_MAX_COMPAT) {
+    bundled_mids = g_string_new ("BUNDLE");
+  }
 
-  /* for each rtp transceiver */
+  if (webrtc->bundle_policy != GST_WEBRTC_BUNDLE_POLICY_NONE) {
+    GStrv last_bundle = NULL;
+    guint bundle_media_index;
+
+    reserved_pts = gather_reserved_pts (webrtc);
+    if (last_offer && _parse_bundle (last_offer, &last_bundle) && last_bundle
+        && last_bundle && last_bundle[0]
+        && _get_bundle_index (last_offer, last_bundle, &bundle_media_index)) {
+      bundle_ufrag =
+          g_strdup (_media_get_ice_ufrag (last_offer, bundle_media_index));
+      bundle_pwd =
+          g_strdup (_media_get_ice_pwd (last_offer, bundle_media_index));
+    } else {
+      _generate_ice_credentials (&bundle_ufrag, &bundle_pwd);
+    }
+
+    g_strfreev (last_bundle);
+  }
+
+  /* FIXME: recycle transceivers */
+
+  /* Fill up the renegotiated streams first */
+  if (last_offer) {
+    for (i = 0; i < gst_sdp_message_medias_len (last_offer); i++) {
+      GstWebRTCRTPTransceiver *trans = NULL;
+      const GstSDPMedia *last_media;
+
+      last_media = gst_sdp_message_get_media (last_offer, i);
+
+      if (g_strcmp0 (gst_sdp_media_get_media (last_media), "audio") == 0
+          || g_strcmp0 (gst_sdp_media_get_media (last_media), "video") == 0) {
+        const gchar *last_mid;
+        int j;
+        last_mid = gst_sdp_media_get_attribute_val (last_media, "mid");
+
+        for (j = 0; j < webrtc->priv->transceivers->len; j++) {
+          trans =
+              g_array_index (webrtc->priv->transceivers,
+              GstWebRTCRTPTransceiver *, j);
+
+          if (trans->mid && g_strcmp0 (trans->mid, last_mid) == 0) {
+            GstSDPMedia *media;
+
+            g_assert (!g_list_find (seen_transceivers, trans));
+
+            GST_LOG_OBJECT (webrtc, "using previous negotiatied transceiver %"
+                GST_PTR_FORMAT " with mid %s into media index %u", trans,
+                trans->mid, media_idx);
+
+            /* FIXME: deal with format changes */
+            gst_sdp_media_copy (last_media, &media);
+            _media_replace_direction (media, trans->direction);
+
+            if (bundled_mids) {
+              const gchar *mid = gst_sdp_media_get_attribute_val (media, "mid");
+
+              g_assert (mid);
+              g_string_append_printf (bundled_mids, " %s", mid);
+            }
+
+            gst_sdp_message_add_media (ret, media);
+            media_idx++;
+
+            gst_sdp_media_free (media);
+            seen_transceivers = g_list_prepend (seen_transceivers, trans);
+            break;
+          }
+        }
+      } else if (g_strcmp0 (gst_sdp_media_get_media (last_media),
+              "application") == 0) {
+        GstSDPMedia media = { 0, };
+        gst_sdp_media_init (&media);
+        if (_add_data_channel_offer (webrtc, ret, &media, bundled_mids, 0,
+                bundle_ufrag, bundle_pwd)) {
+          gst_sdp_message_add_media (ret, &media);
+          media_idx++;
+        } else {
+          gst_sdp_media_uninit (&media);
+        }
+      }
+    }
+  }
+
+  /* add any extra streams */
   for (i = 0; i < webrtc->priv->transceivers->len; i++) {
     GstWebRTCRTPTransceiver *trans;
     GstSDPMedia media = { 0, };
-    gchar *ufrag, *pwd;
 
     trans =
         g_array_index (webrtc->priv->transceivers, GstWebRTCRTPTransceiver *,
         i);
 
+    /* don't add transceivers twice */
+    if (g_list_find (seen_transceivers, trans))
+      continue;
+
+    /* don't add stopped transceivers */
+    if (trans->stopped)
+      continue;
+
     gst_sdp_media_init (&media);
-    /* mandated by JSEP */
-    gst_sdp_media_add_attribute (&media, "setup", "actpass");
 
-    /* FIXME: only needed when restarting ICE */
-    _generate_ice_credentials (&ufrag, &pwd);
-    gst_sdp_media_add_attribute (&media, "ice-ufrag", ufrag);
-    gst_sdp_media_add_attribute (&media, "ice-pwd", pwd);
-    g_free (ufrag);
-    g_free (pwd);
+    if (webrtc->bundle_policy == GST_WEBRTC_BUNDLE_POLICY_NONE) {
+      reserved_pts = g_array_new (FALSE, FALSE, sizeof (guint));
+    }
+
+    GST_LOG_OBJECT (webrtc, "adding transceiver %" GST_PTR_FORMAT " at media "
+        "index %u", trans, media_idx);
 
     if (sdp_media_from_transceiver (webrtc, &media, trans,
-            GST_WEBRTC_SDP_TYPE_OFFER, i))
+            GST_WEBRTC_SDP_TYPE_OFFER, media_idx, bundled_mids, 0, bundle_ufrag,
+            bundle_pwd, reserved_pts)) {
       gst_sdp_message_add_media (ret, &media);
-    else
+      media_idx++;
+    } else {
+      gst_sdp_media_uninit (&media);
+    }
+
+    if (webrtc->bundle_policy == GST_WEBRTC_BUNDLE_POLICY_NONE) {
+      g_array_free (reserved_pts, TRUE);
+    }
+    seen_transceivers = g_list_prepend (seen_transceivers, trans);
+  }
+
+  if (webrtc->bundle_policy != GST_WEBRTC_BUNDLE_POLICY_NONE) {
+    g_array_free (reserved_pts, TRUE);
+  }
+
+  /* add a data channel if exists and not renegotiated */
+  if (_message_get_datachannel_index (ret) == G_MAXUINT) {
+    GstSDPMedia media = { 0, };
+    gst_sdp_media_init (&media);
+    if (_add_data_channel_offer (webrtc, ret, &media, bundled_mids, 0,
+            bundle_ufrag, bundle_pwd)) {
+      gst_sdp_message_add_media (ret, &media);
+      media_idx++;
+    } else {
       gst_sdp_media_uninit (&media);
+    }
+  }
+
+  g_assert (media_idx == gst_sdp_message_medias_len (ret));
+
+  if (bundled_mids) {
+    gchar *mids = g_string_free (bundled_mids, FALSE);
+
+    gst_sdp_message_add_attribute (ret, "group", mids);
+    g_free (mids);
   }
 
+  if (bundle_ufrag)
+    g_free (bundle_ufrag);
+
+  if (bundle_pwd)
+    g_free (bundle_pwd);
+
   /* FIXME: pre-emptively setup receiving elements when needed */
 
   /* XXX: only true for the initial offerer */
   g_object_set (webrtc->priv->ice, "controller", TRUE, NULL);
 
+  g_list_free (seen_transceivers);
+
+  if (webrtc->priv->last_generated_answer)
+    gst_webrtc_session_description_free (webrtc->priv->last_generated_answer);
+  webrtc->priv->last_generated_answer = NULL;
+  if (webrtc->priv->last_generated_offer)
+    gst_webrtc_session_description_free (webrtc->priv->last_generated_offer);
+  {
+    GstSDPMessage *copy;
+    gst_sdp_message_copy (ret, &copy);
+    webrtc->priv->last_generated_offer =
+        gst_webrtc_session_description_new (GST_WEBRTC_SDP_TYPE_OFFER, copy);
+  }
+
   return ret;
 }
 
@@ -1932,6 +2672,7 @@ _get_rtx_target_pt_and_ssrc_from_caps (GstCaps * answer_caps, gint * target_pt,
   gst_structure_get_uint (s, "ssrc", target_ssrc);
 }
 
+/* TODO: use the options argument */
 static GstSDPMessage *
 _create_answer_task (GstWebRTCBin * webrtc, const GstStructure * options)
 {
@@ -1939,6 +2680,13 @@ _create_answer_task (GstWebRTCBin * webrtc, const GstStructure * options)
   const GstWebRTCSessionDescription *pending_remote =
       webrtc->pending_remote_description;
   guint i;
+  GStrv bundled = NULL;
+  guint bundle_idx = 0;
+  GString *bundled_mids = NULL;
+  gchar *bundle_ufrag = NULL;
+  gchar *bundle_pwd = NULL;
+  GList *seen_transceivers = NULL;
+  GstSDPMessage *last_answer = _get_latest_self_generated_sdp (webrtc);
 
   if (!webrtc->pending_remote_description) {
     GST_ERROR_OBJECT (webrtc,
@@ -1946,15 +2694,45 @@ _create_answer_task (GstWebRTCBin * webrtc, const GstStructure * options)
     return NULL;
   }
 
+  if (!_parse_bundle (pending_remote->sdp, &bundled))
+    goto out;
+
+  if (bundled) {
+    GStrv last_bundle = NULL;
+    guint bundle_media_index;
+
+    if (!_get_bundle_index (pending_remote->sdp, bundled, &bundle_idx)) {
+      GST_ERROR_OBJECT (webrtc, "Bundle tag is %s but no media found matching",
+          bundled[0]);
+      goto out;
+    }
+
+    if (webrtc->bundle_policy != GST_WEBRTC_BUNDLE_POLICY_NONE) {
+      bundled_mids = g_string_new ("BUNDLE");
+    }
+
+    if (last_answer && _parse_bundle (last_answer, &last_bundle)
+        && last_bundle && last_bundle[0]
+        && _get_bundle_index (last_answer, last_bundle, &bundle_media_index)) {
+      bundle_ufrag =
+          g_strdup (_media_get_ice_ufrag (last_answer, bundle_media_index));
+      bundle_pwd =
+          g_strdup (_media_get_ice_pwd (last_answer, bundle_media_index));
+    } else {
+      _generate_ice_credentials (&bundle_ufrag, &bundle_pwd);
+    }
+
+    g_strfreev (last_bundle);
+  }
+
   gst_sdp_message_new (&ret);
 
-  /* FIXME: session id and version need special handling depending on the state we're in */
   gst_sdp_message_set_version (ret, "0");
   {
     const GstSDPOrigin *offer_origin =
         gst_sdp_message_get_origin (pending_remote->sdp);
-    gst_sdp_message_set_origin (ret, "-", offer_origin->sess_id, "0", "IN",
-        "IP4", "0.0.0.0");
+    gst_sdp_message_set_origin (ret, "-", offer_origin->sess_id,
+        offer_origin->sess_version, "IN", "IP4", "0.0.0.0");
   }
   gst_sdp_message_set_session_name (ret, "-");
 
@@ -1968,40 +2746,45 @@ _create_answer_task (GstWebRTCBin * webrtc, const GstStructure * options)
   }
 
   for (i = 0; i < gst_sdp_message_medias_len (pending_remote->sdp); i++) {
-    /* FIXME:
-     * bundle policy
-     */
     GstSDPMedia *media = NULL;
     GstSDPMedia *offer_media;
-    GstWebRTCRTPTransceiver *rtp_trans = NULL;
-    WebRTCTransceiver *trans = NULL;
-    GstWebRTCRTPTransceiverDirection offer_dir, answer_dir;
     GstWebRTCDTLSSetup offer_setup, answer_setup;
-    GstCaps *offer_caps, *answer_caps = NULL;
-    gchar *cert;
-    guint j;
-    guint k;
-    gint target_pt = -1;
-    gint original_target_pt = -1;
-    guint target_ssrc = 0;
+    guint j, k;
+    gboolean bundle_only;
+    const gchar *mid;
+
+    offer_media =
+        (GstSDPMedia *) gst_sdp_message_get_media (pending_remote->sdp, i);
+    bundle_only = _media_has_attribute_key (offer_media, "bundle-only");
 
     gst_sdp_media_new (&media);
-    gst_sdp_media_set_port_info (media, 9, 0);
-    gst_sdp_media_set_proto (media, "UDP/TLS/RTP/SAVPF");
+    if (bundle_only && webrtc->bundle_policy == GST_WEBRTC_BUNDLE_POLICY_NONE)
+      gst_sdp_media_set_port_info (media, 0, 0);
+    else
+      gst_sdp_media_set_port_info (media, 9, 0);
     gst_sdp_media_add_connection (media, "IN", "IP4", "0.0.0.0", 0, 0);
 
     {
-      /* FIXME: only needed when restarting ICE */
       gchar *ufrag, *pwd;
-      _generate_ice_credentials (&ufrag, &pwd);
+
+      /* FIXME: deal with ICE restarts */
+      if (last_answer && i < gst_sdp_message_medias_len (last_answer)) {
+        ufrag = g_strdup (_media_get_ice_ufrag (last_answer, i));
+        pwd = g_strdup (_media_get_ice_pwd (last_answer, i));
+      } else {
+        if (!bundled) {
+          _generate_ice_credentials (&ufrag, &pwd);
+        } else {
+          ufrag = g_strdup (bundle_ufrag);
+          pwd = g_strdup (bundle_pwd);
+        }
+      }
       gst_sdp_media_add_attribute (media, "ice-ufrag", ufrag);
       gst_sdp_media_add_attribute (media, "ice-pwd", pwd);
       g_free (ufrag);
       g_free (pwd);
     }
 
-    offer_media =
-        (GstSDPMedia *) gst_sdp_message_get_media (pending_remote->sdp, i);
     for (j = 0; j < gst_sdp_media_attributes_len (offer_media); j++) {
       const GstSDPAttribute *attr =
           gst_sdp_media_get_attribute (offer_media, j);
@@ -2013,154 +2796,246 @@ _create_answer_task (GstWebRTCBin * webrtc, const GstStructure * options)
       }
     }
 
-    offer_caps = gst_caps_new_empty ();
-    for (j = 0; j < gst_sdp_media_formats_len (offer_media); j++) {
-      guint pt = atoi (gst_sdp_media_get_format (offer_media, j));
-      GstCaps *caps;
+    mid = gst_sdp_media_get_attribute_val (media, "mid");
+    /* XXX: not strictly required but a lot of functionality requires a mid */
+    g_assert (mid);
 
-      caps = gst_sdp_media_get_caps_from_media (offer_media, pt);
+    /* set the a=setup: attribute */
+    offer_setup = _get_dtls_setup_from_media (offer_media);
+    answer_setup = _intersect_dtls_setup (offer_setup);
+    if (answer_setup == GST_WEBRTC_DTLS_SETUP_NONE) {
+      GST_WARNING_OBJECT (webrtc, "Could not intersect offer setup with "
+          "transceiver direction");
+      goto rejected;
+    }
+    _media_replace_setup (media, answer_setup);
 
-      /* gst_sdp_media_get_caps_from_media() produces caps with name
-       * "application/x-unknown" which will fail intersection with
-       * "application/x-rtp" caps so mangle the returns caps to have the
-       * correct name here */
-      for (k = 0; k < gst_caps_get_size (caps); k++) {
-        GstStructure *s = gst_caps_get_structure (caps, k);
-        gst_structure_set_name (s, "application/x-rtp");
+    if (g_strcmp0 (gst_sdp_media_get_media (offer_media), "application") == 0) {
+      int sctp_port;
+
+      if (gst_sdp_media_formats_len (offer_media) != 1) {
+        GST_WARNING_OBJECT (webrtc, "Could not find a format in the m= line "
+            "for webrtc-datachannel");
+        goto rejected;
+      }
+      sctp_port = _get_sctp_port_from_media (offer_media);
+      if (sctp_port == -1) {
+        GST_WARNING_OBJECT (webrtc, "media does not contain a sctp port");
+        goto rejected;
       }
 
-      gst_caps_append (offer_caps, caps);
-    }
+      /* XXX: older browsers will produce a different SDP format for data
+       * channel that is currently not parsed correctly */
+      gst_sdp_media_set_proto (media, "UDP/DTLS/SCTP");
 
-    for (j = 0; j < webrtc->priv->transceivers->len; j++) {
-      GstCaps *trans_caps;
-
-      rtp_trans =
-          g_array_index (webrtc->priv->transceivers, GstWebRTCRTPTransceiver *,
-          j);
-      trans_caps = _find_codec_preferences (webrtc, rtp_trans, GST_PAD_SINK, j);
-
-      GST_TRACE_OBJECT (webrtc, "trying to compare %" GST_PTR_FORMAT
-          " and %" GST_PTR_FORMAT, offer_caps, trans_caps);
-
-      /* FIXME: technically this is a little overreaching as some fields we
-       * we can deal with not having and/or we may have unrecognized fields
-       * that we cannot actually support */
-      if (trans_caps) {
-        answer_caps = gst_caps_intersect (offer_caps, trans_caps);
-        if (answer_caps && !gst_caps_is_empty (answer_caps)) {
-          GST_LOG_OBJECT (webrtc,
-              "found compatible transceiver %" GST_PTR_FORMAT
-              " for offer media %u", trans, i);
-          if (trans_caps)
-            gst_caps_unref (trans_caps);
-          break;
-        } else {
-          if (answer_caps) {
-            gst_caps_unref (answer_caps);
-            answer_caps = NULL;
+      gst_sdp_media_set_media (media, "application");
+      gst_sdp_media_set_port_info (media, 9, 0);
+      gst_sdp_media_add_format (media, "webrtc-datachannel");
+
+      /* FIXME: negotiate this properly on renegotiation */
+      gst_sdp_media_add_attribute (media, "sctp-port", "5000");
+
+      _get_or_create_data_channel_transports (webrtc,
+          bundled_mids ? bundle_idx : i);
+
+      if (bundled_mids) {
+        g_assert (mid);
+        g_string_append_printf (bundled_mids, " %s", mid);
+      }
+
+      _add_fingerprint_to_media (webrtc->priv->sctp_transport->transport,
+          media);
+    } else if (g_strcmp0 (gst_sdp_media_get_media (offer_media), "audio") == 0
+        || g_strcmp0 (gst_sdp_media_get_media (offer_media), "video") == 0) {
+      GstCaps *offer_caps, *answer_caps = NULL;
+      GstWebRTCRTPTransceiver *rtp_trans = NULL;
+      WebRTCTransceiver *trans = NULL;
+      GstWebRTCRTPTransceiverDirection offer_dir, answer_dir;
+      gint target_pt = -1;
+      gint original_target_pt = -1;
+      guint target_ssrc = 0;
+
+      gst_sdp_media_set_proto (media, "UDP/TLS/RTP/SAVPF");
+      offer_caps = _rtp_caps_from_media (offer_media);
+
+      if (last_answer && i < gst_sdp_message_medias_len (last_answer)
+          && (rtp_trans =
+              _find_transceiver (webrtc, mid,
+                  (FindTransceiverFunc) match_for_mid))) {
+        const GstSDPMedia *last_media =
+            gst_sdp_message_get_media (last_answer, i);
+        const gchar *last_mid =
+            gst_sdp_media_get_attribute_val (last_media, "mid");
+
+        /* FIXME: assumes no shenanigans with recycling transceivers */
+        g_assert (g_strcmp0 (mid, last_mid) == 0);
+
+        if (!answer_caps
+            && (rtp_trans->direction ==
+                GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDRECV
+                || rtp_trans->direction ==
+                GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_RECVONLY))
+          answer_caps =
+              _find_codec_preferences (webrtc, rtp_trans, GST_PAD_SINK, i);
+        if (!answer_caps
+            && (rtp_trans->direction ==
+                GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDRECV
+                || rtp_trans->direction ==
+                GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDONLY))
+          answer_caps =
+              _find_codec_preferences (webrtc, rtp_trans, GST_PAD_SRC, i);
+        if (!answer_caps)
+          answer_caps = _rtp_caps_from_media (last_media);
+
+        /* XXX: In theory we're meant to use the sendrecv formats for the
+         * inactive direction however we don't know what that may be and would
+         * require asking outside what it expects to possibly send later */
+
+        GST_LOG_OBJECT (webrtc, "Found existing previously negotiated "
+            "transceiver %" GST_PTR_FORMAT " from mid %s for mline %u "
+            "using caps %" GST_PTR_FORMAT, rtp_trans, mid, i, answer_caps);
+      } else {
+        for (j = 0; j < webrtc->priv->transceivers->len; j++) {
+          GstCaps *trans_caps;
+
+          rtp_trans =
+              g_array_index (webrtc->priv->transceivers,
+              GstWebRTCRTPTransceiver *, j);
+
+          if (g_list_find (seen_transceivers, rtp_trans)) {
+            /* Don't double allocate a transceiver to multiple mlines */
+            rtp_trans = NULL;
+            continue;
+          }
+
+          trans_caps =
+              _find_codec_preferences (webrtc, rtp_trans, GST_PAD_SINK, j);
+
+          GST_TRACE_OBJECT (webrtc, "trying to compare %" GST_PTR_FORMAT
+              " and %" GST_PTR_FORMAT, offer_caps, trans_caps);
+
+          /* FIXME: technically this is a little overreaching as some fields we
+           * we can deal with not having and/or we may have unrecognized fields
+           * that we cannot actually support */
+          if (trans_caps) {
+            answer_caps = gst_caps_intersect (offer_caps, trans_caps);
+            if (answer_caps && !gst_caps_is_empty (answer_caps)) {
+              GST_LOG_OBJECT (webrtc,
+                  "found compatible transceiver %" GST_PTR_FORMAT
+                  " for offer media %u", rtp_trans, i);
+              if (trans_caps)
+                gst_caps_unref (trans_caps);
+              break;
+            } else {
+              if (answer_caps) {
+                gst_caps_unref (answer_caps);
+                answer_caps = NULL;
+              }
+              if (trans_caps)
+                gst_caps_unref (trans_caps);
+              rtp_trans = NULL;
+            }
+          } else {
+            rtp_trans = NULL;
           }
-          if (trans_caps)
-            gst_caps_unref (trans_caps);
-          rtp_trans = NULL;
         }
+      }
+
+      if (rtp_trans) {
+        answer_dir = rtp_trans->direction;
+        g_assert (answer_caps != NULL);
       } else {
-        rtp_trans = NULL;
+        /* if no transceiver, then we only receive that stream and respond with
+         * the exact same caps */
+        /* FIXME: how to validate that subsequent elements can actually receive
+         * this payload/format */
+        answer_dir = GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_RECVONLY;
+        answer_caps = gst_caps_ref (offer_caps);
       }
-    }
 
-    if (rtp_trans) {
-      answer_dir = rtp_trans->direction;
-      g_assert (answer_caps != NULL);
-    } else {
-      /* if no transceiver, then we only receive that stream and respond with
-       * the exact same caps */
-      /* FIXME: how to validate that subsequent elements can actually receive
-       * this payload/format */
-      answer_dir = GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_RECVONLY;
-      answer_caps = gst_caps_ref (offer_caps);
-    }
+      if (gst_caps_is_empty (answer_caps)) {
+        GST_WARNING_OBJECT (webrtc, "Could not create caps for media");
+        if (rtp_trans)
+          gst_object_unref (rtp_trans);
+        gst_caps_unref (answer_caps);
+        goto rejected;
+      }
 
-    if (!rtp_trans) {
-      trans = _create_webrtc_transceiver (webrtc, answer_dir, i);
-      rtp_trans = GST_WEBRTC_RTP_TRANSCEIVER (trans);
-    } else {
-      trans = WEBRTC_TRANSCEIVER (rtp_trans);
-    }
+      seen_transceivers = g_list_prepend (seen_transceivers, rtp_trans);
 
-    if (!trans->do_nack) {
-      answer_caps = gst_caps_make_writable (answer_caps);
-      for (k = 0; k < gst_caps_get_size (answer_caps); k++) {
-        GstStructure *s = gst_caps_get_structure (answer_caps, k);
-        gst_structure_remove_fields (s, "rtcp-fb-nack", NULL);
+      if (!rtp_trans) {
+        trans = _create_webrtc_transceiver (webrtc, answer_dir, i);
+        rtp_trans = GST_WEBRTC_RTP_TRANSCEIVER (trans);
+
+        GST_LOG_OBJECT (webrtc, "Created new transceiver %" GST_PTR_FORMAT
+            " for mline %u", trans, i);
+      } else {
+        trans = WEBRTC_TRANSCEIVER (rtp_trans);
       }
-    }
 
-    gst_sdp_media_set_media_from_caps (answer_caps, media);
+      if (!trans->do_nack) {
+        answer_caps = gst_caps_make_writable (answer_caps);
+        for (k = 0; k < gst_caps_get_size (answer_caps); k++) {
+          GstStructure *s = gst_caps_get_structure (answer_caps, k);
+          gst_structure_remove_fields (s, "rtcp-fb-nack", NULL);
+        }
+      }
 
-    _get_rtx_target_pt_and_ssrc_from_caps (answer_caps, &target_pt,
-        &target_ssrc);
+      gst_sdp_media_set_media_from_caps (answer_caps, media);
 
-    original_target_pt = target_pt;
+      _get_rtx_target_pt_and_ssrc_from_caps (answer_caps, &target_pt,
+          &target_ssrc);
 
-    _media_add_fec (media, trans, offer_caps, &target_pt);
-    if (trans->do_nack) {
-      _media_add_rtx (media, trans, offer_caps, target_pt, target_ssrc);
-      if (target_pt != original_target_pt)
-        _media_add_rtx (media, trans, offer_caps, original_target_pt,
-            target_ssrc);
-    }
+      original_target_pt = target_pt;
 
-    if (answer_dir != GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_RECVONLY)
-      _media_add_ssrcs (media, answer_caps, webrtc,
-          WEBRTC_TRANSCEIVER (rtp_trans));
+      _media_add_fec (media, trans, offer_caps, &target_pt);
+      if (trans->do_nack) {
+        _media_add_rtx (media, trans, offer_caps, target_pt, target_ssrc);
+        if (target_pt != original_target_pt)
+          _media_add_rtx (media, trans, offer_caps, original_target_pt,
+              target_ssrc);
+      }
 
-    gst_caps_unref (answer_caps);
-    answer_caps = NULL;
+      if (answer_dir != GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_RECVONLY)
+        _media_add_ssrcs (media, answer_caps, webrtc,
+            WEBRTC_TRANSCEIVER (rtp_trans));
 
-    /* set the new media direction */
-    offer_dir = _get_direction_from_media (offer_media);
-    answer_dir = _intersect_answer_directions (offer_dir, answer_dir);
-    if (answer_dir == GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_NONE) {
-      GST_WARNING_OBJECT (webrtc, "Could not intersect offer direction with "
-          "transceiver direction");
-      goto rejected;
-    }
-    _media_replace_direction (media, answer_dir);
+      gst_caps_unref (answer_caps);
+      answer_caps = NULL;
 
-    /* set the a=setup: attribute */
-    offer_setup = _get_dtls_setup_from_media (offer_media);
-    answer_setup = _intersect_dtls_setup (offer_setup);
-    if (answer_setup == GST_WEBRTC_DTLS_SETUP_NONE) {
-      GST_WARNING_OBJECT (webrtc, "Could not intersect offer direction with "
-          "transceiver direction");
-      goto rejected;
-    }
-    _media_replace_setup (media, answer_setup);
+      /* set the new media direction */
+      offer_dir = _get_direction_from_media (offer_media);
+      answer_dir = _intersect_answer_directions (offer_dir, answer_dir);
+      if (answer_dir == GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_NONE) {
+        GST_WARNING_OBJECT (webrtc, "Could not intersect offer direction with "
+            "transceiver direction");
+        goto rejected;
+      }
+      _media_replace_direction (media, answer_dir);
 
-    /* FIXME: bundle! */
-    if (!trans->stream) {
-      TransportStream *item = _find_transport_for_session (webrtc, i);
-      if (!item)
-        item = _create_transport_channel (webrtc, i);
-      webrtc_transceiver_set_transport (trans, item);
-    }
-    /* set the a=fingerprint: for this transport */
-    g_object_get (trans->stream->transport, "certificate", &cert, NULL);
+      if (!trans->stream) {
+        TransportStream *item;
 
-    {
-      gchar *fingerprint, *val;
-
-      fingerprint =
-          _generate_fingerprint_from_certificate (cert, G_CHECKSUM_SHA256);
-      g_free (cert);
-      val =
-          g_strdup_printf ("%s %s",
-          _g_checksum_to_webrtc_string (G_CHECKSUM_SHA256), fingerprint);
-      g_free (fingerprint);
-
-      gst_sdp_media_add_attribute (media, "fingerprint", val);
-      g_free (val);
+        item =
+            _get_or_create_transport_stream (webrtc,
+            bundled_mids ? bundle_idx : i, FALSE);
+        webrtc_transceiver_set_transport (trans, item);
+      }
+
+      if (bundled_mids) {
+        const gchar *mid = gst_sdp_media_get_attribute_val (media, "mid");
+
+        g_assert (mid);
+        g_string_append_printf (bundled_mids, " %s", mid);
+      }
+
+      /* set the a=fingerprint: for this transport */
+      _add_fingerprint_to_media (trans->stream->transport, media);
+
+      gst_caps_unref (offer_caps);
+    } else {
+      GST_WARNING_OBJECT (webrtc, "unknown m= line media name");
+      goto rejected;
     }
 
     if (0) {
@@ -2172,15 +3047,43 @@ _create_answer_task (GstWebRTCBin * webrtc, const GstStructure * options)
     }
     gst_sdp_message_add_media (ret, media);
     gst_sdp_media_free (media);
+  }
+
+  if (bundled_mids) {
+    gchar *mids = g_string_free (bundled_mids, FALSE);
 
-    gst_caps_unref (offer_caps);
+    gst_sdp_message_add_attribute (ret, "group", mids);
+    g_free (mids);
   }
 
+  if (bundle_ufrag)
+    g_free (bundle_ufrag);
+
+  if (bundle_pwd)
+    g_free (bundle_pwd);
+
   /* FIXME: can we add not matched transceivers? */
 
   /* XXX: only true for the initial offerer */
   g_object_set (webrtc->priv->ice, "controller", FALSE, NULL);
 
+out:
+  g_strfreev (bundled);
+
+  g_list_free (seen_transceivers);
+
+  if (webrtc->priv->last_generated_offer)
+    gst_webrtc_session_description_free (webrtc->priv->last_generated_offer);
+  webrtc->priv->last_generated_offer = NULL;
+  if (webrtc->priv->last_generated_answer)
+    gst_webrtc_session_description_free (webrtc->priv->last_generated_answer);
+  {
+    GstSDPMessage *copy;
+    gst_sdp_message_copy (ret, &copy);
+    webrtc->priv->last_generated_answer =
+        gst_webrtc_session_description_new (GST_WEBRTC_SDP_TYPE_ANSWER, copy);
+  }
+
   return ret;
 }
 
@@ -2313,6 +3216,8 @@ static GstPad *
 _connect_input_stream (GstWebRTCBin * webrtc, GstWebRTCBinPad * pad)
 {
 /*
+ * Not-bundle case:
+ *
  * ,-------------------------webrtcbin-------------------------,
  * ;                                                           ;
  * ;          ,-------rtpbin-------,   ,--transport_send_%u--, ;
@@ -2324,6 +3229,22 @@ _connect_input_stream (GstWebRTCBin * webrtc, GstWebRTCBinPad * pad)
  * ;          '--------------------'                           ;
  * '--------------------- -------------------------------------'
  */
+
+/*
+ * Bundle case:
+ * ,--------------------------------webrtcbin--------------------------------,
+ * ;                                                                         ;
+ * ;                        ,-------rtpbin-------,   ,--transport_send_%u--, ;
+ * ;                        ;    send_rtp_src_%u o---o rtp_sink            ; ;
+ * ;                        ;                    ;   ;                     ; ;
+ * ;                        ;   send_rtcp_src_%u o---o rtcp_sink           ; ;
+ * ; sink_%u ,---funnel---, ;                    ;   '---------------------' ;
+ * o---------o sink_%u    ; ;                    ;                           ;
+ * ; sink_%u ;        src o-o send_rtp_sink_%u   ;                           ;
+ * o---------o sink_%u    ; ;                    ;                           ;
+ * ;         '------------' '--------------------'                           ;
+ * '-------------------------------------------------------------------------'
+ */
   GstPadTemplate *rtp_templ;
   GstPad *rtp_sink;
   gchar *pad_name;
@@ -2333,34 +3254,38 @@ _connect_input_stream (GstWebRTCBin * webrtc, GstWebRTCBinPad * pad)
 
   GST_INFO_OBJECT (pad, "linking input stream %u", pad->mlineindex);
 
-  rtp_templ =
-      _find_pad_template (webrtc->rtpbin, GST_PAD_SINK, GST_PAD_REQUEST,
-      "send_rtp_sink_%u");
-  g_assert (rtp_templ);
+  trans = WEBRTC_TRANSCEIVER (pad->trans);
 
-  pad_name = g_strdup_printf ("send_rtp_sink_%u", pad->mlineindex);
-  rtp_sink =
-      gst_element_request_pad (webrtc->rtpbin, rtp_templ, pad_name, NULL);
-  g_free (pad_name);
-  gst_ghost_pad_set_target (GST_GHOST_PAD (pad), rtp_sink);
-  gst_object_unref (rtp_sink);
+  g_assert (trans->stream);
 
-  trans = WEBRTC_TRANSCEIVER (pad->trans);
+  if (!webrtc->rtpfunnel) {
+    rtp_templ =
+        _find_pad_template (webrtc->rtpbin, GST_PAD_SINK, GST_PAD_REQUEST,
+        "send_rtp_sink_%u");
+    g_assert (rtp_templ);
 
-  if (!trans->stream) {
-    TransportStream *item;
-    /* FIXME: bundle */
-    item = _find_transport_for_session (webrtc, pad->mlineindex);
-    if (!item)
-      item = _create_transport_channel (webrtc, pad->mlineindex);
-    webrtc_transceiver_set_transport (trans, item);
-  }
+    pad_name = g_strdup_printf ("send_rtp_sink_%u", pad->mlineindex);
+    rtp_sink =
+        gst_element_request_pad (webrtc->rtpbin, rtp_templ, pad_name, NULL);
+    g_free (pad_name);
+    gst_ghost_pad_set_target (GST_GHOST_PAD (pad), rtp_sink);
+    gst_object_unref (rtp_sink);
 
-  pad_name = g_strdup_printf ("send_rtp_src_%u", pad->mlineindex);
-  if (!gst_element_link_pads (GST_ELEMENT (webrtc->rtpbin), pad_name,
-          GST_ELEMENT (trans->stream->send_bin), "rtp_sink"))
-    g_warn_if_reached ();
-  g_free (pad_name);
+    pad_name = g_strdup_printf ("send_rtp_src_%u", pad->mlineindex);
+    if (!gst_element_link_pads (GST_ELEMENT (webrtc->rtpbin), pad_name,
+            GST_ELEMENT (trans->stream->send_bin), "rtp_sink"))
+      g_warn_if_reached ();
+    g_free (pad_name);
+  } else {
+    gchar *pad_name = g_strdup_printf ("sink_%u", pad->mlineindex);
+    GstPad *funnel_sinkpad =
+        gst_element_get_request_pad (webrtc->rtpfunnel, pad_name);
+
+    gst_ghost_pad_set_target (GST_GHOST_PAD (pad), funnel_sinkpad);
+
+    g_free (pad_name);
+    gst_object_unref (funnel_sinkpad);
+  }
 
   gst_element_sync_state_with_parent (GST_ELEMENT (trans->stream->send_bin));
 
@@ -2368,8 +3293,9 @@ _connect_input_stream (GstWebRTCBin * webrtc, GstWebRTCBinPad * pad)
 }
 
 /* output pads are receiving elements */
-static GstWebRTCBinPad *
-_connect_output_stream (GstWebRTCBin * webrtc, GstWebRTCBinPad * pad)
+static void
+_connect_output_stream (GstWebRTCBin * webrtc,
+    TransportStream * stream, guint session_id)
 {
 /*
  * ,------------------------webrtcbin------------------------,
@@ -2384,31 +3310,28 @@ _connect_output_stream (GstWebRTCBin * webrtc, GstWebRTCBinPad * pad)
  * '---------------------------------------------------------'
  */
   gchar *pad_name;
-  WebRTCTransceiver *trans;
-
-  g_return_val_if_fail (pad->trans != NULL, NULL);
-
-  GST_INFO_OBJECT (pad, "linking output stream %u", pad->mlineindex);
 
-  trans = WEBRTC_TRANSCEIVER (pad->trans);
-  if (!trans->stream) {
-    TransportStream *item;
-    /* FIXME: bundle */
-    item = _find_transport_for_session (webrtc, pad->mlineindex);
-    if (!item)
-      item = _create_transport_channel (webrtc, pad->mlineindex);
-    webrtc_transceiver_set_transport (trans, item);
+  if (stream->output_connected) {
+    GST_DEBUG_OBJECT (webrtc, "stream %" GST_PTR_FORMAT " is already "
+        "connected to rtpbin.  Not connecting", stream);
+    return;
   }
 
-  pad_name = g_strdup_printf ("recv_rtp_sink_%u", pad->mlineindex);
-  if (!gst_element_link_pads (GST_ELEMENT (trans->stream->receive_bin),
+  GST_INFO_OBJECT (webrtc, "linking output stream %u %" GST_PTR_FORMAT,
+      session_id, stream);
+
+  pad_name = g_strdup_printf ("recv_rtp_sink_%u", session_id);
+  if (!gst_element_link_pads (GST_ELEMENT (stream->receive_bin),
           "rtp_src", GST_ELEMENT (webrtc->rtpbin), pad_name))
     g_warn_if_reached ();
   g_free (pad_name);
 
-  gst_element_sync_state_with_parent (GST_ELEMENT (trans->stream->receive_bin));
+  gst_element_sync_state_with_parent (GST_ELEMENT (stream->receive_bin));
 
-  return pad;
+  /* The webrtcbin src_%u output pads will be created when rtpbin receives
+   * data on that stream in on_rtpbin_pad_added() */
+
+  stream->output_connected = TRUE;
 }
 
 typedef struct
@@ -2425,13 +3348,24 @@ _clear_ice_candidate_item (IceCandidateItem ** item)
 }
 
 static void
-_add_ice_candidate (GstWebRTCBin * webrtc, IceCandidateItem * item)
+_add_ice_candidate (GstWebRTCBin * webrtc, IceCandidateItem * item,
+    gboolean drop_invalid)
 {
   GstWebRTCICEStream *stream;
 
   stream = _find_ice_stream_for_session (webrtc, item->mlineindex);
   if (stream == NULL) {
-    GST_WARNING_OBJECT (webrtc, "Unknown mline %u, ignoring", item->mlineindex);
+    if (drop_invalid) {
+      GST_WARNING_OBJECT (webrtc, "Unknown mline %u, dropping",
+          item->mlineindex);
+    } else {
+      IceCandidateItem *new = g_new0 (IceCandidateItem, 1);
+      new->mlineindex = item->mlineindex;
+      new->candidate = g_strdup (item->candidate);
+
+      g_array_append_val (webrtc->priv->pending_ice_candidates, new);
+      GST_INFO_OBJECT (webrtc, "Unknown mline %u, deferring", item->mlineindex);
+    }
     return;
   }
 
@@ -2451,18 +3385,120 @@ _filter_sdp_fields (GQuark field_id, const GValue * value,
   return TRUE;
 }
 
+static void
+_set_rtx_ptmap_from_stream (GstWebRTCBin * webrtc, TransportStream * stream)
+{
+  gint *rtx_pt;
+  gsize rtx_count;
+
+  rtx_pt = transport_stream_get_all_pt (stream, "RTX", &rtx_count);
+  GST_LOG_OBJECT (stream, "have %" G_GSIZE_FORMAT " rtx payloads", rtx_count);
+  if (rtx_pt) {
+    GstStructure *pt_map = gst_structure_new_empty ("application/x-rtp-pt-map");
+    gsize i;
+
+    for (i = 0; i < rtx_count; i++) {
+      GstCaps *rtx_caps = transport_stream_get_caps_for_pt (stream, rtx_pt[i]);
+      const GstStructure *s = gst_caps_get_structure (rtx_caps, 0);
+      const gchar *apt = gst_structure_get_string (s, "apt");
+
+      GST_LOG_OBJECT (stream, "setting rtx mapping: %s -> %u", apt, rtx_pt[i]);
+      gst_structure_set (pt_map, apt, G_TYPE_UINT, rtx_pt[i], NULL);
+    }
+
+    GST_DEBUG_OBJECT (stream, "setting payload map on %" GST_PTR_FORMAT " : %"
+        GST_PTR_FORMAT " and %" GST_PTR_FORMAT, stream->rtxreceive,
+        stream->rtxsend, pt_map);
+
+    if (stream->rtxreceive)
+      g_object_set (stream->rtxreceive, "payload-type-map", pt_map, NULL);
+    if (stream->rtxsend)
+      g_object_set (stream->rtxsend, "payload-type-map", pt_map, NULL);
+  }
+}
+
+static void
+_update_transport_ptmap_from_media (GstWebRTCBin * webrtc,
+    TransportStream * stream, const GstSDPMessage * sdp, guint media_idx)
+{
+  guint i, len;
+  const gchar *proto;
+  const GstSDPMedia *media = gst_sdp_message_get_media (sdp, media_idx);
+
+  /* get proto */
+  proto = gst_sdp_media_get_proto (media);
+  if (proto != NULL) {
+    /* Parse global SDP attributes once */
+    GstCaps *global_caps = gst_caps_new_empty_simple ("application/x-unknown");
+    GST_DEBUG_OBJECT (webrtc, "mapping sdp session level attributes to caps");
+    gst_sdp_message_attributes_to_caps (sdp, global_caps);
+    GST_DEBUG_OBJECT (webrtc, "mapping sdp media level attributes to caps");
+    gst_sdp_media_attributes_to_caps (media, global_caps);
+
+    len = gst_sdp_media_formats_len (media);
+    for (i = 0; i < len; i++) {
+      GstCaps *caps, *outcaps;
+      GstStructure *s;
+      PtMapItem item;
+      gint pt;
+      guint j;
+
+      pt = atoi (gst_sdp_media_get_format (media, i));
+
+      GST_DEBUG_OBJECT (webrtc, " looking at %d pt: %d", i, pt);
+
+      /* convert caps */
+      caps = gst_sdp_media_get_caps_from_media (media, pt);
+      if (caps == NULL) {
+        GST_WARNING_OBJECT (webrtc, " skipping pt %d without caps", pt);
+        continue;
+      }
+
+      /* Merge in global caps */
+      /* Intersect will merge in missing fields to the current caps */
+      outcaps = gst_caps_intersect (caps, global_caps);
+      gst_caps_unref (caps);
+
+      s = gst_caps_get_structure (outcaps, 0);
+      gst_structure_set_name (s, "application/x-rtp");
+      if (!g_strcmp0 (gst_structure_get_string (s, "encoding-name"), "ULPFEC"))
+        gst_structure_set (s, "is-fec", G_TYPE_BOOLEAN, TRUE, NULL);
+
+      item.caps = gst_caps_new_empty ();
+
+      for (j = 0; j < gst_caps_get_size (outcaps); j++) {
+        GstStructure *s = gst_caps_get_structure (outcaps, j);
+        GstStructure *filtered =
+            gst_structure_new_empty (gst_structure_get_name (s));
+
+        gst_structure_foreach (s,
+            (GstStructureForeachFunc) _filter_sdp_fields, filtered);
+        gst_caps_append_structure (item.caps, filtered);
+      }
+
+      item.pt = pt;
+      gst_caps_unref (outcaps);
+
+      g_array_append_val (stream->ptmap, item);
+    }
+
+    gst_caps_unref (global_caps);
+  }
+}
+
 static void
 _update_transceiver_from_sdp_media (GstWebRTCBin * webrtc,
     const GstSDPMessage * sdp, guint media_idx,
-    GstWebRTCRTPTransceiver * rtp_trans)
+    TransportStream * stream, GstWebRTCRTPTransceiver * rtp_trans,
+    GStrv bundled, guint bundle_idx)
 {
   WebRTCTransceiver *trans = WEBRTC_TRANSCEIVER (rtp_trans);
-  TransportStream *stream = trans->stream;
   GstWebRTCRTPTransceiverDirection prev_dir = rtp_trans->current_direction;
   GstWebRTCRTPTransceiverDirection new_dir;
   const GstSDPMedia *media = gst_sdp_message_get_media (sdp, media_idx);
   GstWebRTCDTLSSetup new_setup;
   gboolean new_rtcp_mux, new_rtcp_rsize;
+  ReceiveState receive_state = 0;
   int i;
 
   rtp_trans->mline = media_idx;
@@ -2472,25 +3508,14 @@ _update_transceiver_from_sdp_media (GstWebRTCBin * webrtc,
 
     if (g_strcmp0 (attr->key, "mid") == 0) {
       g_free (rtp_trans->mid);
-      rtp_trans->mid = g_strdup (attr->value);
-    }
-  }
-
-  if (!stream) {
-    /* FIXME: find an existing transport for e.g. bundle/reconfiguration */
-    stream = _find_transport_for_session (webrtc, media_idx);
-    if (!stream)
-      stream = _create_transport_channel (webrtc, media_idx);
-    webrtc_transceiver_set_transport (trans, stream);
+      rtp_trans->mid = g_strdup (attr->value);
+    }
   }
 
   {
     const GstSDPMedia *local_media, *remote_media;
     GstWebRTCRTPTransceiverDirection local_dir, remote_dir;
     GstWebRTCDTLSSetup local_setup, remote_setup;
-    guint i, len;
-    const gchar *proto;
-    GstCaps *global_caps;
 
     local_media =
         gst_sdp_message_get_media (webrtc->current_local_description->sdp,
@@ -2508,105 +3533,59 @@ _update_transceiver_from_sdp_media (GstWebRTCBin * webrtc,
     local_dir = _get_direction_from_media (local_media);
     remote_dir = _get_direction_from_media (remote_media);
     new_dir = _get_final_direction (local_dir, remote_dir);
+
     if (new_dir == GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_NONE)
       return;
 
-    /* get proto */
-    proto = gst_sdp_media_get_proto (media);
-    if (proto != NULL) {
-      /* Parse global SDP attributes once */
-      global_caps = gst_caps_new_empty_simple ("application/x-unknown");
-      GST_DEBUG_OBJECT (webrtc, "mapping sdp session level attributes to caps");
-      gst_sdp_message_attributes_to_caps (sdp, global_caps);
-      GST_DEBUG_OBJECT (webrtc, "mapping sdp media level attributes to caps");
-      gst_sdp_media_attributes_to_caps (media, global_caps);
-
-      /* clear the ptmap */
-      g_array_set_size (stream->ptmap, 0);
-
-      len = gst_sdp_media_formats_len (media);
-      for (i = 0; i < len; i++) {
-        GstCaps *caps, *outcaps;
-        GstStructure *s;
-        PtMapItem item;
-        gint pt;
-        guint j;
-
-        pt = atoi (gst_sdp_media_get_format (media, i));
-
-        GST_DEBUG_OBJECT (webrtc, " looking at %d pt: %d", i, pt);
-
-        /* convert caps */
-        caps = gst_sdp_media_get_caps_from_media (media, pt);
-        if (caps == NULL) {
-          GST_WARNING_OBJECT (webrtc, " skipping pt %d without caps", pt);
-          continue;
-        }
-
-        /* Merge in global caps */
-        /* Intersect will merge in missing fields to the current caps */
-        outcaps = gst_caps_intersect (caps, global_caps);
-        gst_caps_unref (caps);
-
-        s = gst_caps_get_structure (outcaps, 0);
-        gst_structure_set_name (s, "application/x-rtp");
-        if (!g_strcmp0 (gst_structure_get_string (s, "encoding-name"),
-                "ULPFEC"))
-          gst_structure_set (s, "is-fec", G_TYPE_BOOLEAN, TRUE, NULL);
-
-        item.caps = gst_caps_new_empty ();
-
-        for (j = 0; j < gst_caps_get_size (outcaps); j++) {
-          GstStructure *s = gst_caps_get_structure (outcaps, j);
-          GstStructure *filtered =
-              gst_structure_new_empty (gst_structure_get_name (s));
+    if (prev_dir != GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_NONE
+        && new_dir != GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_INACTIVE
+        && prev_dir != new_dir) {
+      GST_FIXME_OBJECT (webrtc, "implement transceiver direction changes");
+      return;
+    }
 
-          gst_structure_foreach (s,
-              (GstStructureForeachFunc) _filter_sdp_fields, filtered);
-          gst_caps_append_structure (item.caps, filtered);
+    if (!bundled || bundle_idx == media_idx) {
+      new_rtcp_mux = _media_has_attribute_key (local_media, "rtcp-mux")
+          && _media_has_attribute_key (remote_media, "rtcp-mux");
+      new_rtcp_rsize = _media_has_attribute_key (local_media, "rtcp-rsize")
+          && _media_has_attribute_key (remote_media, "rtcp-rsize");
+
+      {
+        GObject *session;
+        g_signal_emit_by_name (webrtc->rtpbin, "get-internal-session",
+            media_idx, &session);
+        if (session) {
+          g_object_set (session, "rtcp-reduced-size", new_rtcp_rsize, NULL);
+          g_object_unref (session);
         }
-
-        item.pt = pt;
-        gst_caps_unref (outcaps);
-
-        g_array_append_val (stream->ptmap, item);
       }
 
-      gst_caps_unref (global_caps);
-    }
-
-    new_rtcp_mux = _media_has_attribute_key (local_media, "rtcp-mux")
-        && _media_has_attribute_key (remote_media, "rtcp-mux");
-    new_rtcp_rsize = _media_has_attribute_key (local_media, "rtcp-rsize")
-        && _media_has_attribute_key (remote_media, "rtcp-rsize");
-
-    {
-      GObject *session;
-      g_signal_emit_by_name (webrtc->rtpbin, "get-internal-session",
-          media_idx, &session);
-      if (session) {
-        g_object_set (session, "rtcp-reduced-size", new_rtcp_rsize, NULL);
-        g_object_unref (session);
-      }
+      g_object_set (stream, "rtcp-mux", new_rtcp_mux, NULL);
     }
   }
 
-  if (prev_dir != GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_NONE
-      && prev_dir != new_dir) {
-    GST_FIXME_OBJECT (webrtc, "implement transceiver direction changes");
-    return;
-  }
-
-  /* FIXME: bundle! */
-  g_object_set (stream, "rtcp-mux", new_rtcp_mux, NULL);
-
   if (new_dir != prev_dir) {
-    TransportReceiveBin *receive;
-
     GST_TRACE_OBJECT (webrtc, "transceiver direction change");
 
-    /* FIXME: this may not always be true. e.g. bundle */
-    g_assert (media_idx == stream->session_id);
+    if (new_dir == GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_INACTIVE) {
+      GstWebRTCBinPad *pad;
+
+      pad = _find_pad_for_mline (webrtc, GST_PAD_SRC, media_idx);
+      if (pad) {
+        GstPad *target = gst_ghost_pad_get_target (GST_GHOST_PAD (pad));
+        if (target) {
+          GstPad *peer = gst_pad_get_peer (target);
+          if (peer) {
+            gst_pad_send_event (peer, gst_event_new_eos ());
+            gst_object_unref (peer);
+          }
+          gst_object_unref (target);
+        }
+        gst_object_unref (pad);
+      }
+
+      /* XXX: send eos event up the sink pad as well? */
+    }
 
     if (new_dir == GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDONLY ||
         new_dir == GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDRECV) {
@@ -2620,15 +3599,12 @@ _update_transceiver_from_sdp_media (GstWebRTCBin * webrtc,
         gst_object_unref (pad);
       } else {
         GST_DEBUG_OBJECT (webrtc,
-            "creating new pad send pad for transceiver %" GST_PTR_FORMAT,
-            trans);
+            "creating new send pad for transceiver %" GST_PTR_FORMAT, trans);
         pad = _create_pad_for_sdp_media (webrtc, GST_PAD_SINK, media_idx);
         pad->trans = gst_object_ref (rtp_trans);
         _connect_input_stream (webrtc, pad);
         _add_pad (webrtc, pad);
       }
-      g_object_set (stream, "dtls-client",
-          new_setup == GST_WEBRTC_DTLS_SETUP_ACTIVE, NULL);
     }
     if (new_dir == GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_RECVONLY ||
         new_dir == GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDRECV) {
@@ -2645,26 +3621,177 @@ _update_transceiver_from_sdp_media (GstWebRTCBin * webrtc,
             "creating new receive pad for transceiver %" GST_PTR_FORMAT, trans);
         pad = _create_pad_for_sdp_media (webrtc, GST_PAD_SRC, media_idx);
         pad->trans = gst_object_ref (rtp_trans);
-        _connect_output_stream (webrtc, pad);
+
+        if (!trans->stream) {
+          TransportStream *item;
+
+          item =
+              _get_or_create_transport_stream (webrtc,
+              bundled ? bundle_idx : media_idx, FALSE);
+          webrtc_transceiver_set_transport (trans, item);
+        }
+
+        _connect_output_stream (webrtc, trans->stream,
+            bundled ? bundle_idx : media_idx);
         /* delay adding the pad until rtpbin creates the recv output pad
          * to ghost to so queries/events travel through the pipeline correctly
          * as soon as the pad is added */
         _add_pad_to_list (webrtc, pad);
       }
-      g_object_set (stream, "dtls-client",
-          new_setup == GST_WEBRTC_DTLS_SETUP_ACTIVE, NULL);
-    }
 
-    receive = TRANSPORT_RECEIVE_BIN (stream->receive_bin);
-    if (new_dir == GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_RECVONLY ||
-        new_dir == GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDRECV)
-      transport_receive_bin_set_receive_state (receive, RECEIVE_STATE_PASS);
-    else
-      transport_receive_bin_set_receive_state (receive, RECEIVE_STATE_DROP);
+      receive_state = RECEIVE_STATE_PASS;
+    } else if (!bundled) {
+      receive_state = RECEIVE_STATE_DROP;
+    }
 
     rtp_trans->mline = media_idx;
     rtp_trans->current_direction = new_dir;
   }
+
+  if (!bundled || bundle_idx == media_idx) {
+    if (stream->rtxsend || stream->rtxreceive) {
+      _set_rtx_ptmap_from_stream (webrtc, stream);
+    }
+
+    g_object_set (stream, "dtls-client",
+        new_setup == GST_WEBRTC_DTLS_SETUP_ACTIVE, NULL);
+  }
+
+  /* Must be after setting the "dtls-client" so that data is not pushed into
+   * the dtlssrtp elements before the ssl direction has been set which will
+   * throw SSL errors */
+  if (receive_state > 0)
+    transport_receive_bin_set_receive_state (stream->receive_bin,
+        receive_state);
+}
+
+/* must be called with the pc lock held */
+static gint
+_generate_data_channel_id (GstWebRTCBin * webrtc)
+{
+  gboolean is_client;
+  gint new_id = -1, max_channels = 0;
+
+  if (webrtc->priv->sctp_transport) {
+    g_object_get (webrtc->priv->sctp_transport, "max-channels", &max_channels,
+        NULL);
+  }
+  if (max_channels <= 0) {
+    max_channels = 65534;
+  }
+
+  g_object_get (webrtc->priv->sctp_transport->transport, "client", &is_client,
+      NULL);
+
+  /* TODO: a better search algorithm */
+  do {
+    GstWebRTCDataChannel *channel;
+
+    new_id++;
+
+    if (new_id < 0 || new_id >= max_channels) {
+      /* exhausted id space */
+      GST_WARNING_OBJECT (webrtc, "Could not find a suitable "
+          "data channel id (max %i)", max_channels);
+      return -1;
+    }
+
+    /* client must generate even ids, server must generate odd ids */
+    if (new_id % 2 == ! !is_client)
+      continue;
+
+    channel = _find_data_channel_for_id (webrtc, new_id);
+    if (!channel)
+      break;
+  } while (TRUE);
+
+  return new_id;
+}
+
+static void
+_update_data_channel_from_sdp_media (GstWebRTCBin * webrtc,
+    const GstSDPMessage * sdp, guint media_idx, TransportStream * stream)
+{
+  const GstSDPMedia *local_media, *remote_media;
+  GstWebRTCDTLSSetup local_setup, remote_setup, new_setup;
+  TransportReceiveBin *receive;
+  int local_port, remote_port;
+  guint64 local_max_size, remote_max_size, max_size;
+  int i;
+
+  local_media =
+      gst_sdp_message_get_media (webrtc->current_local_description->sdp,
+      media_idx);
+  remote_media =
+      gst_sdp_message_get_media (webrtc->current_remote_description->sdp,
+      media_idx);
+
+  local_setup = _get_dtls_setup_from_media (local_media);
+  remote_setup = _get_dtls_setup_from_media (remote_media);
+  new_setup = _get_final_setup (local_setup, remote_setup);
+  if (new_setup == GST_WEBRTC_DTLS_SETUP_NONE)
+    return;
+
+  /* data channel is always rtcp-muxed to avoid generating ICE candidates
+   * for RTCP */
+  g_object_set (stream, "rtcp-mux", TRUE, "dtls-client",
+      new_setup == GST_WEBRTC_DTLS_SETUP_ACTIVE, NULL);
+
+  local_port = _get_sctp_port_from_media (local_media);
+  remote_port = _get_sctp_port_from_media (local_media);
+  if (local_port == -1 || remote_port == -1)
+    return;
+
+  if (0 == (local_max_size =
+          _get_sctp_max_message_size_from_media (local_media)))
+    local_max_size = G_MAXUINT64;
+  if (0 == (remote_max_size =
+          _get_sctp_max_message_size_from_media (remote_media)))
+    remote_max_size = G_MAXUINT64;
+  max_size = MIN (local_max_size, remote_max_size);
+
+  webrtc->priv->sctp_transport->max_message_size = max_size;
+
+  {
+    guint orig_local_port, orig_remote_port;
+
+    /* XXX: sctpassociation warns if we are in the wrong state */
+    g_object_get (webrtc->priv->sctp_transport->sctpdec, "local-sctp-port",
+        &orig_local_port, NULL);
+
+    if (orig_local_port != local_port)
+      g_object_set (webrtc->priv->sctp_transport->sctpdec, "local-sctp-port",
+          local_port, NULL);
+
+    g_object_get (webrtc->priv->sctp_transport->sctpenc, "remote-sctp-port",
+        &orig_remote_port, NULL);
+    if (orig_remote_port != remote_port)
+      g_object_set (webrtc->priv->sctp_transport->sctpenc, "remote-sctp-port",
+          remote_port, NULL);
+  }
+
+  for (i = 0; i < webrtc->priv->data_channels->len; i++) {
+    GstWebRTCDataChannel *channel;
+
+    channel =
+        g_array_index (webrtc->priv->data_channels, GstWebRTCDataChannel *, i);
+
+    if (channel->id == -1)
+      channel->id = _generate_data_channel_id (webrtc);
+    if (channel->id == -1)
+      GST_ELEMENT_WARNING (webrtc, RESOURCE, NOT_FOUND,
+          ("%s", "Failed to generate an identifier for a data channel"), NULL);
+
+    if (webrtc->priv->sctp_transport->association_established
+        && !channel->negotiated && !channel->opened) {
+      gst_webrtc_data_channel_link_to_sctp (channel,
+          webrtc->priv->sctp_transport);
+      gst_webrtc_data_channel_start_negotiation (channel);
+    }
+  }
+
+  receive = TRANSPORT_RECEIVE_BIN (stream->receive_bin);
+  transport_receive_bin_set_receive_state (receive, RECEIVE_STATE_PASS);
 }
 
 static gboolean
@@ -2675,100 +3802,152 @@ _find_compatible_unassociated_transceiver (GstWebRTCRTPTransceiver * p1,
     return FALSE;
   if (p1->mline != -1)
     return FALSE;
+  if (p1->stopped)
+    return FALSE;
 
   return TRUE;
 }
 
+static void
+_connect_rtpfunnel (GstWebRTCBin * webrtc, guint session_id)
+{
+  gchar *pad_name;
+  GstPad *queue_srcpad;
+  GstPad *rtp_sink;
+  TransportStream *stream = _find_transport_for_session (webrtc, session_id);
+  GstElement *queue;
+
+  g_assert (stream);
+
+  if (webrtc->rtpfunnel)
+    goto done;
+
+  webrtc->rtpfunnel = gst_element_factory_make ("rtpfunnel", NULL);
+  gst_bin_add (GST_BIN (webrtc), webrtc->rtpfunnel);
+  gst_element_sync_state_with_parent (webrtc->rtpfunnel);
+
+  queue = gst_element_factory_make ("queue", NULL);
+  gst_bin_add (GST_BIN (webrtc), queue);
+  gst_element_sync_state_with_parent (queue);
+
+  gst_element_link (webrtc->rtpfunnel, queue);
+
+  queue_srcpad = gst_element_get_static_pad (queue, "src");
+
+  pad_name = g_strdup_printf ("send_rtp_sink_%d", session_id);
+  rtp_sink = gst_element_get_request_pad (webrtc->rtpbin, pad_name);
+  g_free (pad_name);
+  gst_pad_link (queue_srcpad, rtp_sink);
+  gst_object_unref (queue_srcpad);
+  gst_object_unref (rtp_sink);
+
+  pad_name = g_strdup_printf ("send_rtp_src_%d", session_id);
+  if (!gst_element_link_pads (GST_ELEMENT (webrtc->rtpbin), pad_name,
+          GST_ELEMENT (stream->send_bin), "rtp_sink"))
+    g_warn_if_reached ();
+  g_free (pad_name);
+
+done:
+  return;
+}
+
 static gboolean
 _update_transceivers_from_sdp (GstWebRTCBin * webrtc, SDPSource source,
     GstWebRTCSessionDescription * sdp)
 {
   int i;
+  gboolean ret = FALSE;
+  GStrv bundled = NULL;
+  guint bundle_idx = 0;
+  TransportStream *bundle_stream = NULL;
+
+  if (!_parse_bundle (sdp->sdp, &bundled))
+    goto done;
+
+  if (bundled) {
+
+    if (!_get_bundle_index (sdp->sdp, bundled, &bundle_idx)) {
+      GST_ERROR_OBJECT (webrtc, "Bundle tag is %s but no media found matching",
+          bundled[0]);
+      goto done;
+    }
+
+    bundle_stream = _get_or_create_transport_stream (webrtc, bundle_idx,
+        _message_media_is_datachannel (sdp->sdp, bundle_idx));
+
+    _connect_rtpfunnel (webrtc, bundle_idx);
+
+    g_array_set_size (bundle_stream->ptmap, 0);
+    for (i = 0; i < gst_sdp_message_medias_len (sdp->sdp); i++) {
+      _update_transport_ptmap_from_media (webrtc, bundle_stream, sdp->sdp, i);
+    }
+  }
 
   for (i = 0; i < gst_sdp_message_medias_len (sdp->sdp); i++) {
     const GstSDPMedia *media = gst_sdp_message_get_media (sdp->sdp, i);
+    TransportStream *stream;
     GstWebRTCRTPTransceiver *trans;
+    guint transport_idx;
 
     /* skip rejected media */
     if (gst_sdp_media_get_port (media) == 0)
       continue;
 
+    if (bundled)
+      transport_idx = bundle_idx;
+    else
+      transport_idx = i;
+
     trans = _find_transceiver_for_sdp_media (webrtc, sdp->sdp, i);
 
+    stream = _get_or_create_transport_stream (webrtc, transport_idx,
+        _message_media_is_datachannel (sdp->sdp, transport_idx));
+    if (!bundled) {
+      g_array_set_size (stream->ptmap, 0);
+      _update_transport_ptmap_from_media (webrtc, stream, sdp->sdp, i);
+    }
+
+    if (trans)
+      webrtc_transceiver_set_transport ((WebRTCTransceiver *) trans, stream);
+
     if (source == SDP_LOCAL && sdp->type == GST_WEBRTC_SDP_TYPE_OFFER && !trans) {
       GST_ERROR ("State mismatch.  Could not find local transceiver by mline.");
-      return FALSE;
+      goto done;
     } else {
-      if (trans) {
-        _update_transceiver_from_sdp_media (webrtc, sdp->sdp, i, trans);
+      if (g_strcmp0 (gst_sdp_media_get_media (media), "audio") == 0 ||
+          g_strcmp0 (gst_sdp_media_get_media (media), "video") == 0) {
+        if (trans) {
+          _update_transceiver_from_sdp_media (webrtc, sdp->sdp, i, stream,
+              trans, bundled, bundle_idx);
+        } else {
+          trans = _find_transceiver (webrtc, NULL,
+              (FindTransceiverFunc) _find_compatible_unassociated_transceiver);
+          /* XXX: default to the advertised direction in the sdp for new
+           * transceviers.  The spec doesn't actually say what happens here, only
+           * that calls to setDirection will change the value.  Nothing about
+           * a default value when the transceiver is created internally */
+          if (!trans) {
+            trans =
+                GST_WEBRTC_RTP_TRANSCEIVER (_create_webrtc_transceiver (webrtc,
+                    _get_direction_from_media (media), i));
+          }
+          _update_transceiver_from_sdp_media (webrtc, sdp->sdp, i, stream,
+              trans, bundled, bundle_idx);
+        }
+      } else if (_message_media_is_datachannel (sdp->sdp, i)) {
+        _update_data_channel_from_sdp_media (webrtc, sdp->sdp, i, stream);
       } else {
-        trans = _find_transceiver (webrtc, NULL,
-            (FindTransceiverFunc) _find_compatible_unassociated_transceiver);
-        /* XXX: default to the advertised direction in the sdp for new
-         * transceviers.  The spec doesn't actually say what happens here, only
-         * that calls to setDirection will change the value.  Nothing about
-         * a default value when the transceiver is created internally */
-        if (!trans)
-          trans =
-              GST_WEBRTC_RTP_TRANSCEIVER (_create_webrtc_transceiver (webrtc,
-                  _get_direction_from_media (media), i));
-        _update_transceiver_from_sdp_media (webrtc, sdp->sdp, i, trans);
+        GST_ERROR_OBJECT (webrtc, "Unknown media type in SDP at index %u", i);
       }
     }
   }
 
-  return TRUE;
-}
-
-static void
-_get_ice_credentials_from_sdp_media (const GstSDPMessage * sdp, guint media_idx,
-    gchar ** ufrag, gchar ** pwd)
-{
-  int i;
-
-  *ufrag = NULL;
-  *pwd = NULL;
-
-  {
-    /* search in the corresponding media section */
-    const GstSDPMedia *media = gst_sdp_message_get_media (sdp, media_idx);
-    const gchar *tmp_ufrag =
-        gst_sdp_media_get_attribute_val (media, "ice-ufrag");
-    const gchar *tmp_pwd = gst_sdp_media_get_attribute_val (media, "ice-pwd");
-    if (tmp_ufrag && tmp_pwd) {
-      *ufrag = g_strdup (tmp_ufrag);
-      *pwd = g_strdup (tmp_pwd);
-      return;
-    }
-  }
+  ret = TRUE;
 
-  /* then in the sdp message itself */
-  for (i = 0; i < gst_sdp_message_attributes_len (sdp); i++) {
-    const GstSDPAttribute *attr = gst_sdp_message_get_attribute (sdp, i);
+done:
+  g_strfreev (bundled);
 
-    if (g_strcmp0 (attr->key, "ice-ufrag") == 0) {
-      g_assert (!*ufrag);
-      *ufrag = g_strdup (attr->value);
-    } else if (g_strcmp0 (attr->key, "ice-pwd") == 0) {
-      g_assert (!*pwd);
-      *pwd = g_strdup (attr->value);
-    }
-  }
-  if (!*ufrag && !*pwd) {
-    /* Check in the medias themselves. According to JSEP, they should be
-     * identical FIXME: only for bundle-d streams */
-    for (i = 0; i < gst_sdp_message_medias_len (sdp); i++) {
-      const GstSDPMedia *media = gst_sdp_message_get_media (sdp, i);
-      const gchar *tmp_ufrag =
-          gst_sdp_media_get_attribute_val (media, "ice-ufrag");
-      const gchar *tmp_pwd = gst_sdp_media_get_attribute_val (media, "ice-pwd");
-      if (tmp_ufrag && tmp_pwd) {
-        *ufrag = g_strdup (tmp_ufrag);
-        *pwd = g_strdup (tmp_pwd);
-        break;
-      }
-    }
-  }
+  return ret;
 }
 
 struct set_description
@@ -2783,7 +3962,11 @@ static void
 _set_description_task (GstWebRTCBin * webrtc, struct set_description *sd)
 {
   GstWebRTCSignalingState new_signaling_state = webrtc->signaling_state;
+  gboolean signalling_state_changed = FALSE;
   GError *error = NULL;
+  GStrv bundled = NULL;
+  guint bundle_idx = 0;
+  guint i;
 
   {
     gchar *state = _enum_value_to_string (GST_TYPE_WEBRTC_SIGNALING_STATE,
@@ -2799,8 +3982,9 @@ _set_description_task (GstWebRTCBin * webrtc, struct set_description *sd)
     g_free (type_str);
   }
 
-  if (!validate_sdp (webrtc, sd->source, sd->sdp, &error)) {
+  if (!validate_sdp (webrtc->signaling_state, sd->source, sd->sdp, &error)) {
     GST_ERROR_OBJECT (webrtc, "%s", error->message);
+    g_clear_error (&error);
     goto out;
   }
 
@@ -2809,6 +3993,17 @@ _set_description_task (GstWebRTCBin * webrtc, struct set_description *sd)
     goto out;
   }
 
+  if (!_parse_bundle (sd->sdp->sdp, &bundled))
+    goto out;
+
+  if (bundled) {
+    if (!_get_bundle_index (sd->sdp->sdp, bundled, &bundle_idx)) {
+      GST_ERROR_OBJECT (webrtc, "Bundle tag is %s but no media found matching",
+          bundled[0]);
+      goto out;
+    }
+  }
+
   switch (sd->sdp->type) {
     case GST_WEBRTC_SDP_TYPE_OFFER:{
       if (sd->source == SDP_LOCAL) {
@@ -2907,27 +4102,9 @@ _set_description_task (GstWebRTCBin * webrtc, struct set_description *sd)
     }
   }
 
-  if (new_signaling_state != webrtc->signaling_state) {
-    gchar *from = _enum_value_to_string (GST_TYPE_WEBRTC_SIGNALING_STATE,
-        webrtc->signaling_state);
-    gchar *to = _enum_value_to_string (GST_TYPE_WEBRTC_SIGNALING_STATE,
-        new_signaling_state);
-    GST_TRACE_OBJECT (webrtc, "notify signaling-state from %s "
-        "to %s", from, to);
-    webrtc->signaling_state = new_signaling_state;
-    PC_UNLOCK (webrtc);
-    g_object_notify (G_OBJECT (webrtc), "signaling-state");
-    PC_LOCK (webrtc);
-
-    g_free (from);
-    g_free (to);
-  }
-
-  /* TODO: necessary data channel modifications */
-
   if (sd->sdp->type == GST_WEBRTC_SDP_TYPE_ROLLBACK) {
     /* FIXME:
-     * If the mid value of an RTCRtpTransceiver was set to a non-null value 
+     * If the mid value of an RTCRtpTransceiver was set to a non-null value
      * by the RTCSessionDescription that is being rolled back, set the mid
      * value of that transceiver to null, as described by [JSEP]
      * (section 4.1.7.2.).
@@ -2941,15 +4118,26 @@ _set_description_task (GstWebRTCBin * webrtc, struct set_description *sd)
      */
   }
 
+  if (webrtc->signaling_state != new_signaling_state) {
+    webrtc->signaling_state = new_signaling_state;
+    signalling_state_changed = TRUE;
+  }
+
   if (webrtc->signaling_state == GST_WEBRTC_SIGNALING_STATE_STABLE) {
     GList *tmp;
-    gboolean prev_need_negotiation = webrtc->priv->need_negotiation;
 
     /* media modifications */
     _update_transceivers_from_sdp (webrtc, sd->source, sd->sdp);
 
     for (tmp = webrtc->priv->pending_sink_transceivers; tmp; tmp = tmp->next) {
       GstWebRTCBinPad *pad = GST_WEBRTC_BIN_PAD (tmp->data);
+      const GstSDPMedia *media;
+
+      media = gst_sdp_message_get_media (sd->sdp->sdp, pad->mlineindex);
+      /* skip rejected media */
+      /* FIXME: arrange for an appropriate flow return */
+      if (gst_sdp_media_get_port (media) == 0)
+        continue;
 
       _connect_input_stream (webrtc, pad);
       gst_pad_remove_probe (GST_PAD (pad), pad->block_id);
@@ -2959,82 +4147,111 @@ _set_description_task (GstWebRTCBin * webrtc, struct set_description *sd)
     g_list_free_full (webrtc->priv->pending_sink_transceivers,
         (GDestroyNotify) gst_object_unref);
     webrtc->priv->pending_sink_transceivers = NULL;
-
-    /* If connection's signaling state is now stable, update the
-     * negotiation-needed flag. If connection's [[ needNegotiation]] slot
-     * was true both before and after this update, queue a task to check
-     * connection's [[needNegotiation]] slot and, if still true, fire a
-     * simple event named negotiationneeded at connection.*/
-    _update_need_negotiation (webrtc);
-    if (prev_need_negotiation && webrtc->priv->need_negotiation) {
-      _check_need_negotiation_task (webrtc, NULL);
-    }
   }
 
-  if (sd->source == SDP_LOCAL) {
-    int i;
+  for (i = 0; i < gst_sdp_message_medias_len (sd->sdp->sdp); i++) {
+    gchar *ufrag, *pwd;
+    TransportStream *item;
 
-    for (i = 0; i < gst_sdp_message_medias_len (sd->sdp->sdp); i++) {
-      gchar *ufrag, *pwd;
-      TransportStream *item;
+    item =
+        _get_or_create_transport_stream (webrtc, bundled ? bundle_idx : i,
+        _message_media_is_datachannel (sd->sdp->sdp, bundled ? bundle_idx : i));
+
+    if (sd->source == SDP_REMOTE) {
+      const GstSDPMedia *media = gst_sdp_message_get_media (sd->sdp->sdp, i);
+      guint j;
+
+      for (j = 0; j < gst_sdp_media_attributes_len (media); j++) {
+        const GstSDPAttribute *attr = gst_sdp_media_get_attribute (media, j);
 
-      /* FIXME: bundle */
-      item = _find_transport_for_session (webrtc, i);
-      if (!item)
-        item = _create_transport_channel (webrtc, i);
+        if (g_strcmp0 (attr->key, "ssrc") == 0) {
+          GStrv split = g_strsplit (attr->value, " ", 0);
+          guint32 ssrc;
 
-      _get_ice_credentials_from_sdp_media (sd->sdp->sdp, i, &ufrag, &pwd);
+          if (split[0] && sscanf (split[0], "%u", &ssrc) && split[1]
+              && g_str_has_prefix (split[1], "cname:")) {
+            SsrcMapItem ssrc_item;
+
+            ssrc_item.media_idx = i;
+            ssrc_item.ssrc = ssrc;
+            g_array_append_val (item->remote_ssrcmap, ssrc_item);
+          }
+          g_strfreev (split);
+        }
+      }
+    }
+
+    if (bundled && bundle_idx != i)
+      continue;
+
+    _get_ice_credentials_from_sdp_media (sd->sdp->sdp, i, &ufrag, &pwd);
+
+    if (sd->source == SDP_LOCAL)
       gst_webrtc_ice_set_local_credentials (webrtc->priv->ice,
           item->stream, ufrag, pwd);
-      g_free (ufrag);
-      g_free (pwd);
-    }
+    else
+      gst_webrtc_ice_set_remote_credentials (webrtc->priv->ice,
+          item->stream, ufrag, pwd);
+    g_free (ufrag);
+    g_free (pwd);
   }
 
-  if (sd->source == SDP_REMOTE) {
-    int i;
+  for (i = 0; i < webrtc->priv->ice_stream_map->len; i++) {
+    IceStreamItem *item =
+        &g_array_index (webrtc->priv->ice_stream_map, IceStreamItem, i);
 
-    for (i = 0; i < gst_sdp_message_medias_len (sd->sdp->sdp); i++) {
-      gchar *ufrag, *pwd;
-      TransportStream *item;
+    gst_webrtc_ice_gather_candidates (webrtc->priv->ice, item->stream);
+  }
 
-      /* FIXME: bundle */
-      item = _find_transport_for_session (webrtc, i);
-      if (!item)
-        item = _create_transport_channel (webrtc, i);
+  if (webrtc->current_local_description && webrtc->current_remote_description) {
+    int i;
 
-      _get_ice_credentials_from_sdp_media (sd->sdp->sdp, i, &ufrag, &pwd);
-      gst_webrtc_ice_set_remote_credentials (webrtc->priv->ice,
-          item->stream, ufrag, pwd);
-      g_free (ufrag);
-      g_free (pwd);
+    for (i = 0; i < webrtc->priv->pending_ice_candidates->len; i++) {
+      IceCandidateItem *item =
+          g_array_index (webrtc->priv->pending_ice_candidates,
+          IceCandidateItem *, i);
+
+      _add_ice_candidate (webrtc, item, TRUE);
     }
+    g_array_set_size (webrtc->priv->pending_ice_candidates, 0);
   }
 
-  {
-    int i;
-    for (i = 0; i < webrtc->priv->ice_stream_map->len; i++) {
-      IceStreamItem *item =
-          &g_array_index (webrtc->priv->ice_stream_map, IceStreamItem, i);
+  /*
+   * If connection's signaling state changed above, fire an event named
+   * signalingstatechange at connection.
+   */
+  if (signalling_state_changed) {
+    gchar *from = _enum_value_to_string (GST_TYPE_WEBRTC_SIGNALING_STATE,
+        webrtc->signaling_state);
+    gchar *to = _enum_value_to_string (GST_TYPE_WEBRTC_SIGNALING_STATE,
+        new_signaling_state);
+    GST_TRACE_OBJECT (webrtc, "notify signaling-state from %s "
+        "to %s", from, to);
+    PC_UNLOCK (webrtc);
+    g_object_notify (G_OBJECT (webrtc), "signaling-state");
+    PC_LOCK (webrtc);
 
-      gst_webrtc_ice_gather_candidates (webrtc->priv->ice, item->stream);
-    }
+    g_free (from);
+    g_free (to);
   }
 
-  if (webrtc->current_local_description && webrtc->current_remote_description) {
-    int i;
-
-    for (i = 0; i < webrtc->priv->pending_ice_candidates->len; i++) {
-      IceCandidateItem *item =
-          g_array_index (webrtc->priv->pending_ice_candidates,
-          IceCandidateItem *, i);
+  if (webrtc->signaling_state == GST_WEBRTC_SIGNALING_STATE_STABLE) {
+    gboolean prev_need_negotiation = webrtc->priv->need_negotiation;
 
-      _add_ice_candidate (webrtc, item);
+    /* If connection's signaling state is now stable, update the
+     * negotiation-needed flag. If connection's [[ needNegotiation]] slot
+     * was true both before and after this update, queue a task to check
+     * connection's [[needNegotiation]] slot and, if still true, fire a
+     * simple event named negotiationneeded at connection.*/
+    _update_need_negotiation (webrtc);
+    if (prev_need_negotiation && webrtc->priv->need_negotiation) {
+      _check_need_negotiation_task (webrtc, NULL);
     }
-    g_array_set_size (webrtc->priv->pending_ice_candidates, 0);
   }
 
 out:
+  g_strfreev (bundled);
+
   PC_UNLOCK (webrtc);
   gst_promise_reply (sd->promise, NULL);
   PC_LOCK (webrtc);
@@ -3118,7 +4335,7 @@ _add_ice_candidate_task (GstWebRTCBin * webrtc, IceCandidateItem * item)
 
     g_array_append_val (webrtc->priv->pending_ice_candidates, new);
   } else {
-    _add_ice_candidate (webrtc, item);
+    _add_ice_candidate (webrtc, item, FALSE);
   }
 }
 
@@ -3170,7 +4387,6 @@ _on_ice_candidate (GstWebRTCICE * ice, guint session_id,
 {
   IceCandidateItem *item = g_new0 (IceCandidateItem, 1);
 
-  /* FIXME: bundle support */
   item->mlineindex = session_id;
   item->candidate = g_strdup (candidate);
 
@@ -3293,6 +4509,36 @@ gst_webrtc_bin_get_transceivers (GstWebRTCBin * webrtc)
   return arr;
 }
 
+static GstWebRTCRTPTransceiver *
+gst_webrtc_bin_get_transceiver (GstWebRTCBin * webrtc, guint idx)
+{
+  GstWebRTCRTPTransceiver *trans = NULL;
+
+  if (idx >= webrtc->priv->transceivers->len) {
+    GST_ERROR_OBJECT (webrtc, "No transceiver for idx %d", idx);
+    goto done;
+  }
+
+  trans =
+      g_array_index (webrtc->priv->transceivers, GstWebRTCRTPTransceiver *,
+      idx);
+  gst_object_ref (trans);
+
+done:
+  return trans;
+}
+
+static gboolean
+gst_webrtc_bin_add_turn_server (GstWebRTCBin * webrtc, const gchar * uri)
+{
+  g_return_val_if_fail (GST_IS_WEBRTC_BIN (webrtc), FALSE);
+  g_return_val_if_fail (uri != NULL, FALSE);
+
+  GST_DEBUG_OBJECT (webrtc, "Adding turn server: %s", uri);
+
+  return gst_webrtc_ice_add_turn_server (webrtc->priv->ice, uri);
+}
+
 static gboolean
 copy_sticky_events (GstPad * pad, GstEvent ** event, gpointer user_data)
 {
@@ -3304,6 +4550,167 @@ copy_sticky_events (GstPad * pad, GstEvent ** event, gpointer user_data)
   return TRUE;
 }
 
+static GstWebRTCDataChannel *
+gst_webrtc_bin_create_data_channel (GstWebRTCBin * webrtc, const gchar * label,
+    GstStructure * init_params)
+{
+  gboolean ordered;
+  gint max_packet_lifetime;
+  gint max_retransmits;
+  const gchar *protocol;
+  gboolean negotiated;
+  gint id;
+  GstWebRTCPriorityType priority;
+  GstWebRTCDataChannel *ret;
+  gint max_channels = 65534;
+
+
+  printf("%s, %d\n", __func__, __LINE__);
+
+  g_return_val_if_fail (GST_IS_WEBRTC_BIN (webrtc), NULL);
+  g_return_val_if_fail (label != NULL, NULL);
+  g_return_val_if_fail (strlen (label) <= 65535, NULL);
+  g_return_val_if_fail (webrtc->priv->is_closed != TRUE, NULL);
+
+  if (!init_params
+      || !gst_structure_get_boolean (init_params, "ordered", &ordered))
+    ordered = TRUE;
+  if (!init_params
+      || !gst_structure_get_int (init_params, "max-packet-lifetime",
+          &max_packet_lifetime))
+    max_packet_lifetime = -1;
+  if (!init_params
+      || !gst_structure_get_int (init_params, "max-retransmits",
+          &max_retransmits))
+    max_retransmits = -1;
+
+  printf("%s, %d\n", __func__, __LINE__);
+
+  /* both retransmits and lifetime cannot be set */
+  g_return_val_if_fail ((max_packet_lifetime == -1)
+      || (max_retransmits == -1), NULL);
+
+  printf("%s, %d\n", __func__, __LINE__);
+
+
+  if (!init_params
+      || !(protocol = gst_structure_get_string (init_params, "protocol")))
+    protocol = "";
+  g_return_val_if_fail (strlen (protocol) <= 65535, NULL);
+
+
+  printf("%s, %d, %p\n", __func__, __LINE__, init_params);
+
+  if (!init_params
+      || !gst_structure_get_boolean (init_params, "negotiated", &negotiated))
+    negotiated = FALSE;
+
+  if (!negotiated || !init_params
+      || !gst_structure_get_int (init_params, "id", &id))
+    id = -1;
+
+  printf("%s, %d, ne: %d, id: %d\n", __func__, __LINE__, negotiated, id);
+
+  if (negotiated)
+    g_return_val_if_fail (id != -1, NULL);
+
+  printf("%s, %d\n", __func__, __LINE__);
+
+  g_return_val_if_fail (id < 65535, NULL);
+
+  if (!init_params
+      || !gst_structure_get_enum (init_params, "priority",
+          GST_TYPE_WEBRTC_PRIORITY_TYPE, (gint *) & priority))
+    priority = GST_WEBRTC_PRIORITY_TYPE_LOW;
+
+
+  printf("%s, %d\n", __func__, __LINE__);
+
+  /* FIXME: clamp max-retransmits and max-packet-lifetime */
+
+  if (webrtc->priv->sctp_transport) {
+    /* Let transport be the connection's [[SctpTransport]] slot.
+     *
+     * If the [[DataChannelId]] slot is not null, transport is in 
+     * connected state and [[DataChannelId]] is greater or equal to the
+     * transport's [[MaxChannels]] slot, throw an OperationError.
+     */
+    g_object_get (webrtc->priv->sctp_transport, "max-channels", &max_channels,
+        NULL);
+
+    printf("%s, %d, id: %d, max: %d\n", __func__, __LINE__, id, max_channels);
+
+    g_return_val_if_fail (id <= max_channels, NULL);
+  }
+
+  if (!_have_nice_elements (webrtc) || !_have_dtls_elements (webrtc) ||
+      !_have_sctp_elements (webrtc)) {
+
+	  printf("%s, %d\n", __func__, __LINE__);
+
+    return NULL;
+  }
+
+  PC_LOCK (webrtc);
+  /* check if the id has been used already */
+  if (id != -1) {
+    GstWebRTCDataChannel *channel = _find_data_channel_for_id (webrtc, id);
+    if (channel) {
+      GST_ELEMENT_WARNING (webrtc, LIBRARY, SETTINGS,
+          ("Attempting to add a data channel with a duplicate ID: %i", id),
+          NULL);
+      PC_UNLOCK (webrtc);
+      return NULL;
+    }
+  } else if (webrtc->current_local_description
+      && webrtc->current_remote_description && webrtc->priv->sctp_transport
+      && webrtc->priv->sctp_transport->transport) {
+    /* else we can only generate an id if we're configured already.  The other
+     * case for generating an id is on sdp setting */
+    id = _generate_data_channel_id (webrtc);
+    if (id == -1) {
+      GST_ELEMENT_WARNING (webrtc, RESOURCE, NOT_FOUND,
+          ("%s", "Failed to generate an identifier for a data channel"), NULL);
+      PC_UNLOCK (webrtc);
+      return NULL;
+    }
+  }
+
+  ret = g_object_new (GST_TYPE_WEBRTC_DATA_CHANNEL, "label", label,
+      "ordered", ordered, "max-packet-lifetime", max_packet_lifetime,
+      "max-retransmits", max_retransmits, "protocol", protocol,
+      "negotiated", negotiated, "id", id, "priority", priority, NULL);
+
+
+  printf("%s, %d\n", __func__, __LINE__);
+
+  if (ret) {
+    gst_bin_add (GST_BIN (webrtc), ret->appsrc);
+    gst_bin_add (GST_BIN (webrtc), ret->appsink);
+
+    gst_element_sync_state_with_parent (ret->appsrc);
+    gst_element_sync_state_with_parent (ret->appsink);
+
+    ret = gst_object_ref (ret);
+    ret->webrtcbin = webrtc;
+    g_array_append_val (webrtc->priv->data_channels, ret);
+    gst_webrtc_data_channel_link_to_sctp (ret, webrtc->priv->sctp_transport);
+    if (webrtc->priv->sctp_transport &&
+        webrtc->priv->sctp_transport->association_established
+        && !ret->negotiated) {
+      gst_webrtc_data_channel_start_negotiation (ret);
+    } else {
+      _update_need_negotiation (webrtc);
+    }
+  }
+
+
+  printf("%s, %d\n", __func__, __LINE__);
+
+  PC_UNLOCK (webrtc);
+  return ret;
+}
+
 /* === rtpbin signal implementations === */
 
 static void
@@ -3320,6 +4727,9 @@ on_rtpbin_pad_added (GstElement * rtpbin, GstPad * new_pad,
     WebRTCTransceiver *trans;
     TransportStream *stream;
     GstWebRTCBinPad *pad;
+    guint media_idx = 0;
+    gboolean found_ssrc = FALSE;
+    guint i;
 
     if (sscanf (new_pad_name, "recv_rtp_src_%u_%u_%u", &session_id, &ssrc,
             &pt) != 3) {
@@ -3331,8 +4741,23 @@ on_rtpbin_pad_added (GstElement * rtpbin, GstPad * new_pad,
     if (!stream)
       g_warn_if_reached ();
 
-    /* FIXME: bundle! */
-    rtp_trans = _find_transceiver_for_mline (webrtc, session_id);
+    media_idx = session_id;
+
+    for (i = 0; i < stream->remote_ssrcmap->len; i++) {
+      SsrcMapItem *item =
+          &g_array_index (stream->remote_ssrcmap, SsrcMapItem, i);
+      if (item->ssrc == ssrc) {
+        media_idx = item->media_idx;
+        found_ssrc = TRUE;
+        break;
+      }
+    }
+
+    if (!found_ssrc) {
+      GST_WARNING_OBJECT (webrtc, "Could not find ssrc %u", ssrc);
+    }
+
+    rtp_trans = _find_transceiver_for_mline (webrtc, media_idx);
     if (!rtp_trans)
       g_warn_if_reached ();
     trans = WEBRTC_TRANSCEIVER (rtp_trans);
@@ -3372,7 +4797,7 @@ on_rtpbin_request_pt_map (GstElement * rtpbin, guint session_id, guint pt,
   if (!stream)
     goto unknown_session;
 
-  if ((ret = _transport_stream_get_caps_for_pt (stream, pt)))
+  if ((ret = transport_stream_get_caps_for_pt (stream, pt)))
     gst_caps_ref (ret);
 
   GST_TRACE_OBJECT (webrtc, "Found caps %" GST_PTR_FORMAT " for pt %d in "
@@ -3392,7 +4817,8 @@ on_rtpbin_request_aux_sender (GstElement * rtpbin, guint session_id,
     GstWebRTCBin * webrtc)
 {
   TransportStream *stream;
-  GstStructure *pt_map = gst_structure_new_empty ("application/x-rtp-pt-map");
+  gboolean have_rtx = FALSE;
+  GstStructure *pt_map = NULL;
   GstElement *ret = NULL;
   GstWebRTCRTPTransceiver *trans;
 
@@ -3400,37 +4826,28 @@ on_rtpbin_request_aux_sender (GstElement * rtpbin, guint session_id,
   trans = _find_transceiver (webrtc, &session_id,
       (FindTransceiverFunc) transceiver_match_for_mline);
 
-  if (stream) {
-    guint i;
-
-    for (i = 0; i < stream->ptmap->len; i++) {
-      PtMapItem *item = &g_array_index (stream->ptmap, PtMapItem, i);
-      if (!gst_caps_is_empty (item->caps)) {
-        GstStructure *s = gst_caps_get_structure (item->caps, 0);
-        gint pt;
-        const gchar *apt_str = gst_structure_get_string (s, "apt");
-
-        if (!apt_str)
-          continue;
+  if (stream)
+    have_rtx = transport_stream_get_pt (stream, "RTX") != 0;
 
-        if (!g_strcmp0 (gst_structure_get_string (s, "encoding-name"), "RTX") &&
-            gst_structure_get_int (s, "payload", &pt)) {
-          gst_structure_set (pt_map, apt_str, G_TYPE_UINT, pt, NULL);
-        }
-      }
-    }
-  }
+  GST_LOG_OBJECT (webrtc, "requesting aux sender for stream %" GST_PTR_FORMAT
+      " with transport %" GST_PTR_FORMAT " and pt map %" GST_PTR_FORMAT, stream,
+      trans, pt_map);
 
-  if (gst_structure_n_fields (pt_map)) {
+  if (have_rtx) {
     GstElement *rtx;
     GstPad *pad;
     gchar *name;
 
+    if (stream->rtxsend) {
+      GST_WARNING_OBJECT (webrtc, "rtprtxsend already created! rtpbin bug?!");
+      goto out;
+    }
+
     GST_INFO ("creating AUX sender");
     ret = gst_bin_new (NULL);
     rtx = gst_element_factory_make ("rtprtxsend", NULL);
-    g_object_set (rtx, "payload-type-map", pt_map, "max-size-packets", 500,
-        NULL);
+    g_object_set (rtx, "max-size-packets", 500, NULL);
+    _set_rtx_ptmap_from_stream (webrtc, stream);
 
     if (WEBRTC_TRANSCEIVER (trans)->local_rtx_ssrc_map)
       g_object_set (rtx, "ssrc-map",
@@ -3449,9 +4866,13 @@ on_rtpbin_request_aux_sender (GstElement * rtpbin, guint session_id,
     gst_element_add_pad (ret, gst_ghost_pad_new (name, pad));
     g_free (name);
     gst_object_unref (pad);
+
+    stream->rtxsend = gst_object_ref (rtx);
   }
 
-  gst_structure_free (pt_map);
+out:
+  if (pt_map)
+    gst_structure_free (pt_map);
 
   return ret;
 }
@@ -3470,29 +4891,31 @@ on_rtpbin_request_aux_receiver (GstElement * rtpbin, guint session_id,
   stream = _find_transport_for_session (webrtc, session_id);
 
   if (stream) {
-    red_pt = _transport_stream_get_pt (stream, "RED");
-    rtx_pt = _transport_stream_get_pt (stream, "RTX");
+    red_pt = transport_stream_get_pt (stream, "RED");
+    rtx_pt = transport_stream_get_pt (stream, "RTX");
   }
 
+  GST_LOG_OBJECT (webrtc, "requesting aux receiver for stream %" GST_PTR_FORMAT,
+      stream);
+
   if (red_pt || rtx_pt)
     ret = gst_bin_new (NULL);
 
   if (rtx_pt) {
-    GstCaps *rtx_caps = _transport_stream_get_caps_for_pt (stream, rtx_pt);
-    GstElement *rtx = gst_element_factory_make ("rtprtxreceive", NULL);
-    GstStructure *pt_map;
-    const GstStructure *s = gst_caps_get_structure (rtx_caps, 0);
+    if (stream->rtxreceive) {
+      GST_WARNING_OBJECT (webrtc,
+          "rtprtxreceive already created! rtpbin bug?!");
+      goto error;
+    }
 
-    gst_bin_add (GST_BIN (ret), rtx);
+    stream->rtxreceive = gst_element_factory_make ("rtprtxreceive", NULL);
+    _set_rtx_ptmap_from_stream (webrtc, stream);
 
-    pt_map = gst_structure_new_empty ("application/x-rtp-pt-map");
-    gst_structure_set (pt_map, gst_structure_get_string (s, "apt"), G_TYPE_UINT,
-        rtx_pt, NULL);
-    g_object_set (rtx, "payload-type-map", pt_map, NULL);
+    gst_bin_add (GST_BIN (ret), stream->rtxreceive);
 
-    sinkpad = gst_element_get_static_pad (rtx, "sink");
+    sinkpad = gst_element_get_static_pad (stream->rtxreceive, "sink");
 
-    prev = rtx;
+    prev = gst_object_ref (stream->rtxreceive);
   }
 
   if (red_pt) {
@@ -3530,7 +4953,13 @@ on_rtpbin_request_aux_receiver (GstElement * rtpbin, guint session_id,
     gst_element_add_pad (ret, ghost);
   }
 
+out:
   return ret;
+
+error:
+  if (ret)
+    gst_object_unref (ret);
+  goto out;
 }
 
 static GstElement *
@@ -3555,7 +4984,7 @@ on_rtpbin_request_fec_decoder (GstElement * rtpbin, guint session_id,
    *   example)
    */
   if (stream)
-    pt = _transport_stream_get_pt (stream, "ULPFEC");
+    pt = transport_stream_get_pt (stream, "ULPFEC");
 
   if (pt) {
     GST_DEBUG_OBJECT (webrtc, "Creating ULPFEC decoder for pt %d in session %u",
@@ -3588,8 +5017,8 @@ on_rtpbin_request_fec_encoder (GstElement * rtpbin, guint session_id,
       (FindTransceiverFunc) transceiver_match_for_mline);
 
   if (stream) {
-    ulpfec_pt = _transport_stream_get_pt (stream, "ULPFEC");
-    red_pt = _transport_stream_get_pt (stream, "RED");
+    ulpfec_pt = transport_stream_get_pt (stream, "ULPFEC");
+    red_pt = transport_stream_get_pt (stream, "RED");
   }
 
   if (ulpfec_pt || red_pt)
@@ -3597,7 +5026,7 @@ on_rtpbin_request_fec_encoder (GstElement * rtpbin, guint session_id,
 
   if (ulpfec_pt) {
     GstElement *fecenc = gst_element_factory_make ("rtpulpfecenc", NULL);
-    GstCaps *caps = _transport_stream_get_caps_for_pt (stream, ulpfec_pt);
+    GstCaps *caps = transport_stream_get_caps_for_pt (stream, ulpfec_pt);
 
     GST_DEBUG_OBJECT (webrtc,
         "Creating ULPFEC encoder for session %d with pt %d", session_id,
@@ -3653,10 +5082,84 @@ on_rtpbin_request_fec_encoder (GstElement * rtpbin, guint session_id,
   return ret;
 }
 
+static void
+on_rtpbin_bye_ssrc (GstElement * rtpbin, guint session_id, guint ssrc,
+    GstWebRTCBin * webrtc)
+{
+  GST_INFO_OBJECT (webrtc, "session %u ssrc %u received bye", session_id, ssrc);
+}
+
+static void
+on_rtpbin_bye_timeout (GstElement * rtpbin, guint session_id, guint ssrc,
+    GstWebRTCBin * webrtc)
+{
+  GST_INFO_OBJECT (webrtc, "session %u ssrc %u bye timeout", session_id, ssrc);
+}
+
+static void
+on_rtpbin_sender_timeout (GstElement * rtpbin, guint session_id, guint ssrc,
+    GstWebRTCBin * webrtc)
+{
+  GST_INFO_OBJECT (webrtc, "session %u ssrc %u sender timeout", session_id,
+      ssrc);
+}
+
+static void
+on_rtpbin_new_ssrc (GstElement * rtpbin, guint session_id, guint ssrc,
+    GstWebRTCBin * webrtc)
+{
+  GST_INFO_OBJECT (webrtc, "session %u ssrc %u new ssrc", session_id, ssrc);
+}
+
 static void
 on_rtpbin_ssrc_active (GstElement * rtpbin, guint session_id, guint ssrc,
     GstWebRTCBin * webrtc)
 {
+  GST_INFO_OBJECT (webrtc, "session %u ssrc %u active", session_id, ssrc);
+}
+
+static void
+on_rtpbin_ssrc_collision (GstElement * rtpbin, guint session_id, guint ssrc,
+    GstWebRTCBin * webrtc)
+{
+  GST_INFO_OBJECT (webrtc, "session %u ssrc %u collision", session_id, ssrc);
+}
+
+static void
+on_rtpbin_ssrc_sdes (GstElement * rtpbin, guint session_id, guint ssrc,
+    GstWebRTCBin * webrtc)
+{
+  GST_INFO_OBJECT (webrtc, "session %u ssrc %u sdes", session_id, ssrc);
+}
+
+static void
+on_rtpbin_ssrc_validated (GstElement * rtpbin, guint session_id, guint ssrc,
+    GstWebRTCBin * webrtc)
+{
+  GST_INFO_OBJECT (webrtc, "session %u ssrc %u validated", session_id, ssrc);
+}
+
+static void
+on_rtpbin_timeout (GstElement * rtpbin, guint session_id, guint ssrc,
+    GstWebRTCBin * webrtc)
+{
+  GST_INFO_OBJECT (webrtc, "session %u ssrc %u timeout", session_id, ssrc);
+}
+
+static void
+on_rtpbin_new_sender_ssrc (GstElement * rtpbin, guint session_id, guint ssrc,
+    GstWebRTCBin * webrtc)
+{
+  GST_INFO_OBJECT (webrtc, "session %u ssrc %u new sender ssrc", session_id,
+      ssrc);
+}
+
+static void
+on_rtpbin_sender_ssrc_active (GstElement * rtpbin, guint session_id, guint ssrc,
+    GstWebRTCBin * webrtc)
+{
+  GST_INFO_OBJECT (webrtc, "session %u ssrc %u sender ssrc active", session_id,
+      ssrc);
 }
 
 static void
@@ -3712,8 +5215,28 @@ _create_rtpbin (GstWebRTCBin * webrtc)
       G_CALLBACK (on_rtpbin_request_fec_decoder), webrtc);
   g_signal_connect (rtpbin, "request-fec-encoder",
       G_CALLBACK (on_rtpbin_request_fec_encoder), webrtc);
+  g_signal_connect (rtpbin, "on-bye-ssrc",
+      G_CALLBACK (on_rtpbin_bye_ssrc), webrtc);
+  g_signal_connect (rtpbin, "on-bye-timeout",
+      G_CALLBACK (on_rtpbin_bye_timeout), webrtc);
+  g_signal_connect (rtpbin, "on-new-ssrc",
+      G_CALLBACK (on_rtpbin_new_ssrc), webrtc);
+  g_signal_connect (rtpbin, "on-new-sender-ssrc",
+      G_CALLBACK (on_rtpbin_new_sender_ssrc), webrtc);
+  g_signal_connect (rtpbin, "on-sender-ssrc-active",
+      G_CALLBACK (on_rtpbin_sender_ssrc_active), webrtc);
+  g_signal_connect (rtpbin, "on-sender-timeout",
+      G_CALLBACK (on_rtpbin_sender_timeout), webrtc);
   g_signal_connect (rtpbin, "on-ssrc-active",
       G_CALLBACK (on_rtpbin_ssrc_active), webrtc);
+  g_signal_connect (rtpbin, "on-ssrc-collision",
+      G_CALLBACK (on_rtpbin_ssrc_collision), webrtc);
+  g_signal_connect (rtpbin, "on-ssrc-sdes",
+      G_CALLBACK (on_rtpbin_ssrc_sdes), webrtc);
+  g_signal_connect (rtpbin, "on-ssrc-validated",
+      G_CALLBACK (on_rtpbin_ssrc_validated), webrtc);
+  g_signal_connect (rtpbin, "on-timeout",
+      G_CALLBACK (on_rtpbin_timeout), webrtc);
   g_signal_connect (rtpbin, "new-jitterbuffer",
       G_CALLBACK (on_rtpbin_new_jitterbuffer), webrtc);
 
@@ -3732,30 +5255,12 @@ gst_webrtc_bin_change_state (GstElement * element, GstStateChange transition)
 
   switch (transition) {
     case GST_STATE_CHANGE_NULL_TO_READY:{
-      GstElement *nice;
-      if (!webrtc->rtpbin) {
-        /* FIXME: is this the right thing for a missing plugin? */
-        GST_ELEMENT_ERROR (webrtc, CORE, MISSING_PLUGIN, (NULL),
-            ("%s", "rtpbin element is not available"));
-        return GST_STATE_CHANGE_FAILURE;
-      }
-      nice = gst_element_factory_make ("nicesrc", NULL);
-      if (!nice) {
-        /* FIXME: is this the right thing for a missing plugin? */
-        GST_ELEMENT_ERROR (webrtc, CORE, MISSING_PLUGIN, (NULL),
-            ("%s", "libnice elements are not available"));
-        return GST_STATE_CHANGE_FAILURE;
-      }
-      gst_object_unref (nice);
-      nice = gst_element_factory_make ("nicesink", NULL);
-      if (!nice) {
-        /* FIXME: is this the right thing for a missing plugin? */
-        GST_ELEMENT_ERROR (webrtc, CORE, MISSING_PLUGIN, (NULL),
-            ("%s", "libnice elements are not available"));
+      if (!_have_nice_elements (webrtc) || !_have_dtls_elements (webrtc))
         return GST_STATE_CHANGE_FAILURE;
-      }
-      gst_object_unref (nice);
+      _start_thread (webrtc);
+      PC_LOCK (webrtc);
       _update_need_negotiation (webrtc);
+      PC_UNLOCK (webrtc);
       break;
     }
     case GST_STATE_CHANGE_READY_TO_PAUSED:
@@ -3780,6 +5285,9 @@ gst_webrtc_bin_change_state (GstElement * element, GstStateChange transition)
     case GST_STATE_CHANGE_PAUSED_TO_READY:
       webrtc->priv->running = FALSE;
       break;
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      _stop_thread (webrtc);
+      break;
     default:
       break;
   }
@@ -3801,26 +5309,10 @@ gst_webrtc_bin_request_new_pad (GstElement * element, GstPadTemplate * templ,
 {
   GstWebRTCBin *webrtc = GST_WEBRTC_BIN (element);
   GstWebRTCBinPad *pad = NULL;
-  GstPluginFeature *feature;
   guint serial;
 
-  feature = gst_registry_lookup_feature (gst_registry_get (), "nicesrc");
-  if (feature) {
-    gst_object_unref (feature);
-  } else {
-    GST_ELEMENT_ERROR (element, CORE, MISSING_PLUGIN, NULL,
-        ("%s", "libnice elements are not available"));
-    return NULL;
-  }
-
-  feature = gst_registry_lookup_feature (gst_registry_get (), "nicesink");
-  if (feature) {
-    gst_object_unref (feature);
-  } else {
-    GST_ELEMENT_ERROR (element, CORE, MISSING_PLUGIN, NULL,
-        ("%s", "libnice elements are not available"));
+  if (!_have_nice_elements (webrtc) || !_have_dtls_elements (webrtc))
     return NULL;
-  }
 
   if (templ->direction == GST_PAD_SINK ||
       g_strcmp0 (templ->name_template, "sink_%u") == 0) {
@@ -3869,6 +5361,9 @@ gst_webrtc_bin_release_pad (GstElement * element, GstPad * pad)
   webrtc_pad->trans = NULL;
 
   _remove_pad (webrtc, webrtc_pad);
+  PC_LOCK (webrtc);
+  _update_need_negotiation (webrtc);
+  PC_UNLOCK (webrtc);
 }
 
 static void
@@ -3882,6 +5377,19 @@ gst_webrtc_bin_set_property (GObject * object, guint prop_id,
     case PROP_TURN_SERVER:
       g_object_set_property (G_OBJECT (webrtc->priv->ice), pspec->name, value);
       break;
+    case PROP_BUNDLE_POLICY:
+      if (g_value_get_enum (value) == GST_WEBRTC_BUNDLE_POLICY_BALANCED) {
+        GST_ERROR_OBJECT (object, "Balanced bundle policy not implemented yet");
+      } else {
+        webrtc->bundle_policy = g_value_get_enum (value);
+      }
+      break;
+    case PROP_ICE_TRANSPORT_POLICY:
+      webrtc->ice_transport_policy = g_value_get_enum (value);
+      g_object_set (webrtc->priv->ice, "force-relay",
+          webrtc->ice_transport_policy ==
+          GST_WEBRTC_ICE_TRANSPORT_POLICY_RELAY ? TRUE : FALSE, NULL);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -3940,6 +5448,12 @@ gst_webrtc_bin_get_property (GObject * object, guint prop_id,
     case PROP_TURN_SERVER:
       g_object_get_property (G_OBJECT (webrtc->priv->ice), pspec->name, value);
       break;
+    case PROP_BUNDLE_POLICY:
+      g_value_set_enum (value, webrtc->bundle_policy);
+      break;
+    case PROP_ICE_TRANSPORT_POLICY:
+      g_value_set_enum (value, webrtc->ice_transport_policy);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -3958,8 +5472,6 @@ gst_webrtc_bin_dispose (GObject * object)
 {
   GstWebRTCBin *webrtc = GST_WEBRTC_BIN (object);
 
-  _stop_thread (webrtc);
-
   if (webrtc->priv->ice)
     gst_object_unref (webrtc->priv->ice);
   webrtc->priv->ice = NULL;
@@ -3968,6 +5480,8 @@ gst_webrtc_bin_dispose (GObject * object)
     g_array_free (webrtc->priv->ice_stream_map, TRUE);
   webrtc->priv->ice_stream_map = NULL;
 
+  g_clear_object (&webrtc->priv->sctp_transport);
+
   G_OBJECT_CLASS (parent_class)->dispose (object);
 }
 
@@ -3984,6 +5498,14 @@ gst_webrtc_bin_finalize (GObject * object)
     g_array_free (webrtc->priv->transceivers, TRUE);
   webrtc->priv->transceivers = NULL;
 
+  if (webrtc->priv->data_channels)
+    g_array_free (webrtc->priv->data_channels, TRUE);
+  webrtc->priv->data_channels = NULL;
+
+  if (webrtc->priv->pending_data_channels)
+    g_array_free (webrtc->priv->pending_data_channels, TRUE);
+  webrtc->priv->pending_data_channels = NULL;
+
   if (webrtc->priv->pending_ice_candidates)
     g_array_free (webrtc->priv->pending_ice_candidates, TRUE);
   webrtc->priv->pending_ice_candidates = NULL;
@@ -4016,6 +5538,13 @@ gst_webrtc_bin_finalize (GObject * object)
     gst_webrtc_session_description_free (webrtc->pending_remote_description);
   webrtc->pending_remote_description = NULL;
 
+  if (webrtc->priv->last_generated_answer)
+    gst_webrtc_session_description_free (webrtc->priv->last_generated_answer);
+  webrtc->priv->last_generated_answer = NULL;
+  if (webrtc->priv->last_generated_offer)
+    gst_webrtc_session_description_free (webrtc->priv->last_generated_offer);
+  webrtc->priv->last_generated_offer = NULL;
+
   if (webrtc->priv->stats)
     gst_structure_free (webrtc->priv->stats);
   webrtc->priv->stats = NULL;
@@ -4032,8 +5561,6 @@ gst_webrtc_bin_class_init (GstWebRTCBinClass * klass)
   GObjectClass *gobject_class = (GObjectClass *) klass;
   GstElementClass *element_class = (GstElementClass *) klass;
 
-  g_type_class_add_private (klass, sizeof (GstWebRTCBinPrivate));
-
   element_class->request_new_pad = gst_webrtc_bin_request_new_pad;
   element_class->release_pad = gst_webrtc_bin_release_pad;
   element_class->change_state = gst_webrtc_bin_change_state;
@@ -4054,16 +5581,58 @@ gst_webrtc_bin_class_init (GstWebRTCBinClass * klass)
   g_object_class_install_property (gobject_class,
       PROP_LOCAL_DESCRIPTION,
       g_param_spec_boxed ("local-description", "Local Description",
-          "The local SDP description to use for this connection",
+          "The local SDP description in use for this connection. "
+          "Favours a pending description over the current description",
           GST_TYPE_WEBRTC_SESSION_DESCRIPTION,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class,
+      PROP_CURRENT_LOCAL_DESCRIPTION,
+      g_param_spec_boxed ("current-local-description",
+          "Current Local Description",
+          "The local description that was successfully negotiated the last time "
+          "the connection transitioned into the stable state",
+          GST_TYPE_WEBRTC_SESSION_DESCRIPTION,
+          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class,
+      PROP_PENDING_LOCAL_DESCRIPTION,
+      g_param_spec_boxed ("pending-local-description",
+          "Pending Local Description",
+          "The local description that is in the process of being negotiated plus "
+          "any local candidates that have been generated by the ICE Agent since the "
+          "offer or answer was created",
+          GST_TYPE_WEBRTC_SESSION_DESCRIPTION,
+          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 
   g_object_class_install_property (gobject_class,
       PROP_REMOTE_DESCRIPTION,
       g_param_spec_boxed ("remote-description", "Remote Description",
-          "The remote SDP description to use for this connection",
+          "The remote SDP description to use for this connection. "
+          "Favours a pending description over the current description",
           GST_TYPE_WEBRTC_SESSION_DESCRIPTION,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class,
+      PROP_CURRENT_REMOTE_DESCRIPTION,
+      g_param_spec_boxed ("current-remote-description",
+          "Current Remote Description",
+          "The last remote description that was successfully negotiated the last "
+          "time the connection transitioned into the stable state plus any remote "
+          "candidates that have been supplied via addIceCandidate() since the offer "
+          "or answer was created",
+          GST_TYPE_WEBRTC_SESSION_DESCRIPTION,
+          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class,
+      PROP_PENDING_REMOTE_DESCRIPTION,
+      g_param_spec_boxed ("pending-remote-description",
+          "Pending Remote Description",
+          "The remote description that is in the process of being negotiated, "
+          "complete with any remote candidates that have been supplied via "
+          "addIceCandidate() since the offer or answer was created",
+          GST_TYPE_WEBRTC_SESSION_DESCRIPTION,
+          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 
   g_object_class_install_property (gobject_class,
       PROP_STUN_SERVER,
@@ -4074,7 +5643,9 @@ gst_webrtc_bin_class_init (GstWebRTCBinClass * klass)
   g_object_class_install_property (gobject_class,
       PROP_TURN_SERVER,
       g_param_spec_string ("turn-server", "TURN Server",
-          "The TURN server of the form turn(s)://username:password@host:port",
+          "The TURN server of the form turn(s)://username:password@host:port. "
+          "This is a convenience property, use #GstWebRTCBin::add-turn-server "
+          "if you wish to use multiple TURN servers",
           NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
   g_object_class_install_property (gobject_class,
@@ -4109,10 +5680,26 @@ gst_webrtc_bin_class_init (GstWebRTCBinClass * klass)
           GST_WEBRTC_ICE_GATHERING_STATE_NEW,
           G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 
+  g_object_class_install_property (gobject_class,
+      PROP_BUNDLE_POLICY,
+      g_param_spec_enum ("bundle-policy", "Bundle Policy",
+          "The policy to apply for bundling",
+          GST_TYPE_WEBRTC_BUNDLE_POLICY,
+          GST_WEBRTC_BUNDLE_POLICY_NONE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class,
+      PROP_ICE_TRANSPORT_POLICY,
+      g_param_spec_enum ("ice-transport-policy", "ICE Transport Policy",
+          "The policy to apply for ICE transport",
+          GST_TYPE_WEBRTC_ICE_TRANSPORT_POLICY,
+          GST_WEBRTC_ICE_TRANSPORT_POLICY_ALL,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   /**
    * GstWebRTCBin::create-offer:
-   * @object: the #GstWebRtcBin
-   * @options: create-offer options
+   * @object: the #webrtcbin
+   * @options: (nullable): create-offer options
    * @promise: a #GstPromise which will contain the offer
    */
   gst_webrtc_bin_signals[CREATE_OFFER_SIGNAL] =
@@ -4124,8 +5711,8 @@ gst_webrtc_bin_class_init (GstWebRTCBinClass * klass)
 
   /**
    * GstWebRTCBin::create-answer:
-   * @object: the #GstWebRtcBin
-   * @options: create-answer options
+   * @object: the #webrtcbin
+   * @options: (nullable): create-answer options
    * @promise: a #GstPromise which will contain the answer
    */
   gst_webrtc_bin_signals[CREATE_ANSWER_SIGNAL] =
@@ -4137,10 +5724,9 @@ gst_webrtc_bin_class_init (GstWebRTCBinClass * klass)
 
   /**
    * GstWebRTCBin::set-local-description:
-   * @object: the #GstWebRtcBin
-   * @type: the type of description being set
-   * @sdp: a #GstSDPMessage description
-   * @promise (allow-none): a #GstPromise to be notified when it's set
+   * @object: the #GstWebRTCBin
+   * @desc: a #GstWebRTCSessionDescription description
+   * @promise: (nullable): a #GstPromise to be notified when it's set
    */
   gst_webrtc_bin_signals[SET_LOCAL_DESCRIPTION_SIGNAL] =
       g_signal_new_class_handler ("set-local-description",
@@ -4151,10 +5737,9 @@ gst_webrtc_bin_class_init (GstWebRTCBinClass * klass)
 
   /**
    * GstWebRTCBin::set-remote-description:
-   * @object: the #GstWebRtcBin
-   * @type: the type of description being set
-   * @sdp: a #GstSDPMessage description
-   * @promise (allow-none): a #GstPromise to be notified when it's set
+   * @object: the #GstWebRTCBin
+   * @desc: a #GstWebRTCSessionDescription description
+   * @promise: (nullable): a #GstPromise to be notified when it's set
    */
   gst_webrtc_bin_signals[SET_REMOTE_DESCRIPTION_SIGNAL] =
       g_signal_new_class_handler ("set-remote-description",
@@ -4165,7 +5750,8 @@ gst_webrtc_bin_class_init (GstWebRTCBinClass * klass)
 
   /**
    * GstWebRTCBin::add-ice-candidate:
-   * @object: the #GstWebRtcBin
+   * @object: the #webrtcbin
+   * @mline_index: the index of the media description in the SDP
    * @ice-candidate: an ice candidate
    */
   gst_webrtc_bin_signals[ADD_ICE_CANDIDATE_SIGNAL] =
@@ -4176,7 +5762,8 @@ gst_webrtc_bin_class_init (GstWebRTCBinClass * klass)
 
   /**
    * GstWebRTCBin::get-stats:
-   * @object: the #GstWebRtcBin
+   * @object: the #webrtcbin
+   * @pad: (nullable): A #GstPad to get the stats for, or %NULL for all
    * @promise: a #GstPromise for the result
    *
    * The @promise will contain the result of retrieving the session statistics.
@@ -4222,7 +5809,7 @@ gst_webrtc_bin_class_init (GstWebRTCBinClass * klass)
    *
    * RTCInboundRTPStreamStats supported fields (https://w3c.github.io/webrtc-stats/#inboundrtpstats-dict*)
    *
-   *  "remote-id"           G_TYPE_STRING               identifier for the associated RTCRemoteOutboundRTPSTreamStats
+   *  "remote-id"           G_TYPE_STRING               identifier for the associated RTCRemoteOutboundRTPStreamStats
    *
    * RTCRemoteInboundRTPStreamStats supported fields (https://w3c.github.io/webrtc-stats/#remoteinboundrtpstats-dict*)
    *
@@ -4252,7 +5839,7 @@ gst_webrtc_bin_class_init (GstWebRTCBinClass * klass)
 
   /**
    * GstWebRTCBin::on-negotiation-needed:
-   * @object: the #GstWebRtcBin
+   * @object: the #webrtcbin
    */
   gst_webrtc_bin_signals[ON_NEGOTIATION_NEEDED_SIGNAL] =
       g_signal_new ("on-negotiation-needed", G_TYPE_FROM_CLASS (klass),
@@ -4261,7 +5848,8 @@ gst_webrtc_bin_class_init (GstWebRTCBinClass * klass)
 
   /**
    * GstWebRTCBin::on-ice-candidate:
-   * @object: the #GstWebRtcBin
+   * @object: the #webrtcbin
+   * @mline_index: the index of the media description in the SDP
    * @candidate: the ICE candidate
    */
   gst_webrtc_bin_signals[ON_ICE_CANDIDATE_SIGNAL] =
@@ -4271,7 +5859,7 @@ gst_webrtc_bin_class_init (GstWebRTCBinClass * klass)
 
   /**
    * GstWebRTCBin::on-new-transceiver:
-   * @object: the #GstWebRtcBin
+   * @object: the #webrtcbin
    * @candidate: the new #GstWebRTCRTPTransceiver
    */
   gst_webrtc_bin_signals[ON_NEW_TRANSCEIVER_SIGNAL] =
@@ -4279,9 +5867,19 @@ gst_webrtc_bin_class_init (GstWebRTCBinClass * klass)
       G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_generic,
       G_TYPE_NONE, 1, GST_TYPE_WEBRTC_RTP_TRANSCEIVER);
 
+  /**
+   * GstWebRTCBin::on-data-channel:
+   * @object: the #GstWebRTCBin
+   * @candidate: the new `GstWebRTCDataChannel`
+   */
+  gst_webrtc_bin_signals[ON_DATA_CHANNEL_SIGNAL] =
+      g_signal_new ("on-data-channel", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_generic,
+      G_TYPE_NONE, 1, GST_TYPE_WEBRTC_DATA_CHANNEL);
+
   /**
    * GstWebRTCBin::add-transceiver:
-   * @object: the #GstWebRtcBin
+   * @object: the #webrtcbin
    * @direction: the direction of the new transceiver
    * @caps: (allow none): the codec preferences for this transceiver
    *
@@ -4296,7 +5894,7 @@ gst_webrtc_bin_class_init (GstWebRTCBinClass * klass)
 
   /**
    * GstWebRTCBin::get-transceivers:
-   * @object: the #GstWebRtcBin
+   * @object: the #webrtcbin
    *
    * Returns: a #GArray of #GstWebRTCRTPTransceivers
    */
@@ -4305,6 +5903,61 @@ gst_webrtc_bin_class_init (GstWebRTCBinClass * klass)
       G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
       G_CALLBACK (gst_webrtc_bin_get_transceivers), NULL, NULL,
       g_cclosure_marshal_generic, G_TYPE_ARRAY, 0);
+
+  /**
+   * GstWebRTCBin::get-transceiver:
+   * @object: the #GstWebRTCBin
+   * @idx: The index of the transceiver
+   *
+   * Returns: (transfer full): the #GstWebRTCRTPTransceiver, or %NULL
+   * Since: 1.16
+   */
+  gst_webrtc_bin_signals[GET_TRANSCEIVER_SIGNAL] =
+      g_signal_new_class_handler ("get-transceiver", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_CALLBACK (gst_webrtc_bin_get_transceiver), NULL, NULL,
+      g_cclosure_marshal_generic, GST_TYPE_WEBRTC_RTP_TRANSCEIVER, 1,
+      G_TYPE_INT);
+
+  /**
+   * GstWebRTCBin::add-turn-server:
+   * @object: the #GstWebRTCBin
+   * @uri: The uri of the server of the form turn(s)://username:password@host:port
+   *
+   * Add a turn server to obtain ICE candidates from
+   */
+  gst_webrtc_bin_signals[ADD_TURN_SERVER_SIGNAL] =
+      g_signal_new_class_handler ("add-turn-server", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_CALLBACK (gst_webrtc_bin_add_turn_server), NULL, NULL,
+      g_cclosure_marshal_generic, G_TYPE_BOOLEAN, 1, G_TYPE_STRING);
+
+  /*
+   * GstWebRTCBin::create-data-channel:
+   * @object: the #GstWebRTCBin
+   * @label: the label for the data channel
+   * @options: a #GstStructure of options for creating the data channel
+   *
+   * The options dictionary is the same format as the RTCDataChannelInit
+   * members outlined https://www.w3.org/TR/webrtc/#dom-rtcdatachannelinit and
+   * and reproduced below
+   *
+   *  ordered               G_TYPE_BOOLEAN        Whether the channal will send data with guarenteed ordering
+   *  max-packet-lifetime   G_TYPE_INT            The time in milliseconds to attempt transmitting unacknowledged data. -1 for unset
+   *  max-retransmits       G_TYPE_INT            The number of times data will be attempted to be transmitted without acknowledgement before dropping
+   *  protocol              G_TYPE_STRING         The subprotocol used by this channel
+   *  negotiated            G_TYPE_BOOLEAN        Whether the created data channel should not perform in-band chnanel announcment.  If %TRUE, then application must negotiate the channel itself and create the corresponding channel on the peer with the same id.
+   *  id                    G_TYPE_INT            Override the default identifier selection of this channel
+   *  priority              GST_TYPE_WEBRTC_PRIORITY_TYPE   The priority to use for this channel
+   *
+   * Returns: (transfer full): a new data channel object
+   */
+  gst_webrtc_bin_signals[CREATE_DATA_CHANNEL_SIGNAL] =
+      g_signal_new_class_handler ("create-data-channel",
+      G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_CALLBACK (gst_webrtc_bin_create_data_channel), NULL, NULL,
+      g_cclosure_marshal_generic, GST_TYPE_WEBRTC_DATA_CHANNEL, 2,
+      G_TYPE_STRING, GST_TYPE_STRUCTURE);
 }
 
 static void
@@ -4341,14 +5994,10 @@ _transport_free (GObject ** object)
 static void
 gst_webrtc_bin_init (GstWebRTCBin * webrtc)
 {
-  webrtc->priv =
-      G_TYPE_INSTANCE_GET_PRIVATE ((webrtc), GST_TYPE_WEBRTC_BIN,
-      GstWebRTCBinPrivate);
+  webrtc->priv = gst_webrtc_bin_get_instance_private (webrtc);
   g_mutex_init (PC_GET_LOCK (webrtc));
   g_cond_init (PC_GET_COND (webrtc));
 
-  _start_thread (webrtc);
-
   webrtc->rtpbin = _create_rtpbin (webrtc);
   gst_bin_add (GST_BIN (webrtc), webrtc->rtpbin);
 
@@ -4360,6 +6009,15 @@ gst_webrtc_bin_init (GstWebRTCBin * webrtc)
   g_array_set_clear_func (webrtc->priv->transports,
       (GDestroyNotify) _transport_free);
 
+  webrtc->priv->data_channels = g_array_new (FALSE, TRUE, sizeof (gpointer));
+  g_array_set_clear_func (webrtc->priv->data_channels,
+      (GDestroyNotify) _deref_and_unref);
+
+  webrtc->priv->pending_data_channels =
+      g_array_new (FALSE, TRUE, sizeof (gpointer));
+  g_array_set_clear_func (webrtc->priv->pending_data_channels,
+      (GDestroyNotify) _deref_and_unref);
+
   webrtc->priv->session_mid_map =
       g_array_new (FALSE, TRUE, sizeof (SessionMidItem));
   g_array_set_clear_func (webrtc->priv->session_mid_map,
@@ -4374,4 +6032,7 @@ gst_webrtc_bin_init (GstWebRTCBin * webrtc)
       g_array_new (FALSE, TRUE, sizeof (IceCandidateItem *));
   g_array_set_clear_func (webrtc->priv->pending_ice_candidates,
       (GDestroyNotify) _clear_ice_candidate_item);
+
+  /* we start off closed until we move to READY */
+  webrtc->priv->is_closed = TRUE;
 }
diff --git a/ext/webrtc/gstwebrtcbin.h b/ext/webrtc/gstwebrtcbin.h
index 49603ec5e..d38e50985 100644
--- a/ext/webrtc/gstwebrtcbin.h
+++ b/ext/webrtc/gstwebrtcbin.h
@@ -23,22 +23,10 @@
 #include <gst/sdp/sdp.h>
 #include "fwd.h"
 #include "gstwebrtcice.h"
+#include "transportstream.h"
 
 G_BEGIN_DECLS
 
-#define GST_WEBRTC_BIN_ERROR gst_webrtc_bin_error_quark ()
-GQuark gst_webrtc_bin_error_quark (void);
-
-typedef enum
-{
-  GST_WEBRTC_BIN_ERROR_FAILED,
-  GST_WEBRTC_BIN_ERROR_INVALID_SYNTAX,
-  GST_WEBRTC_BIN_ERROR_INVALID_MODIFICATION,
-  GST_WEBRTC_BIN_ERROR_INVALID_STATE,
-  GST_WEBRTC_BIN_ERROR_BAD_SDP,
-  GST_WEBRTC_BIN_ERROR_FINGERPRINT,
-} GstWebRTCJSEPSDPError;
-
 GType gst_webrtc_bin_pad_get_type(void);
 #define GST_TYPE_WEBRTC_BIN_PAD            (gst_webrtc_bin_pad_get_type())
 #define GST_WEBRTC_BIN_PAD(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WEBRTC_BIN_PAD,GstWebRTCBinPad))
@@ -80,6 +68,7 @@ struct _GstWebRTCBin
   GstBin                            parent;
 
   GstElement                       *rtpbin;
+  GstElement                       *rtpfunnel;
 
   GstWebRTCSignalingState           signaling_state;
   GstWebRTCICEGatheringState        ice_gathering_state;
@@ -91,6 +80,9 @@ struct _GstWebRTCBin
   GstWebRTCSessionDescription      *current_remote_description;
   GstWebRTCSessionDescription      *pending_remote_description;
 
+  GstWebRTCBundlePolicy             bundle_policy;
+  GstWebRTCICETransportPolicy       ice_transport_policy;
+
   GstWebRTCBinPrivate              *priv;
 };
 
@@ -107,6 +99,13 @@ struct _GstWebRTCBinPrivate
   GArray *transceivers;
   GArray *session_mid_map;
   GArray *transports;
+  GArray *data_channels;
+  /* list of data channels we've received a sctp stream for but no data
+   * channel protocol for */
+  GArray *pending_data_channels;
+
+  GstWebRTCSCTPTransport *sctp_transport;
+  TransportStream *data_channel_transport;
 
   GstWebRTCICE *ice;
   GArray *ice_stream_map;
@@ -115,7 +114,6 @@ struct _GstWebRTCBinPrivate
   /* peerconnection variables */
   gboolean is_closed;
   gboolean need_negotiation;
-  gpointer sctp_transport;      /* FIXME */
 
   /* peerconnection helper thread for promises */
   GMainContext *main_context;
@@ -133,6 +131,10 @@ struct _GstWebRTCBinPrivate
   /* count of the number of media streams we've offered for uniqueness */
   /* FIXME: overflow? */
   guint media_counter;
+  /* the number of times create_offer has been called for the version field */
+  guint offer_count;
+  GstWebRTCSessionDescription *last_generated_offer;
+  GstWebRTCSessionDescription *last_generated_answer;
 
   GstStructure *stats;
 };
diff --git a/ext/webrtc/gstwebrtcice.c b/ext/webrtc/gstwebrtcice.c
index ce30d3b44..17e3f25d3 100644
--- a/ext/webrtc/gstwebrtcice.c
+++ b/ext/webrtc/gstwebrtcice.c
@@ -32,15 +32,11 @@
  * - are locally generated remote candidates meant to be readded to libnice?
  */
 
+static GstUri *_validate_turn_server (GstWebRTCICE * ice, const gchar * s);
+
 #define GST_CAT_DEFAULT gst_webrtc_ice_debug
 GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
 
-#define gst_webrtc_ice_parent_class parent_class
-G_DEFINE_TYPE_WITH_CODE (GstWebRTCICE, gst_webrtc_ice,
-    GST_TYPE_OBJECT,
-    GST_DEBUG_CATEGORY_INIT (gst_webrtc_ice_debug, "webrtcice", 0, "webrtcice");
-    );
-
 GQuark
 gst_webrtc_ice_error_quark (void)
 {
@@ -63,6 +59,7 @@ enum
   PROP_TURN_SERVER,
   PROP_CONTROLLER,
   PROP_AGENT,
+  PROP_FORCE_RELAY,
 };
 
 static guint gst_webrtc_ice_signals[LAST_SIGNAL] = { 0 };
@@ -80,6 +77,12 @@ struct _GstWebRTCICEPrivate
   GCond cond;
 };
 
+#define gst_webrtc_ice_parent_class parent_class
+G_DEFINE_TYPE_WITH_CODE (GstWebRTCICE, gst_webrtc_ice,
+    GST_TYPE_OBJECT, G_ADD_PRIVATE (GstWebRTCICE)
+    GST_DEBUG_CATEGORY_INIT (gst_webrtc_ice_debug, "webrtcice", 0,
+        "webrtcice"););
+
 static gboolean
 _unlock_pc_thread (GMutex * lock)
 {
@@ -292,11 +295,161 @@ _parse_userinfo (const gchar * userinfo, gchar ** user, gchar ** pass)
   *pass = g_strdup (&colon[1]);
 }
 
+static gchar *
+_resolve_host (GstWebRTCICE * ice, const gchar * host)
+{
+  GResolver *resolver = g_resolver_get_default ();
+  GError *error = NULL;
+  GInetAddress *addr;
+  GList *addresses;
+  gchar *address;
+
+  GST_DEBUG_OBJECT (ice, "Resolving host %s", host);
+
+  if (!(addresses = g_resolver_lookup_by_name (resolver, host, NULL, &error))) {
+    GST_ERROR ("%s", error->message);
+    g_clear_error (&error);
+    return NULL;
+  }
+
+  GST_DEBUG_OBJECT (ice, "Resolved %d addresses for host %s",
+      g_list_length (addresses), host);
+
+  /* XXX: only the first address is used */
+  addr = addresses->data;
+  address = g_inet_address_to_string (addr);
+  g_resolver_free_addresses (addresses);
+
+  return address;
+}
+
+static void
+_add_turn_server (GstWebRTCICE * ice, struct NiceStreamItem *item,
+    GstUri * turn_server)
+{
+  gboolean ret;
+  gchar *user, *pass;
+  const gchar *host, *userinfo, *transport, *scheme;
+  NiceRelayType relays[4] = { 0, };
+  int i, relay_n = 0;
+  gchar *ip = NULL;
+
+  host = gst_uri_get_host (turn_server);
+  if (!host) {
+    GST_ERROR_OBJECT (ice, "Turn server has no host");
+    goto out;
+  }
+  ip = _resolve_host (ice, host);
+  if (!ip) {
+    GST_ERROR_OBJECT (ice, "Failed to resolve turn server '%s'", host);
+    goto out;
+  }
+
+  /* Set the resolved IP as the host since that's what libnice wants */
+  gst_uri_set_host (turn_server, ip);
+
+  scheme = gst_uri_get_scheme (turn_server);
+  transport = gst_uri_get_query_value (turn_server, "transport");
+  userinfo = gst_uri_get_userinfo (turn_server);
+  _parse_userinfo (userinfo, &user, &pass);
+
+  if (g_strcmp0 (scheme, "turns") == 0) {
+    relays[relay_n++] = NICE_RELAY_TYPE_TURN_TLS;
+  } else if (g_strcmp0 (scheme, "turn") == 0) {
+    if (!transport || g_strcmp0 (transport, "udp") == 0)
+      relays[relay_n++] = NICE_RELAY_TYPE_TURN_UDP;
+    if (!transport || g_strcmp0 (transport, "tcp") == 0)
+      relays[relay_n++] = NICE_RELAY_TYPE_TURN_TCP;
+  }
+  g_assert (relay_n < G_N_ELEMENTS (relays));
+
+  for (i = 0; i < relay_n; i++) {
+    ret = nice_agent_set_relay_info (ice->priv->nice_agent,
+        item->nice_stream_id, NICE_COMPONENT_TYPE_RTP,
+        gst_uri_get_host (turn_server), gst_uri_get_port (turn_server), user,
+        pass, relays[i]);
+    if (!ret) {
+      gchar *uri = gst_uri_to_string (turn_server);
+      GST_ERROR_OBJECT (ice, "Failed to set TURN server '%s'", uri);
+      g_free (uri);
+      break;
+    }
+    ret = nice_agent_set_relay_info (ice->priv->nice_agent,
+        item->nice_stream_id, NICE_COMPONENT_TYPE_RTCP,
+        gst_uri_get_host (turn_server), gst_uri_get_port (turn_server), user,
+        pass, relays[i]);
+    if (!ret) {
+      gchar *uri = gst_uri_to_string (turn_server);
+      GST_ERROR_OBJECT (ice, "Failed to set TURN server '%s'", uri);
+      g_free (uri);
+      break;
+    }
+  }
+  g_free (user);
+  g_free (pass);
+
+out:
+  g_free (ip);
+}
+
+typedef struct
+{
+  GstWebRTCICE *ice;
+  struct NiceStreamItem *item;
+} AddTurnServerData;
+
+static void
+_add_turn_server_func (const gchar * uri, GstUri * turn_server,
+    AddTurnServerData * data)
+{
+  _add_turn_server (data->ice, data->item, turn_server);
+}
+
+static void
+_add_stun_server (GstWebRTCICE * ice, GstUri * stun_server)
+{
+  const gchar *msg = "must be of the form stun://<host>:<port>";
+  const gchar *host;
+  gchar *s = NULL;
+  gchar *ip = NULL;
+  guint port;
+
+  s = gst_uri_to_string (stun_server);
+  GST_DEBUG_OBJECT (ice, "adding stun server, %s", s);
+
+  host = gst_uri_get_host (stun_server);
+  if (!host) {
+    GST_ERROR_OBJECT (ice, "Stun server '%s' has no host, %s", s, msg);
+    goto out;
+  }
+
+  port = gst_uri_get_port (stun_server);
+  if (port == GST_URI_NO_PORT) {
+    GST_INFO_OBJECT (ice, "Stun server '%s' has no port, assuming 3478", s);
+    port = 3478;
+    gst_uri_set_port (stun_server, port);
+  }
+
+  ip = _resolve_host (ice, host);
+  if (!ip) {
+    GST_ERROR_OBJECT (ice, "Failed to resolve stun server '%s'", host);
+    goto out;
+  }
+
+  g_object_set (ice->priv->nice_agent, "stun-server", ip,
+      "stun-server-port", port, NULL);
+
+out:
+  g_free (s);
+  g_free (ip);
+}
+
 GstWebRTCICEStream *
 gst_webrtc_ice_add_stream (GstWebRTCICE * ice, guint session_id)
 {
   struct NiceStreamItem m = NICE_MATCH_INIT;
   struct NiceStreamItem *item;
+  AddTurnServerData add_data;
 
   m.session_id = session_id;
   item = _nice_stream_item_find (ice, (NiceStreamItemFindFunc) _match, &m);
@@ -306,56 +459,22 @@ gst_webrtc_ice_add_stream (GstWebRTCICE * ice, guint session_id)
     return 0;
   }
 
+  if (ice->stun_server) {
+    _add_stun_server (ice, ice->stun_server);
+  }
+
   item = _create_nice_stream_item (ice, session_id);
 
   if (ice->turn_server) {
-    gboolean ret;
-    gchar *user, *pass;
-    const gchar *userinfo, *transport, *scheme;
-    NiceRelayType relays[4] = { 0, };
-    int i, relay_n = 0;
-
-    scheme = gst_uri_get_scheme (ice->turn_server);
-    transport = gst_uri_get_query_value (ice->turn_server, "transport");
-    userinfo = gst_uri_get_userinfo (ice->turn_server);
-    _parse_userinfo (userinfo, &user, &pass);
-
-    if (g_strcmp0 (scheme, "turns") == 0) {
-      relays[relay_n++] = NICE_RELAY_TYPE_TURN_TLS;
-    } else if (g_strcmp0 (scheme, "turn") == 0) {
-      if (!transport || g_strcmp0 (transport, "udp") == 0)
-        relays[relay_n++] = NICE_RELAY_TYPE_TURN_UDP;
-      if (!transport || g_strcmp0 (transport, "tcp") == 0)
-        relays[relay_n++] = NICE_RELAY_TYPE_TURN_TCP;
-    }
-    g_assert (relay_n < G_N_ELEMENTS (relays));
-
-    for (i = 0; i < relay_n; i++) {
-      ret = nice_agent_set_relay_info (ice->priv->nice_agent,
-          item->nice_stream_id, NICE_COMPONENT_TYPE_RTP,
-          gst_uri_get_host (ice->turn_server),
-          gst_uri_get_port (ice->turn_server), user, pass, relays[i]);
-      if (!ret) {
-        gchar *uri = gst_uri_to_string (ice->turn_server);
-        GST_ERROR_OBJECT (ice, "Failed to set TURN server '%s'", uri);
-        g_free (uri);
-        break;
-      }
-      ret = nice_agent_set_relay_info (ice->priv->nice_agent,
-          item->nice_stream_id, NICE_COMPONENT_TYPE_RTCP,
-          gst_uri_get_host (ice->turn_server),
-          gst_uri_get_port (ice->turn_server), user, pass, relays[i]);
-      if (!ret) {
-        gchar *uri = gst_uri_to_string (ice->turn_server);
-        GST_ERROR_OBJECT (ice, "Failed to set TURN server '%s'", uri);
-        g_free (uri);
-        break;
-      }
-    }
-    g_free (user);
-    g_free (pass);
+    _add_turn_server (ice, item, ice->turn_server);
   }
 
+  add_data.ice = ice;
+  add_data.item = item;
+
+  g_hash_table_foreach (ice->turn_servers, (GHFunc) _add_turn_server_func,
+      &add_data);
+
   return item->stream;
 }
 
@@ -532,6 +651,23 @@ gst_webrtc_ice_set_remote_credentials (GstWebRTCICE * ice,
   return TRUE;
 }
 
+gboolean
+gst_webrtc_ice_add_turn_server (GstWebRTCICE * ice, const gchar * uri)
+{
+  gboolean ret = FALSE;
+  GstUri *valid_uri;
+
+  if (!(valid_uri = _validate_turn_server (ice, uri)))
+    goto done;
+
+  g_hash_table_insert (ice->turn_servers, g_strdup (uri), valid_uri);
+
+  ret = TRUE;
+
+done:
+  return ret;
+}
+
 gboolean
 gst_webrtc_ice_set_local_credentials (GstWebRTCICE * ice,
     GstWebRTCICEStream * stream, gchar * ufrag, gchar * pwd)
@@ -580,41 +716,21 @@ _clear_ice_stream (struct NiceStreamItem *item)
   }
 }
 
-static gchar *
-_resolve_host (const gchar * host)
-{
-  GResolver *resolver = g_resolver_get_default ();
-  GError *error = NULL;
-  GInetAddress *addr;
-  GList *addresses;
-
-  if (!(addresses = g_resolver_lookup_by_name (resolver, host, NULL, &error))) {
-    GST_ERROR ("%s", error->message);
-    g_clear_error (&error);
-    return NULL;
-  }
-
-  /* XXX: only the first address is used */
-  addr = addresses->data;
-
-  return g_inet_address_to_string (addr);
-}
-
-static void
-_set_turn_server (GstWebRTCICE * ice, const gchar * s)
+static GstUri *
+_validate_turn_server (GstWebRTCICE * ice, const gchar * s)
 {
   GstUri *uri = gst_uri_from_string (s);
-  const gchar *userinfo, *host, *scheme;
+  const gchar *userinfo, *scheme;
   GList *keys = NULL, *l;
-  gchar *ip = NULL, *user = NULL, *pass = NULL;
+  gchar *user = NULL, *pass = NULL;
   gboolean turn_tls = FALSE;
   guint port;
 
-  GST_DEBUG_OBJECT (ice, "setting turn server, %s", s);
+  GST_DEBUG_OBJECT (ice, "validating turn server, %s", s);
 
   if (!uri) {
     GST_ERROR_OBJECT (ice, "Could not parse turn server '%s'", s);
-    return;
+    return NULL;
   }
 
   scheme = gst_uri_get_scheme (uri);
@@ -657,16 +773,6 @@ _set_turn_server (GstWebRTCICE * ice, const gchar * s)
     goto out;
   }
 
-  host = gst_uri_get_host (uri);
-  if (!host) {
-    GST_ERROR_OBJECT (ice, "Turn server has no host");
-    goto out;
-  }
-  ip = _resolve_host (host);
-  if (!ip) {
-    GST_ERROR_OBJECT (ice, "Failed to resolve turn server '%s'", host);
-    goto out;
-  }
   port = gst_uri_get_port (uri);
 
   if (port == GST_URI_NO_PORT) {
@@ -676,18 +782,13 @@ _set_turn_server (GstWebRTCICE * ice, const gchar * s)
       gst_uri_set_port (uri, 3478);
     }
   }
-  /* Set the resolved IP as the host since that's what libnice wants */
-  gst_uri_set_host (uri, ip);
-
-  if (ice->turn_server)
-    gst_uri_unref (ice->turn_server);
-  ice->turn_server = uri;
 
 out:
   g_list_free (keys);
-  g_free (ip);
   g_free (user);
   g_free (pass);
+
+  return uri;
 }
 
 static void
@@ -701,9 +802,6 @@ gst_webrtc_ice_set_property (GObject * object, guint prop_id,
       const gchar *s = g_value_get_string (value);
       GstUri *uri = gst_uri_from_string (s);
       const gchar *msg = "must be of the form stun://<host>:<port>";
-      const gchar *host;
-      gchar *ip;
-      guint port;
 
       GST_DEBUG_OBJECT (ice, "setting stun server, %s", s);
 
@@ -712,42 +810,29 @@ gst_webrtc_ice_set_property (GObject * object, guint prop_id,
         return;
       }
 
-      host = gst_uri_get_host (uri);
-      if (!host) {
-        GST_ERROR_OBJECT (ice, "Stun server '%s' has no host, %s", s, msg);
-        return;
-      }
-      port = gst_uri_get_port (uri);
-      if (port == GST_URI_NO_PORT) {
-        GST_INFO_OBJECT (ice, "Stun server '%s' has no port, assuming 3478", s);
-        port = 3478;
-        gst_uri_set_port (uri, port);
-      }
-
-      ip = _resolve_host (host);
-      if (!ip) {
-        GST_ERROR_OBJECT (ice, "Failed to resolve stun server '%s'", host);
-        return;
-      }
-
       if (ice->stun_server)
         gst_uri_unref (ice->stun_server);
       ice->stun_server = uri;
-
-      g_object_set (ice->priv->nice_agent, "stun-server", ip,
-          "stun-server-port", port, NULL);
-
-      g_free (ip);
       break;
     }
     case PROP_TURN_SERVER:{
-      _set_turn_server (ice, g_value_get_string (value));
+      GstUri *uri = _validate_turn_server (ice, g_value_get_string (value));
+
+      if (uri) {
+        if (ice->turn_server)
+          gst_uri_unref (ice->turn_server);
+        ice->turn_server = uri;
+      }
       break;
     }
     case PROP_CONTROLLER:
       g_object_set_property (G_OBJECT (ice->priv->nice_agent),
           "controlling-mode", value);
       break;
+    case PROP_FORCE_RELAY:
+      g_object_set_property (G_OBJECT (ice->priv->nice_agent),
+          "force-relay", value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -780,6 +865,10 @@ gst_webrtc_ice_get_property (GObject * object, guint prop_id,
     case PROP_AGENT:
       g_value_set_object (value, ice->priv->nice_agent);
       break;
+    case PROP_FORCE_RELAY:
+      g_object_get_property (G_OBJECT (ice->priv->nice_agent),
+          "force-relay", value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -807,6 +896,8 @@ gst_webrtc_ice_finalize (GObject * object)
 
   g_object_unref (ice->priv->nice_agent);
 
+  g_hash_table_unref (ice->turn_servers);
+
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
@@ -815,8 +906,6 @@ gst_webrtc_ice_class_init (GstWebRTCICEClass * klass)
 {
   GObjectClass *gobject_class = (GObjectClass *) klass;
 
-  g_type_class_add_private (klass, sizeof (GstWebRTCICEPrivate));
-
   gobject_class->get_property = gst_webrtc_ice_get_property;
   gobject_class->set_property = gst_webrtc_ice_set_property;
   gobject_class->finalize = gst_webrtc_ice_finalize;
@@ -846,9 +935,15 @@ gst_webrtc_ice_class_init (GstWebRTCICEClass * klass)
           "ICE agent in use by this object", NICE_TYPE_AGENT,
           G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 
+  g_object_class_install_property (gobject_class,
+      PROP_FORCE_RELAY,
+      g_param_spec_boolean ("force-relay", "Force Relay",
+          "Force all traffic to go through a relay.", FALSE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   /**
    * GstWebRTCICE::on-ice-candidate:
-   * @object: the #GstWebRtcBin
+   * @object: the #GstWebRTCBin
    * @candidate: the ICE candidate
    */
   gst_webrtc_ice_signals[ON_ICE_CANDIDATE_SIGNAL] =
@@ -860,13 +955,15 @@ gst_webrtc_ice_class_init (GstWebRTCICEClass * klass)
 static void
 gst_webrtc_ice_init (GstWebRTCICE * ice)
 {
-  ice->priv =
-      G_TYPE_INSTANCE_GET_PRIVATE ((ice), GST_TYPE_WEBRTC_ICE,
-      GstWebRTCICEPrivate);
+  ice->priv = gst_webrtc_ice_get_instance_private (ice);
 
   g_mutex_init (&ice->priv->lock);
   g_cond_init (&ice->priv->cond);
 
+  ice->turn_servers =
+      g_hash_table_new_full (g_str_hash, g_str_equal, g_free,
+      (GDestroyNotify) gst_uri_unref);
+
   _start_thread (ice);
 
   ice->priv->nice_agent = nice_agent_new (ice->priv->main_context,
diff --git a/ext/webrtc/gstwebrtcice.h b/ext/webrtc/gstwebrtcice.h
index cacf497a8..4b0cfdce3 100644
--- a/ext/webrtc/gstwebrtcice.h
+++ b/ext/webrtc/gstwebrtcice.h
@@ -48,6 +48,8 @@ struct _GstWebRTCICE
   GstUri                           *stun_server;
   GstUri                           *turn_server;
 
+  GHashTable                       *turn_servers;
+
   GstWebRTCICEPrivate              *priv;
 };
 
@@ -77,6 +79,8 @@ gboolean                    gst_webrtc_ice_set_remote_credentials   (GstWebRTCIC
                                                                      GstWebRTCICEStream * stream,
                                                                      gchar * ufrag,
                                                                      gchar * pwd);
+gboolean                    gst_webrtc_ice_add_turn_server          (GstWebRTCICE * ice,
+                                                                     const gchar * uri);
 
 G_END_DECLS
 
diff --git a/ext/webrtc/gstwebrtcstats.c b/ext/webrtc/gstwebrtcstats.c
index 38a6a02a2..7ecf9b9aa 100644
--- a/ext/webrtc/gstwebrtcstats.c
+++ b/ext/webrtc/gstwebrtcstats.c
@@ -40,8 +40,8 @@ _init_debug (void)
   static gsize _init = 0;
 
   if (g_once_init_enter (&_init)) {
-    GST_DEBUG_CATEGORY_INIT (gst_webrtc_stats_debug, "webrtcice", 0,
-        "webrtcice");
+    GST_DEBUG_CATEGORY_INIT (gst_webrtc_stats_debug, "webrtcstats", 0,
+        "webrtcstats");
     g_once_init_leave (&_init, 1);
   }
 }
@@ -82,6 +82,8 @@ _get_peer_connection_stats (GstWebRTCBin * webrtc)
 }
 
 #define CLOCK_RATE_VALUE_TO_SECONDS(v,r) ((double) v / (double) clock_rate)
+#define FIXED_16_16_TO_DOUBLE(v) ((double) ((v & 0xffff0000) >> 16) + ((v & 0xffff) / 65536.0))
+#define FIXED_32_32_TO_DOUBLE(v) ((double) ((v & G_GUINT64_CONSTANT (0xffffffff00000000)) >> 32) + ((v & G_GUINT64_CONSTANT (0xffffffff)) / 4294967296.0))
 
 /* https://www.w3.org/TR/webrtc-stats/#inboundrtpstats-dict*
    https://www.w3.org/TR/webrtc-stats/#outboundrtpstats-dict* */
@@ -90,52 +92,43 @@ _get_stats_from_rtp_source_stats (GstWebRTCBin * webrtc,
     const GstStructure * source_stats, const gchar * codec_id,
     const gchar * transport_id, GstStructure * s)
 {
-  GstStructure *in, *out, *r_in, *r_out;
-  gchar *in_id, *out_id, *r_in_id, *r_out_id;
   guint ssrc, fir, pli, nack, jitter;
   int lost, clock_rate;
   guint64 packets, bytes;
-  gboolean have_rb = FALSE, sent_rb = FALSE;
+  gboolean internal;
   double ts;
 
   gst_structure_get_double (s, "timestamp", &ts);
-  gst_structure_get_uint (source_stats, "ssrc", &ssrc);
-  gst_structure_get (source_stats, "have-rb", G_TYPE_BOOLEAN, &have_rb,
-      "sent_rb", G_TYPE_BOOLEAN, &sent_rb, "clock-rate", G_TYPE_INT,
-      &clock_rate, NULL);
-
-  in_id = g_strdup_printf ("rtp-inbound-stream-stats_%u", ssrc);
-  out_id = g_strdup_printf ("rtp-outbound-stream-stats_%u", ssrc);
-  r_in_id = g_strdup_printf ("rtp-remote-inbound-stream-stats_%u", ssrc);
-  r_out_id = g_strdup_printf ("rtp-remote-outbound-stream-stats_%u", ssrc);
-
-  in = gst_structure_new_empty (in_id);
-  _set_base_stats (in, GST_WEBRTC_STATS_INBOUND_RTP, ts, in_id);
-
-  /* RTCStreamStats */
-  gst_structure_set (in, "ssrc", G_TYPE_UINT, ssrc, NULL);
-  gst_structure_set (in, "codec-id", G_TYPE_STRING, codec_id, NULL);
-  gst_structure_set (in, "transport-id", G_TYPE_STRING, transport_id, NULL);
-  if (gst_structure_get_uint (source_stats, "recv-fir-count", &fir))
-    gst_structure_set (in, "fir-count", G_TYPE_UINT, fir, NULL);
-  if (gst_structure_get_uint (source_stats, "recv-pli-count", &pli))
-    gst_structure_set (in, "pli-count", G_TYPE_UINT, pli, NULL);
-  if (gst_structure_get_uint (source_stats, "recv-nack-count", &nack))
-    gst_structure_set (in, "nack-count", G_TYPE_UINT, nack, NULL);
-  /* XXX: mediaType, trackId, sliCount, qpSum */
-
-  /* RTCReceivedRTPStreamStats */
-  if (gst_structure_get_uint64 (source_stats, "packets-received", &packets))
-    gst_structure_set (in, "packets-received", G_TYPE_UINT64, packets, NULL);
-  if (gst_structure_get_uint64 (source_stats, "octets-received", &bytes))
-    gst_structure_set (in, "bytes-received", G_TYPE_UINT64, bytes, NULL);
-  if (gst_structure_get_int (source_stats, "packets-lost", &lost))
-    gst_structure_set (in, "packets-lost", G_TYPE_INT, lost, NULL);
-  if (gst_structure_get_uint (source_stats, "jitter", &jitter))
-    gst_structure_set (in, "jitter", G_TYPE_DOUBLE,
-        CLOCK_RATE_VALUE_TO_SECONDS (jitter, clock_rate), NULL);
-/*
-    RTCReceivedRTPStreamStats
+  gst_structure_get (source_stats, "ssrc", G_TYPE_UINT, &ssrc, "clock-rate",
+      G_TYPE_INT, &clock_rate, "internal", G_TYPE_BOOLEAN, &internal, NULL);
+
+  if (internal) {
+    GstStructure *r_in, *out;
+    gchar *out_id, *r_in_id;
+
+    out_id = g_strdup_printf ("rtp-outbound-stream-stats_%u", ssrc);
+    r_in_id = g_strdup_printf ("rtp-remote-inbound-stream-stats_%u", ssrc);
+
+    r_in = gst_structure_new_empty (r_in_id);
+    _set_base_stats (r_in, GST_WEBRTC_STATS_REMOTE_INBOUND_RTP, ts, r_in_id);
+
+    /* RTCStreamStats */
+    gst_structure_set (r_in, "local-id", G_TYPE_STRING, out_id, NULL);
+    gst_structure_set (r_in, "ssrc", G_TYPE_UINT, ssrc, NULL);
+    gst_structure_set (r_in, "codec-id", G_TYPE_STRING, codec_id, NULL);
+    gst_structure_set (r_in, "transport-id", G_TYPE_STRING, transport_id, NULL);
+    /* XXX: mediaType, trackId, sliCount, qpSum */
+
+    if (gst_structure_get_uint64 (source_stats, "packets-received", &packets))
+      gst_structure_set (r_in, "packets-received", G_TYPE_UINT64, packets,
+          NULL);
+    if (gst_structure_get_int (source_stats, "packets-lost", &lost))
+      gst_structure_set (r_in, "packets-lost", G_TYPE_INT, lost, NULL);
+    if (gst_structure_get_uint (source_stats, "jitter", &jitter))
+      gst_structure_set (r_in, "jitter", G_TYPE_DOUBLE,
+          CLOCK_RATE_VALUE_TO_SECONDS (jitter, clock_rate), NULL);
+
+/* XXX: RTCReceivedRTPStreamStats
     double             fractionLost;
     unsigned long      packetsDiscarded;
     unsigned long      packetsFailedDecryption;
@@ -150,33 +143,89 @@ _get_stats_from_rtp_source_stats (GstWebRTCBin * webrtc,
     double             gapDiscardRate;
 */
 
-  /* RTCInboundRTPStreamStats */
-  gst_structure_set (in, "remote-id", G_TYPE_STRING, r_out_id, NULL);
-  /* XXX: framesDecoded, lastPacketReceivedTimestamp */
+    /* RTCRemoteInboundRTPStreamStats */
+    /* XXX: framesDecoded, lastPacketReceivedTimestamp */
 
-  r_in = gst_structure_new_empty (r_in_id);
-  _set_base_stats (r_in, GST_WEBRTC_STATS_REMOTE_INBOUND_RTP, ts, r_in_id);
+    out = gst_structure_new_empty (out_id);
+    _set_base_stats (out, GST_WEBRTC_STATS_OUTBOUND_RTP, ts, out_id);
 
-  /* RTCStreamStats */
-  gst_structure_set (r_in, "ssrc", G_TYPE_UINT, ssrc, NULL);
-  gst_structure_set (r_in, "codec-id", G_TYPE_STRING, codec_id, NULL);
-  gst_structure_set (r_in, "transport-id", G_TYPE_STRING, transport_id, NULL);
-  /* XXX: mediaType, trackId, sliCount, qpSum */
+    /* RTCStreamStats */
+    gst_structure_set (out, "ssrc", G_TYPE_UINT, ssrc, NULL);
+    gst_structure_set (out, "codec-id", G_TYPE_STRING, codec_id, NULL);
+    gst_structure_set (out, "transport-id", G_TYPE_STRING, transport_id, NULL);
+    if (gst_structure_get_uint (source_stats, "sent-fir-count", &fir))
+      gst_structure_set (out, "fir-count", G_TYPE_UINT, fir, NULL);
+    if (gst_structure_get_uint (source_stats, "sent-pli-count", &pli))
+      gst_structure_set (out, "pli-count", G_TYPE_UINT, pli, NULL);
+    if (gst_structure_get_uint (source_stats, "sent-nack-count", &nack))
+      gst_structure_set (out, "nack-count", G_TYPE_UINT, nack, NULL);
+    /* XXX: mediaType, trackId, sliCount, qpSum */
 
-  /* RTCReceivedRTPStreamStats */
-  if (sent_rb) {
-    if (gst_structure_get_uint (source_stats, "sent-rb-jitter", &jitter))
-      gst_structure_set (r_in, "jitter", G_TYPE_DOUBLE,
-          CLOCK_RATE_VALUE_TO_SECONDS (jitter, clock_rate), NULL);
-    if (gst_structure_get_int (source_stats, "sent-rb-packetslost", &lost))
-      gst_structure_set (r_in, "packets-lost", G_TYPE_INT, lost, NULL);
-    /* packetsReceived, bytesReceived */
+/* RTCSentRTPStreamStats */
+    if (gst_structure_get_uint64 (source_stats, "octets-sent", &bytes))
+      gst_structure_set (out, "bytes-sent", G_TYPE_UINT64, bytes, NULL);
+    if (gst_structure_get_uint64 (source_stats, "packets-sent", &packets))
+      gst_structure_set (out, "packets-sent", G_TYPE_UINT64, packets, NULL);
+/* XXX:
+    unsigned long      packetsDiscardedOnSend;
+    unsigned long long bytesDiscardedOnSend;
+*/
+
+    /* RTCOutboundRTPStreamStats */
+    gst_structure_set (out, "remote-id", G_TYPE_STRING, r_in_id, NULL);
+/* XXX:
+    DOMHighResTimeStamp lastPacketSentTimestamp;
+    double              targetBitrate;
+    unsigned long       framesEncoded;
+    double              totalEncodeTime;
+    double              averageRTCPInterval;
+*/
+    gst_structure_set (s, out_id, GST_TYPE_STRUCTURE, out, NULL);
+    gst_structure_set (s, r_in_id, GST_TYPE_STRUCTURE, r_in, NULL);
+
+    gst_structure_free (out);
+    gst_structure_free (r_in);
+
+    g_free (out_id);
+    g_free (r_in_id);
   } else {
-    /* default values */
-    gst_structure_set (r_in, "jitter", G_TYPE_DOUBLE, 0.0, "packets-lost",
-        G_TYPE_INT, 0, NULL);
-  }
-/* XXX: RTCReceivedRTPStreamStats
+    GstStructure *in, *r_out;
+    gchar *r_out_id, *in_id;
+    gboolean have_rb = FALSE, have_sr = FALSE;
+
+    gst_structure_get (source_stats, "have-rb", G_TYPE_BOOLEAN, &have_rb,
+        "have-sr", G_TYPE_BOOLEAN, &have_sr, NULL);
+
+    in_id = g_strdup_printf ("rtp-inbound-stream-stats_%u", ssrc);
+    r_out_id = g_strdup_printf ("rtp-remote-outbound-stream-stats_%u", ssrc);
+
+    in = gst_structure_new_empty (in_id);
+    _set_base_stats (in, GST_WEBRTC_STATS_INBOUND_RTP, ts, in_id);
+
+    /* RTCStreamStats */
+    gst_structure_set (in, "ssrc", G_TYPE_UINT, ssrc, NULL);
+    gst_structure_set (in, "codec-id", G_TYPE_STRING, codec_id, NULL);
+    gst_structure_set (in, "transport-id", G_TYPE_STRING, transport_id, NULL);
+    if (gst_structure_get_uint (source_stats, "recv-fir-count", &fir))
+      gst_structure_set (in, "fir-count", G_TYPE_UINT, fir, NULL);
+    if (gst_structure_get_uint (source_stats, "recv-pli-count", &pli))
+      gst_structure_set (in, "pli-count", G_TYPE_UINT, pli, NULL);
+    if (gst_structure_get_uint (source_stats, "recv-nack-count", &nack))
+      gst_structure_set (in, "nack-count", G_TYPE_UINT, nack, NULL);
+    /* XXX: mediaType, trackId, sliCount, qpSum */
+
+    /* RTCReceivedRTPStreamStats */
+    if (gst_structure_get_uint64 (source_stats, "packets-received", &packets))
+      gst_structure_set (in, "packets-received", G_TYPE_UINT64, packets, NULL);
+    if (gst_structure_get_uint64 (source_stats, "octets-received", &bytes))
+      gst_structure_set (in, "bytes-received", G_TYPE_UINT64, bytes, NULL);
+    if (gst_structure_get_int (source_stats, "packets-lost", &lost))
+      gst_structure_set (in, "packets-lost", G_TYPE_INT, lost, NULL);
+    if (gst_structure_get_uint (source_stats, "jitter", &jitter))
+      gst_structure_set (in, "jitter", G_TYPE_DOUBLE,
+          CLOCK_RATE_VALUE_TO_SECONDS (jitter, clock_rate), NULL);
+/*
+    RTCReceivedRTPStreamStats
     double             fractionLost;
     unsigned long      packetsDiscarded;
     unsigned long      packetsFailedDecryption;
@@ -191,91 +240,65 @@ _get_stats_from_rtp_source_stats (GstWebRTCBin * webrtc,
     double             gapDiscardRate;
 */
 
-  /* RTCRemoteInboundRTPStreamStats */
-  gst_structure_set (r_in, "local-id", G_TYPE_STRING, out_id, NULL);
-  if (have_rb) {
-    guint32 rtt;
-    if (gst_structure_get_uint (source_stats, "rb-round-trip", &rtt)) {
-      /* 16.16 fixed point to double */
-      double val =
-          (double) ((rtt & 0xffff0000) >> 16) + ((rtt & 0xffff) / 65536.0);
-      gst_structure_set (r_in, "round-trip-time", G_TYPE_DOUBLE, val, NULL);
+    /* RTCInboundRTPStreamStats */
+    gst_structure_set (in, "remote-id", G_TYPE_STRING, r_out_id, NULL);
+    /* XXX: framesDecoded, lastPacketReceivedTimestamp */
+
+    r_out = gst_structure_new_empty (r_out_id);
+    _set_base_stats (r_out, GST_WEBRTC_STATS_REMOTE_OUTBOUND_RTP, ts, r_out_id);
+    /* RTCStreamStats */
+    gst_structure_set (r_out, "ssrc", G_TYPE_UINT, ssrc, NULL);
+    gst_structure_set (r_out, "codec-id", G_TYPE_STRING, codec_id, NULL);
+    gst_structure_set (r_out, "transport-id", G_TYPE_STRING, transport_id,
+        NULL);
+    if (have_rb) {
+      guint32 rtt;
+      if (gst_structure_get_uint (source_stats, "rb-round-trip", &rtt)) {
+        /* 16.16 fixed point to double */
+        double val = FIXED_16_16_TO_DOUBLE (rtt);
+        gst_structure_set (r_out, "round-trip-time", G_TYPE_DOUBLE, val, NULL);
+      }
+    } else {
+      /* default values */
+      gst_structure_set (r_out, "round-trip-time", G_TYPE_DOUBLE, 0.0, NULL);
     }
-  } else {
-    /* default values */
-    gst_structure_set (r_in, "round-trip-time", G_TYPE_DOUBLE, 0.0, NULL);
-  }
-  /* XXX: framesDecoded, lastPacketReceivedTimestamp */
-
-  out = gst_structure_new_empty (out_id);
-  _set_base_stats (out, GST_WEBRTC_STATS_OUTBOUND_RTP, ts, out_id);
-
-  /* RTCStreamStats */
-  gst_structure_set (out, "ssrc", G_TYPE_UINT, ssrc, NULL);
-  gst_structure_set (out, "codec-id", G_TYPE_STRING, codec_id, NULL);
-  gst_structure_set (out, "transport-id", G_TYPE_STRING, transport_id, NULL);
-  if (gst_structure_get_uint (source_stats, "sent-fir-count", &fir))
-    gst_structure_set (out, "fir-count", G_TYPE_UINT, fir, NULL);
-  if (gst_structure_get_uint (source_stats, "sent-pli-count", &pli))
-    gst_structure_set (out, "pli-count", G_TYPE_UINT, pli, NULL);
-  if (gst_structure_get_uint (source_stats, "sent-nack-count", &nack))
-    gst_structure_set (out, "nack-count", G_TYPE_UINT, nack, NULL);
-  /* XXX: mediaType, trackId, sliCount, qpSum */
+    /* XXX: mediaType, trackId, sliCount, qpSum */
 
 /* RTCSentRTPStreamStats */
-  if (gst_structure_get_uint64 (source_stats, "octets-sent", &bytes))
-    gst_structure_set (out, "bytes-sent", G_TYPE_UINT64, bytes, NULL);
-  if (gst_structure_get_uint64 (source_stats, "packets-sent", &packets))
-    gst_structure_set (out, "packets-sent", G_TYPE_UINT64, packets, NULL);
+    if (have_sr) {
+      if (gst_structure_get_uint64 (source_stats, "sr-octet-count", &bytes))
+        gst_structure_set (r_out, "bytes-sent", G_TYPE_UINT64, bytes, NULL);
+      if (gst_structure_get_uint64 (source_stats, "sr-packet-count", &packets))
+        gst_structure_set (r_out, "packets-sent", G_TYPE_UINT64, packets, NULL);
+    }
 /* XXX:
     unsigned long      packetsDiscardedOnSend;
     unsigned long long bytesDiscardedOnSend;
 */
 
-  /* RTCOutboundRTPStreamStats */
-  gst_structure_set (out, "remote-id", G_TYPE_STRING, r_in_id, NULL);
-/* XXX:
-    DOMHighResTimeStamp lastPacketSentTimestamp;
-    double              targetBitrate;
-    unsigned long       framesEncoded;
-    double              totalEncodeTime;
-    double              averageRTCPInterval;
-*/
-
-  r_out = gst_structure_new_empty (r_out_id);
-  _set_base_stats (r_out, GST_WEBRTC_STATS_REMOTE_OUTBOUND_RTP, ts, r_out_id);
-  /* RTCStreamStats */
-  gst_structure_set (r_out, "ssrc", G_TYPE_UINT, ssrc, NULL);
-  gst_structure_set (r_out, "codec-id", G_TYPE_STRING, codec_id, NULL);
-  gst_structure_set (r_out, "transport-id", G_TYPE_STRING, transport_id, NULL);
-  /* XXX: mediaType, trackId, sliCount, qpSum */
-
-/* RTCSentRTPStreamStats */
-/*  if (gst_structure_get_uint64 (source_stats, "octets-sent", &bytes))
-    gst_structure_set (r_out, "bytes-sent", G_TYPE_UINT64, bytes, NULL);
-  if (gst_structure_get_uint64 (source_stats, "packets-sent", &packets))
-    gst_structure_set (r_out, "packets-sent", G_TYPE_UINT64, packets, NULL);*/
-/* XXX:
-    unsigned long      packetsDiscardedOnSend;
-    unsigned long long bytesDiscardedOnSend;
-*/
+    if (have_sr) {
+      guint64 ntptime;
+      if (gst_structure_get_uint64 (source_stats, "sr-ntptime", &ntptime)) {
+        /* 16.16 fixed point to double */
+        double val = FIXED_32_32_TO_DOUBLE (ntptime);
+        gst_structure_set (r_out, "remote-timestamp", G_TYPE_DOUBLE, val, NULL);
+      }
+    } else {
+      /* default values */
+      gst_structure_set (r_out, "remote-timestamp", G_TYPE_DOUBLE, 0.0, NULL);
+    }
 
-  gst_structure_set (r_out, "local-id", G_TYPE_STRING, in_id, NULL);
+    gst_structure_set (r_out, "local-id", G_TYPE_STRING, in_id, NULL);
 
-  gst_structure_set (s, in_id, GST_TYPE_STRUCTURE, in, NULL);
-  gst_structure_set (s, out_id, GST_TYPE_STRUCTURE, out, NULL);
-  gst_structure_set (s, r_in_id, GST_TYPE_STRUCTURE, r_in, NULL);
-  gst_structure_set (s, r_out_id, GST_TYPE_STRUCTURE, r_out, NULL);
+    gst_structure_set (s, in_id, GST_TYPE_STRUCTURE, in, NULL);
+    gst_structure_set (s, r_out_id, GST_TYPE_STRUCTURE, r_out, NULL);
 
-  gst_structure_free (in);
-  gst_structure_free (out);
-  gst_structure_free (r_in);
-  gst_structure_free (r_out);
+    gst_structure_free (in);
+    gst_structure_free (r_out);
 
-  g_free (in_id);
-  g_free (out_id);
-  g_free (r_in_id);
-  g_free (r_out_id);
+    g_free (in_id);
+    g_free (r_out_id);
+  }
 }
 
 /* https://www.w3.org/TR/webrtc-stats/#candidatepair-dict* */
@@ -353,6 +376,7 @@ _get_stats_from_dtls_transport (GstWebRTCBin * webrtc,
   GstStructure *stats;
   gchar *id;
   double ts;
+  gchar *ice_id;
 
   gst_structure_get_double (s, "timestamp", &ts);
 
@@ -395,14 +419,16 @@ _get_stats_from_dtls_transport (GstWebRTCBin * webrtc,
   gst_structure_set (s, id, GST_TYPE_STRUCTURE, stats, NULL);
   gst_structure_free (stats);
 
-  _get_stats_from_ice_transport (webrtc, transport->transport, s);
+  ice_id = _get_stats_from_ice_transport (webrtc, transport->transport, s);
+  g_free (ice_id);
 
   return id;
 }
 
 static void
 _get_stats_from_transport_channel (GstWebRTCBin * webrtc,
-    TransportStream * stream, const gchar * codec_id, GstStructure * s)
+    TransportStream * stream, const gchar * codec_id, guint ssrc,
+    GstStructure * s)
 {
   GstWebRTCDTLSTransport *transport;
   GObject *rtp_session;
@@ -438,13 +464,13 @@ _get_stats_from_transport_channel (GstWebRTCBin * webrtc,
   for (i = 0; i < source_stats->n_values; i++) {
     const GstStructure *stats;
     const GValue *val = g_value_array_get_nth (source_stats, i);
-    gboolean internal;
+    guint stats_ssrc = 0;
 
     stats = gst_value_get_structure (val);
 
-    /* skip internal sources */
-    gst_structure_get (stats, "internal", G_TYPE_BOOLEAN, &internal, NULL);
-    if (internal)
+    /* skip foreign sources */
+    gst_structure_get (stats, "ssrc", G_TYPE_UINT, &stats_ssrc, NULL);
+    if (ssrc && stats_ssrc && ssrc != stats_ssrc)
       continue;
 
     _get_stats_from_rtp_source_stats (webrtc, stats, codec_id, transport_id, s);
@@ -457,14 +483,15 @@ _get_stats_from_transport_channel (GstWebRTCBin * webrtc,
 }
 
 /* https://www.w3.org/TR/webrtc-stats/#codec-dict* */
-static gchar *
+static void
 _get_codec_stats_from_pad (GstWebRTCBin * webrtc, GstPad * pad,
-    GstStructure * s)
+    GstStructure * s, gchar ** out_id, guint * out_ssrc)
 {
   GstStructure *stats;
   GstCaps *caps;
   gchar *id;
   double ts;
+  guint ssrc = 0;
 
   gst_structure_get_double (s, "timestamp", &ts);
 
@@ -483,6 +510,9 @@ _get_codec_stats_from_pad (GstWebRTCBin * webrtc, GstPad * pad,
     if (gst_structure_get_int (caps_s, "clock-rate", &clock_rate))
       gst_structure_set (stats, "clock-rate", G_TYPE_UINT, clock_rate, NULL);
 
+    if (gst_structure_get_uint (caps_s, "ssrc", &ssrc))
+      gst_structure_set (stats, "ssrc", G_TYPE_UINT, ssrc, NULL);
+
     /* FIXME: codecType, mimeType, channels, sdpFmtpLine, implementation, transportId */
   }
 
@@ -492,25 +522,36 @@ _get_codec_stats_from_pad (GstWebRTCBin * webrtc, GstPad * pad,
   gst_structure_set (s, id, GST_TYPE_STRUCTURE, stats, NULL);
   gst_structure_free (stats);
 
-  return id;
+  if (out_id)
+    *out_id = id;
+  else
+    g_free (id);
+
+  if (out_ssrc)
+    *out_ssrc = ssrc;
 }
 
 static gboolean
 _get_stats_from_pad (GstWebRTCBin * webrtc, GstPad * pad, GstStructure * s)
 {
   GstWebRTCBinPad *wpad = GST_WEBRTC_BIN_PAD (pad);
+  TransportStream *stream;
   gchar *codec_id;
+  guint ssrc;
 
-  codec_id = _get_codec_stats_from_pad (webrtc, pad, s);
-  if (wpad->trans) {
-    WebRTCTransceiver *trans;
-    trans = WEBRTC_TRANSCEIVER (wpad->trans);
-    if (trans->stream)
-      _get_stats_from_transport_channel (webrtc, trans->stream, codec_id, s);
-  }
+  _get_codec_stats_from_pad (webrtc, pad, s, &codec_id, &ssrc);
 
-  g_free (codec_id);
+  if (!wpad->trans)
+    goto out;
 
+  stream = WEBRTC_TRANSCEIVER (wpad->trans)->stream;
+  if (!stream)
+    goto out;
+
+  _get_stats_from_transport_channel (webrtc, stream, codec_id, ssrc, s);
+
+out:
+  g_free (codec_id);
   return TRUE;
 }
 
diff --git a/ext/webrtc/icestream.c b/ext/webrtc/icestream.c
index dd4852468..e51af7044 100644
--- a/ext/webrtc/icestream.c
+++ b/ext/webrtc/icestream.c
@@ -27,12 +27,6 @@
 #define GST_CAT_DEFAULT gst_webrtc_ice_stream_debug
 GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
 
-#define gst_webrtc_ice_stream_parent_class parent_class
-G_DEFINE_TYPE_WITH_CODE (GstWebRTCICEStream, gst_webrtc_ice_stream,
-    GST_TYPE_OBJECT,
-    GST_DEBUG_CATEGORY_INIT (gst_webrtc_ice_stream_debug,
-        "webrtcicestream", 0, "webrtcicestream"););
-
 enum
 {
   SIGNAL_0,
@@ -54,6 +48,12 @@ struct _GstWebRTCICEStreamPrivate
   GList *transports;
 };
 
+#define gst_webrtc_ice_stream_parent_class parent_class
+G_DEFINE_TYPE_WITH_CODE (GstWebRTCICEStream, gst_webrtc_ice_stream,
+    GST_TYPE_OBJECT, G_ADD_PRIVATE (GstWebRTCICEStream)
+    GST_DEBUG_CATEGORY_INIT (gst_webrtc_ice_stream_debug,
+        "webrtcicestream", 0, "webrtcicestream"););
+
 static void
 gst_webrtc_ice_stream_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec)
@@ -201,8 +201,6 @@ gst_webrtc_ice_stream_class_init (GstWebRTCICEStreamClass * klass)
 {
   GObjectClass *gobject_class = (GObjectClass *) klass;
 
-  g_type_class_add_private (klass, sizeof (GstWebRTCICEStreamPrivate));
-
   gobject_class->constructed = gst_webrtc_ice_stream_constructed;
   gobject_class->get_property = gst_webrtc_ice_stream_get_property;
   gobject_class->set_property = gst_webrtc_ice_stream_set_property;
@@ -226,9 +224,7 @@ gst_webrtc_ice_stream_class_init (GstWebRTCICEStreamClass * klass)
 static void
 gst_webrtc_ice_stream_init (GstWebRTCICEStream * ice)
 {
-  ice->priv =
-      G_TYPE_INSTANCE_GET_PRIVATE ((ice), GST_TYPE_WEBRTC_ICE_STREAM,
-      GstWebRTCICEStreamPrivate);
+  ice->priv = gst_webrtc_ice_stream_get_instance_private (ice);
 }
 
 GstWebRTCICEStream *
diff --git a/ext/webrtc/meson.build b/ext/webrtc/meson.build
index c98bd0d89..3e7a5d1d8 100644
--- a/ext/webrtc/meson.build
+++ b/ext/webrtc/meson.build
@@ -4,6 +4,7 @@ webrtc_sources = [
   'gstwebrtcstats.c',
   'icestream.c',
   'nicetransport.c',
+  'sctptransport.c',
   'gstwebrtcbin.c',
   'transportreceivebin.c',
   'transportsendbin.c',
@@ -11,17 +12,23 @@ webrtc_sources = [
   'utils.c',
   'webrtcsdp.c',
   'webrtctransceiver.c',
+  'webrtcdatachannel.c',
 ]
 
-libnice_dep = dependency('nice', version : '>=0.1.14', required : false)
+libnice_dep = dependency('nice', version : '>=0.1.14', required : get_option('webrtc'),
+                         fallback : ['libnice', 'libnice_dep'],
+                         default_options: ['tests=disabled'])
 
 if libnice_dep.found()
-  library('gstwebrtc',
+  gstwebrtc_plugin = library('gstwebrtc',
     webrtc_sources,
     c_args : gst_plugins_bad_args + ['-DGST_USE_UNSTABLE_API'],
     include_directories : [configinc],
-    dependencies : [libnice_dep, gstbase_dep, gstsdp_dep, gstwebrtc_dep],
+    dependencies : [gio_dep, libnice_dep, gstbase_dep, gstsdp_dep,
+                    gstapp_dep, gstwebrtc_dep, gstsctp_dep],
     install : true,
     install_dir : plugins_install_dir,
   )
+  pkgconfig.generate(gstwebrtc_plugin, install_dir : plugins_pkgconfig_install_dir)
+  plugins += [gstwebrtc_plugin]
 endif
diff --git a/ext/webrtc/nicetransport.c b/ext/webrtc/nicetransport.c
index 2365cfd52..5e7f30e71 100644
--- a/ext/webrtc/nicetransport.c
+++ b/ext/webrtc/nicetransport.c
@@ -27,13 +27,6 @@
 #define GST_CAT_DEFAULT gst_webrtc_nice_transport_debug
 GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
 
-#define gst_webrtc_nice_transport_parent_class parent_class
-G_DEFINE_TYPE_WITH_CODE (GstWebRTCNiceTransport, gst_webrtc_nice_transport,
-    GST_TYPE_WEBRTC_ICE_TRANSPORT,
-    GST_DEBUG_CATEGORY_INIT (gst_webrtc_nice_transport_debug,
-        "webrtcnicetransport", 0, "webrtcnicetransport");
-    );
-
 enum
 {
   SIGNAL_0,
@@ -53,6 +46,13 @@ struct _GstWebRTCNiceTransportPrivate
   gboolean running;
 };
 
+#define gst_webrtc_nice_transport_parent_class parent_class
+G_DEFINE_TYPE_WITH_CODE (GstWebRTCNiceTransport, gst_webrtc_nice_transport,
+    GST_TYPE_WEBRTC_ICE_TRANSPORT, G_ADD_PRIVATE (GstWebRTCNiceTransport)
+    GST_DEBUG_CATEGORY_INIT (gst_webrtc_nice_transport_debug,
+        "webrtcnicetransport", 0, "webrtcnicetransport");
+    );
+
 static NiceComponentType
 _gst_component_to_nice (GstWebRTCICEComponent component)
 {
@@ -236,8 +236,6 @@ gst_webrtc_nice_transport_class_init (GstWebRTCNiceTransportClass * klass)
 {
   GObjectClass *gobject_class = (GObjectClass *) klass;
 
-  g_type_class_add_private (klass, sizeof (GstWebRTCNiceTransportPrivate));
-
   gobject_class->constructed = gst_webrtc_nice_transport_constructed;
   gobject_class->get_property = gst_webrtc_nice_transport_get_property;
   gobject_class->set_property = gst_webrtc_nice_transport_set_property;
@@ -254,9 +252,7 @@ gst_webrtc_nice_transport_class_init (GstWebRTCNiceTransportClass * klass)
 static void
 gst_webrtc_nice_transport_init (GstWebRTCNiceTransport * nice)
 {
-  nice->priv =
-      G_TYPE_INSTANCE_GET_PRIVATE ((nice), GST_TYPE_WEBRTC_NICE_TRANSPORT,
-      GstWebRTCNiceTransportPrivate);
+  nice->priv = gst_webrtc_nice_transport_get_instance_private (nice);
 }
 
 GstWebRTCNiceTransport *
diff --git a/ext/webrtc/sctptransport.c b/ext/webrtc/sctptransport.c
new file mode 100644
index 000000000..f5643e9fe
--- /dev/null
+++ b/ext/webrtc/sctptransport.c
@@ -0,0 +1,270 @@
+/* GStreamer
+ * Copyright (C) 2018 Matthew Waters <matthew@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <stdio.h>
+
+#include "sctptransport.h"
+#include "gstwebrtcbin.h"
+
+#define GST_CAT_DEFAULT gst_webrtc_sctp_transport_debug
+GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
+
+enum
+{
+  SIGNAL_0,
+  ON_RESET_STREAM_SIGNAL,
+  LAST_SIGNAL,
+};
+
+enum
+{
+  PROP_0,
+  PROP_TRANSPORT,
+  PROP_STATE,
+  PROP_MAX_MESSAGE_SIZE,
+  PROP_MAX_CHANNELS,
+};
+
+static guint gst_webrtc_sctp_transport_signals[LAST_SIGNAL] = { 0 };
+
+#define gst_webrtc_sctp_transport_parent_class parent_class
+G_DEFINE_TYPE_WITH_CODE (GstWebRTCSCTPTransport, gst_webrtc_sctp_transport,
+    GST_TYPE_OBJECT, GST_DEBUG_CATEGORY_INIT (gst_webrtc_sctp_transport_debug,
+        "webrtcsctptransport", 0, "webrtcsctptransport"););
+
+typedef void (*SCTPTask) (GstWebRTCSCTPTransport * sctp, gpointer user_data);
+
+struct task
+{
+  GstWebRTCSCTPTransport *sctp;
+  SCTPTask func;
+  gpointer user_data;
+  GDestroyNotify notify;
+};
+
+static void
+_execute_task (GstWebRTCBin * webrtc, struct task *task)
+{
+  if (task->func)
+    task->func (task->sctp, task->user_data);
+}
+
+static void
+_free_task (struct task *task)
+{
+  gst_object_unref (task->sctp);
+
+  if (task->notify)
+    task->notify (task->user_data);
+  g_free (task);
+}
+
+static void
+_sctp_enqueue_task (GstWebRTCSCTPTransport * sctp, SCTPTask func,
+    gpointer user_data, GDestroyNotify notify)
+{
+  struct task *task = g_new0 (struct task, 1);
+
+  task->sctp = gst_object_ref (sctp);
+  task->func = func;
+  task->user_data = user_data;
+  task->notify = notify;
+
+  gst_webrtc_bin_enqueue_task (sctp->webrtcbin,
+      (GstWebRTCBinFunc) _execute_task, task, (GDestroyNotify) _free_task);
+}
+
+static void
+_emit_stream_reset (GstWebRTCSCTPTransport * sctp, gpointer user_data)
+{
+  guint stream_id = GPOINTER_TO_UINT (user_data);
+
+  g_signal_emit (sctp,
+      gst_webrtc_sctp_transport_signals[ON_RESET_STREAM_SIGNAL], 0, stream_id);
+}
+
+static void
+_on_sctp_dec_pad_removed (GstElement * sctpdec, GstPad * pad,
+    GstWebRTCSCTPTransport * sctp)
+{
+  guint stream_id;
+
+  if (sscanf (GST_PAD_NAME (pad), "src_%u", &stream_id) != 1)
+    return;
+
+  _sctp_enqueue_task (sctp, (SCTPTask) _emit_stream_reset,
+      GUINT_TO_POINTER (stream_id), NULL);
+}
+
+static void
+_on_sctp_association_established (GstElement * sctpenc, gboolean established,
+    GstWebRTCSCTPTransport * sctp)
+{
+  GST_OBJECT_LOCK (sctp);
+  if (established)
+    sctp->state = GST_WEBRTC_SCTP_TRANSPORT_STATE_CONNECTED;
+  else
+    sctp->state = GST_WEBRTC_SCTP_TRANSPORT_STATE_CLOSED;
+  sctp->association_established = established;
+  GST_OBJECT_UNLOCK (sctp);
+
+  g_object_notify (G_OBJECT (sctp), "state");
+}
+
+static void
+gst_webrtc_sctp_transport_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+//  GstWebRTCSCTPTransport *sctp = GST_WEBRTC_SCTP_TRANSPORT (object);
+
+  switch (prop_id) {
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_webrtc_sctp_transport_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstWebRTCSCTPTransport *sctp = GST_WEBRTC_SCTP_TRANSPORT (object);
+
+  switch (prop_id) {
+    case PROP_TRANSPORT:
+      g_value_set_object (value, sctp->transport);
+      break;
+    case PROP_STATE:
+      g_value_set_enum (value, sctp->state);
+      break;
+    case PROP_MAX_MESSAGE_SIZE:
+      g_value_set_uint64 (value, sctp->max_message_size);
+      break;
+    case PROP_MAX_CHANNELS:
+      g_value_set_uint (value, sctp->max_channels);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_webrtc_sctp_transport_finalize (GObject * object)
+{
+  GstWebRTCSCTPTransport *sctp = GST_WEBRTC_SCTP_TRANSPORT (object);
+
+  g_signal_handlers_disconnect_by_data (sctp->sctpdec, sctp);
+  g_signal_handlers_disconnect_by_data (sctp->sctpenc, sctp);
+
+  gst_object_unref (sctp->sctpdec);
+  gst_object_unref (sctp->sctpenc);
+
+  g_clear_object (&sctp->transport);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gst_webrtc_sctp_transport_constructed (GObject * object)
+{
+  GstWebRTCSCTPTransport *sctp = GST_WEBRTC_SCTP_TRANSPORT (object);
+  guint association_id;
+
+  association_id = g_random_int_range (0, G_MAXUINT16);
+
+  sctp->sctpdec =
+      g_object_ref_sink (gst_element_factory_make ("sctpdec", NULL));
+  g_object_set (sctp->sctpdec, "sctp-association-id", association_id, NULL);
+  sctp->sctpenc =
+      g_object_ref_sink (gst_element_factory_make ("sctpenc", NULL));
+  g_object_set (sctp->sctpenc, "sctp-association-id", association_id, NULL);
+
+  g_signal_connect (sctp->sctpdec, "pad-removed",
+      G_CALLBACK (_on_sctp_dec_pad_removed), sctp);
+  g_signal_connect (sctp->sctpenc, "sctp-association-established",
+      G_CALLBACK (_on_sctp_association_established), sctp);
+
+  G_OBJECT_CLASS (parent_class)->constructed (object);
+}
+
+static void
+gst_webrtc_sctp_transport_class_init (GstWebRTCSCTPTransportClass * klass)
+{
+  GObjectClass *gobject_class = (GObjectClass *) klass;
+
+  gobject_class->constructed = gst_webrtc_sctp_transport_constructed;
+  gobject_class->get_property = gst_webrtc_sctp_transport_get_property;
+  gobject_class->set_property = gst_webrtc_sctp_transport_set_property;
+  gobject_class->finalize = gst_webrtc_sctp_transport_finalize;
+
+  g_object_class_install_property (gobject_class,
+      PROP_TRANSPORT,
+      g_param_spec_object ("transport",
+          "WebRTC DTLS Transport",
+          "DTLS transport used for this SCTP transport",
+          GST_TYPE_WEBRTC_DTLS_TRANSPORT,
+          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class,
+      PROP_STATE,
+      g_param_spec_enum ("state",
+          "WebRTC SCTP Transport state", "WebRTC SCTP Transport state",
+          GST_TYPE_WEBRTC_SCTP_TRANSPORT_STATE,
+          GST_WEBRTC_SCTP_TRANSPORT_STATE_NEW,
+          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class,
+      PROP_MAX_MESSAGE_SIZE,
+      g_param_spec_uint64 ("max-message-size",
+          "Maximum message size",
+          "Maximum message size as reported by the transport", 0, G_MAXUINT64,
+          0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class,
+      PROP_MAX_CHANNELS,
+      g_param_spec_uint ("max-channels",
+          "Maximum number of channels", "Maximum number of channels",
+          0, G_MAXUINT16, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstWebRTCSCTPTransport::reset-stream:
+   * @object: the #GstWebRTCSCTPTransport
+   * @stream_id: the SCTP stream that was reset
+   */
+  gst_webrtc_sctp_transport_signals[ON_RESET_STREAM_SIGNAL] =
+      g_signal_new ("stream-reset", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_generic,
+      G_TYPE_NONE, 1, G_TYPE_UINT);
+}
+
+static void
+gst_webrtc_sctp_transport_init (GstWebRTCSCTPTransport * nice)
+{
+}
+
+GstWebRTCSCTPTransport *
+gst_webrtc_sctp_transport_new (void)
+{
+  return g_object_new (GST_TYPE_WEBRTC_SCTP_TRANSPORT, NULL);
+}
diff --git a/ext/webrtc/sctptransport.h b/ext/webrtc/sctptransport.h
new file mode 100644
index 000000000..d5327a77e
--- /dev/null
+++ b/ext/webrtc/sctptransport.h
@@ -0,0 +1,65 @@
+/* GStreamer
+ * Copyright (C) 2018 Matthew Waters <matthew@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_WEBRTC_SCTP_TRANSPORT_H__
+#define __GST_WEBRTC_SCTP_TRANSPORT_H__
+
+#include <gst/gst.h>
+/* libnice */
+#include <agent.h>
+#include <gst/webrtc/webrtc.h>
+#include "gstwebrtcice.h"
+
+G_BEGIN_DECLS
+
+GType gst_webrtc_sctp_transport_get_type(void);
+#define GST_TYPE_WEBRTC_SCTP_TRANSPORT            (gst_webrtc_sctp_transport_get_type())
+#define GST_WEBRTC_SCTP_TRANSPORT(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WEBRTC_SCTP_TRANSPORT,GstWebRTCSCTPTransport))
+#define GST_IS_WEBRTC_SCTP_TRANSPORT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WEBRTC_SCTP_TRANSPORT))
+#define GST_WEBRTC_SCTP_TRANSPORT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_WEBRTC_SCTP_TRANSPORT,GstWebRTCSCTPTransportClass))
+#define GST_IS_WEBRTC_SCTP_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_WEBRTC_SCTP_TRANSPORT))
+#define GST_WEBRTC_SCTP_TRANSPORT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_WEBRTC_SCTP_TRANSPORT,GstWebRTCSCTPTransportClass))
+
+struct _GstWebRTCSCTPTransport
+{
+  GstObject                     parent;
+
+  GstWebRTCDTLSTransport       *transport;
+  GstWebRTCSCTPTransportState   state;
+  guint64                       max_message_size;
+  guint                         max_channels;
+
+  gboolean                      association_established;
+
+  GstElement                   *sctpdec;
+  GstElement                   *sctpenc;
+
+  GstWebRTCBin                 *webrtcbin;
+};
+
+struct _GstWebRTCSCTPTransportClass
+{
+  GstObjectClass                parent_class;
+};
+
+GstWebRTCSCTPTransport *    gst_webrtc_sctp_transport_new               (void);
+
+G_END_DECLS
+
+#endif /* __GST_WEBRTC_SCTP_TRANSPORT_H__ */
diff --git a/ext/webrtc/transportreceivebin.c b/ext/webrtc/transportreceivebin.c
index 6730b1fb7..d059fa270 100644
--- a/ext/webrtc/transportreceivebin.c
+++ b/ext/webrtc/transportreceivebin.c
@@ -25,23 +25,24 @@
 #include "utils.h"
 
 /*
- * ,----------------------------transport_receive_%u-----------------------------,
- * ;       (rtp)                                                                 ;
- * ;  ,---nicesrc----,  ,-capsfilter-,  ,----dtlssrtpdec----,      ,--funnel--,  ;
- * ;  ;          src o--o sink   src o--o sink      rtp_src o------o sink_0   ;  ;
- * ;  '--------------'  '------------'  ;                   ;      ;      src o--o rtp_src
- * ;                                    ;          rtcp_src o-, ,--o sink_1   ;  ;
- * ;                                    '-------------------' ; ;  '----------'  ;
- * ;                                                          ; ;  ,--funnel--,  ;
- * ;                                                          '-+--o sink_0   ;  ;
- * ;                                                          ,-'  ;      src o--o rtcp_src
- * ;       (rtcp)                                             ;  ,-o sink_1   ;  ;
- * ;  ,---nicesrc----,  ,-capsfilter-,  ,----dtlssrtpdec----, ;  ; '----------'  ;
- * ;  ;          src o--o sink   src o--o sink      rtp_src o-'  ;               ;
- * ;  '--------------'  '------------'  ;                   ;    ;               ;
- * ;                                    ;          rtcp_src o----'               ;
- * ;                                    '-------------------'                    ;
- * '-----------------------------------------------------------------------------'
+ * ,----------------------------transport_receive_%u---------------------------,
+ * ;     (rtp/data)                                                            ;
+ * ;  ,-nicesrc-, ,-capsfilter-, ,--queue--, ,-dtlssrtpdec-,       ,-funnel-,  ;
+ * ;  ;     src o-o sink   src o-osink  srco-osink  rtp_srco-------o sink_0 ;  ;
+ * ;  '---------' '------------' '---------' ;             ;       ;    src o--o rtp_src
+ * ;                                         ;     rtcp_srco---, ,-o sink_1 ;  ;
+ * ;                                         ;             ;   ; ; '--------'  ;
+ * ;                                         ;     data_srco-, ; ; ,-funnel-,  ;
+ * ;     (rtcp)                              '-------------' ; '-+-o sink_0 ;  ;
+ * ;  ,-nicesrc-, ,-capsfilter-, ,--queue--, ,-dtlssrtpdec-, ; ,-' ;    src o--o rtcp_src
+ * ;  ;     src o-o sink   src o-osink  srco-osink  rtp_srco-+-' ,-o sink_1 ;  ;
+ * ;  '---------' '------------' '---------' ;             ; ;   ; '--------'  ;
+ * ;                                         ;     rtcp_srco-+---' ,-funnel-,  ;
+ * ;                                         ;             ; '-----o sink_0 ;  ;
+ * ;                                         ;     data_srco-,     ;    src o--o data_src
+ * ;                                         '-------------' '-----o sink_1 ;  ;
+ * ;                                                               '--------'  ;
+ * '---------------------------------------------------------------------------'
  *
  * Do we really wnat to be *that* permissive in what we accept?
  *
@@ -70,6 +71,12 @@ GST_STATIC_PAD_TEMPLATE ("rtcp_src",
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS ("application/x-rtp"));
 
+static GstStaticPadTemplate data_sink_template =
+GST_STATIC_PAD_TEMPLATE ("data_src",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
 enum
 {
   PROP_0,
@@ -94,21 +101,31 @@ _receive_state_to_string (ReceiveState state)
 static GstPadProbeReturn
 pad_block (GstPad * pad, GstPadProbeInfo * info, TransportReceiveBin * receive)
 {
-  GstPadProbeReturn ret;
-
   g_mutex_lock (&receive->pad_block_lock);
   while (receive->receive_state == RECEIVE_STATE_BLOCK) {
     g_cond_wait (&receive->pad_block_cond, &receive->pad_block_lock);
     GST_DEBUG_OBJECT (pad, "probe waited. new state %s",
         _receive_state_to_string (receive->receive_state));
   }
-  ret = GST_PAD_PROBE_PASS;
 
-  if (receive->receive_state == RECEIVE_STATE_DROP) {
-    ret = GST_PAD_PROBE_DROP;
-  } else if (receive->receive_state == RECEIVE_STATE_PASS) {
-    ret = GST_PAD_PROBE_OK;
-  }
+  g_mutex_unlock (&receive->pad_block_lock);
+
+  return GST_PAD_PROBE_OK;
+}
+
+static GstPadProbeReturn
+src_probe_cb (GstPad * pad, GstPadProbeInfo * info,
+    TransportReceiveBin * receive)
+{
+  GstPadProbeReturn ret;
+
+  g_mutex_lock (&receive->pad_block_lock);
+
+  g_assert (receive->receive_state != RECEIVE_STATE_BLOCK);
+
+  ret =
+      receive->receive_state ==
+      RECEIVE_STATE_DROP ? GST_PAD_PROBE_DROP : GST_PAD_PROBE_OK;
 
   g_mutex_unlock (&receive->pad_block_lock);
 
@@ -188,14 +205,37 @@ transport_receive_bin_change_state (GstElement * element,
 
   switch (transition) {
     case GST_STATE_CHANGE_NULL_TO_READY:{
-      GstElement *elem;
+      GstWebRTCDTLSTransport *transport;
+      GstElement *elem, *dtlssrtpdec;
+      GstPad *pad;
 
+      transport = receive->stream->transport;
+      dtlssrtpdec = transport->dtlssrtpdec;
+      pad = gst_element_get_static_pad (dtlssrtpdec, "sink");
       receive->rtp_block =
-          _create_pad_block (GST_ELEMENT (receive), receive->rtp_src, 0, NULL,
-          NULL);
+          _create_pad_block (GST_ELEMENT (receive), pad, 0, NULL, NULL);
       receive->rtp_block->block_id =
-          gst_pad_add_probe (receive->rtp_src, GST_PAD_PROBE_TYPE_ALL_BOTH,
+          gst_pad_add_probe (pad, GST_PAD_PROBE_TYPE_ALL_BOTH,
           (GstPadProbeCallback) pad_block, receive, NULL);
+      gst_object_unref (pad);
+
+      receive->rtp_src_probe_id = gst_pad_add_probe (receive->rtp_src,
+          GST_PAD_PROBE_TYPE_ALL_BOTH, (GstPadProbeCallback) src_probe_cb,
+          receive, NULL);
+
+      transport = receive->stream->rtcp_transport;
+      dtlssrtpdec = transport->dtlssrtpdec;
+      pad = gst_element_get_static_pad (dtlssrtpdec, "sink");
+      receive->rtcp_block =
+          _create_pad_block (GST_ELEMENT (receive), pad, 0, NULL, NULL);
+      receive->rtcp_block->block_id =
+          gst_pad_add_probe (pad, GST_PAD_PROBE_TYPE_ALL_BOTH,
+          (GstPadProbeCallback) pad_block, receive, NULL);
+      gst_object_unref (pad);
+
+      receive->rtcp_src_probe_id = gst_pad_add_probe (receive->rtcp_src,
+          GST_PAD_PROBE_TYPE_ALL_BOTH, (GstPadProbeCallback) src_probe_cb,
+          receive, NULL);
 
       /* XXX: because nice needs the nicesrc internal main loop running in order
        * correctly STUN... */
@@ -230,6 +270,19 @@ transport_receive_bin_change_state (GstElement * element,
       if (receive->rtp_block)
         _free_pad_block (receive->rtp_block);
       receive->rtp_block = NULL;
+
+      if (receive->rtp_src_probe_id)
+        gst_pad_remove_probe (receive->rtp_src, receive->rtp_src_probe_id);
+      receive->rtp_src_probe_id = 0;
+
+      if (receive->rtcp_block)
+        _free_pad_block (receive->rtcp_block);
+      receive->rtcp_block = NULL;
+
+      if (receive->rtcp_src_probe_id)
+        gst_pad_remove_probe (receive->rtcp_src, receive->rtcp_src_probe_id);
+      receive->rtcp_src_probe_id = 0;
+
       break;
     }
     default:
@@ -265,13 +318,21 @@ transport_receive_bin_constructed (GObject * object)
   g_object_set (capsfilter, "caps", caps, NULL);
   gst_caps_unref (caps);
 
+  queue = gst_element_factory_make ("queue", NULL);
+  /* FIXME: make this configurable? */
+  g_object_set (queue, "leaky", 2, "max-size-time", (guint64) 0,
+      "max-size-buffers", 0, "max-size-bytes", 5 * 1024 * 1024, NULL);
+  g_signal_connect (queue, "overrun", G_CALLBACK (rtp_queue_overrun), receive);
+
+  gst_bin_add (GST_BIN (receive), GST_ELEMENT (queue));
   gst_bin_add (GST_BIN (receive), GST_ELEMENT (capsfilter));
-  if (!gst_element_link_pads (capsfilter, "src", transport->dtlssrtpdec,
-          "sink"))
+  if (!gst_element_link_pads (capsfilter, "src", queue, "sink"))
     g_warn_if_reached ();
 
-  gst_bin_add (GST_BIN (receive), GST_ELEMENT (transport->transport->src));
+  if (!gst_element_link_pads (queue, "src", transport->dtlssrtpdec, "sink"))
+    g_warn_if_reached ();
 
+  gst_bin_add (GST_BIN (receive), GST_ELEMENT (transport->transport->src));
   if (!gst_element_link_pads (GST_ELEMENT (transport->transport->src), "src",
           GST_ELEMENT (capsfilter), "sink"))
     g_warn_if_reached ();
@@ -285,13 +346,21 @@ transport_receive_bin_constructed (GObject * object)
   g_object_set (capsfilter, "caps", caps, NULL);
   gst_caps_unref (caps);
 
+  queue = gst_element_factory_make ("queue", NULL);
+  /* FIXME: make this configurable? */
+  g_object_set (queue, "leaky", 2, "max-size-time", (guint64) 0,
+      "max-size-buffers", 0, "max-size-bytes", 5 * 1024 * 1024, NULL);
+  g_signal_connect (queue, "overrun", G_CALLBACK (rtp_queue_overrun), receive);
+
+  gst_bin_add (GST_BIN (receive), queue);
   gst_bin_add (GST_BIN (receive), GST_ELEMENT (capsfilter));
-  if (!gst_element_link_pads (capsfilter, "src", transport->dtlssrtpdec,
-          "sink"))
+  if (!gst_element_link_pads (capsfilter, "src", queue, "sink"))
     g_warn_if_reached ();
 
-  gst_bin_add (GST_BIN (receive), GST_ELEMENT (transport->transport->src));
+  if (!gst_element_link_pads (queue, "src", transport->dtlssrtpdec, "sink"))
+    g_warn_if_reached ();
 
+  gst_bin_add (GST_BIN (receive), GST_ELEMENT (transport->transport->src));
   if (!gst_element_link_pads (GST_ELEMENT (transport->transport->src), "src",
           GST_ELEMENT (capsfilter), "sink"))
     g_warn_if_reached ();
@@ -306,16 +375,7 @@ transport_receive_bin_constructed (GObject * object)
           "rtp_src", funnel, "sink_1"))
     g_warn_if_reached ();
 
-  queue = gst_element_factory_make ("queue", NULL);
-  /* FIXME: make this configurable? */
-  g_object_set (queue, "leaky", 2, "max-size-time", (guint64) 0,
-      "max-size-buffers", 0, "max-size-bytes", 5 * 1024 * 1024, NULL);
-  g_signal_connect (queue, "overrun", G_CALLBACK (rtp_queue_overrun), receive);
-  gst_bin_add (GST_BIN (receive), queue);
-  if (!gst_element_link_pads (funnel, "src", queue, "sink"))
-    g_warn_if_reached ();
-
-  pad = gst_element_get_static_pad (queue, "src");
+  pad = gst_element_get_static_pad (funnel, "src");
   receive->rtp_src = gst_ghost_pad_new ("rtp_src", pad);
 
   gst_element_add_pad (GST_ELEMENT (receive), receive->rtp_src);
@@ -332,7 +392,22 @@ transport_receive_bin_constructed (GObject * object)
     g_warn_if_reached ();
 
   pad = gst_element_get_static_pad (funnel, "src");
-  ghost = gst_ghost_pad_new ("rtcp_src", pad);
+  receive->rtcp_src = gst_ghost_pad_new ("rtcp_src", pad);
+  gst_element_add_pad (GST_ELEMENT (receive), receive->rtcp_src);
+  gst_object_unref (pad);
+
+  /* create funnel for data_src */
+  funnel = gst_element_factory_make ("funnel", NULL);
+  gst_bin_add (GST_BIN (receive), funnel);
+  if (!gst_element_link_pads (receive->stream->transport->dtlssrtpdec,
+          "data_src", funnel, "sink_0"))
+    g_warn_if_reached ();
+  if (!gst_element_link_pads (receive->stream->rtcp_transport->dtlssrtpdec,
+          "data_src", funnel, "sink_1"))
+    g_warn_if_reached ();
+
+  pad = gst_element_get_static_pad (funnel, "src");
+  ghost = gst_ghost_pad_new ("data_src", pad);
   gst_element_add_pad (GST_ELEMENT (receive), ghost);
   gst_object_unref (pad);
 
@@ -350,6 +425,8 @@ transport_receive_bin_class_init (TransportReceiveBinClass * klass)
   gst_element_class_add_static_pad_template (element_class, &rtp_sink_template);
   gst_element_class_add_static_pad_template (element_class,
       &rtcp_sink_template);
+  gst_element_class_add_static_pad_template (element_class,
+      &data_sink_template);
 
   gst_element_class_set_metadata (element_class, "WebRTC Transport Receive Bin",
       "Filter/Network/WebRTC", "A bin for webrtc connections",
diff --git a/ext/webrtc/transportreceivebin.h b/ext/webrtc/transportreceivebin.h
index f26b4ad0f..a4c187064 100644
--- a/ext/webrtc/transportreceivebin.h
+++ b/ext/webrtc/transportreceivebin.h
@@ -46,7 +46,11 @@ struct _TransportReceiveBin
   gboolean                   rtcp_mux;
 
   GstPad                    *rtp_src;
+  gulong                     rtp_src_probe_id;
+  GstPad                    *rtcp_src;
+  gulong                     rtcp_src_probe_id;
   struct pad_block          *rtp_block;
+  struct pad_block          *rtcp_block;
   GMutex                     pad_block_lock;
   GCond                      pad_block_cond;
   ReceiveState               receive_state;
diff --git a/ext/webrtc/transportsendbin.c b/ext/webrtc/transportsendbin.c
index be1b8aa37..36522d336 100644
--- a/ext/webrtc/transportsendbin.c
+++ b/ext/webrtc/transportsendbin.c
@@ -27,9 +27,11 @@
 /*
  *           ,------------------------transport_send_%u-------------------------,
  *           ;                          ,-----dtlssrtpenc---,                   ;
- *  rtp_sink o--------------------------o rtp_sink_0        ;  ,---nicesink---, ;
- *           ;                          ;               src o--o sink         ; ;
- *           ;   ,--outputselector--, ,-o rtcp_sink_0       ;  '--------------' ;
+ * data_sink o--------------------------o data_sink         ;                   ;
+ *           ;                          ;                   ;  ,---nicesink---, ;
+ *  rtp_sink o--------------------------o rtp_sink_0    src o--o sink         ; ;
+ *           ;                          ;                   ;  '--------------' ;
+ *           ;   ,--outputselector--, ,-o rtcp_sink_0       ;                   ;
  *           ;   ;            src_0 o-' '-------------------'                   ;
  * rtcp_sink ;---o sink             ;   ,----dtlssrtpenc----,  ,---nicesink---, ;
  *           ;   ;            src_1 o---o rtcp_sink_0   src o--o sink         ; ;
@@ -61,6 +63,12 @@ GST_STATIC_PAD_TEMPLATE ("rtcp_sink",
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS ("application/x-rtp"));
 
+static GstStaticPadTemplate data_sink_template =
+GST_STATIC_PAD_TEMPLATE ("data_sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
 enum
 {
   PROP_0,
@@ -422,6 +430,16 @@ transport_send_bin_constructed (GObject * object)
   gst_element_add_pad (GST_ELEMENT (send), ghost);
   gst_object_unref (pad);
 
+  /* push the data stream onto the RTP dtls element */
+  templ = _find_pad_template (transport->dtlssrtpenc,
+      GST_PAD_SINK, GST_PAD_REQUEST, "data_sink");
+  pad = gst_element_request_pad (transport->dtlssrtpenc, templ, "data_sink",
+      NULL);
+
+  ghost = gst_ghost_pad_new ("data_sink", pad);
+  gst_element_add_pad (GST_ELEMENT (send), ghost);
+  gst_object_unref (pad);
+
   /* RTCP */
   transport = send->stream->rtcp_transport;
   /* Do the common init for the context struct */
@@ -509,6 +527,8 @@ transport_send_bin_class_init (TransportSendBinClass * klass)
   gst_element_class_add_static_pad_template (element_class, &rtp_sink_template);
   gst_element_class_add_static_pad_template (element_class,
       &rtcp_sink_template);
+  gst_element_class_add_static_pad_template (element_class,
+      &data_sink_template);
 
   gst_element_class_set_metadata (element_class, "WebRTC Transport Send Bin",
       "Filter/Network/WebRTC", "A bin for webrtc connections",
diff --git a/ext/webrtc/transportstream.c b/ext/webrtc/transportstream.c
index 894b3217a..01261ae1b 100644
--- a/ext/webrtc/transportstream.c
+++ b/ext/webrtc/transportstream.c
@@ -40,6 +40,71 @@ enum
   PROP_DTLS_CLIENT,
 };
 
+GstCaps *
+transport_stream_get_caps_for_pt (TransportStream * stream, guint pt)
+{
+  guint i, len;
+
+  len = stream->ptmap->len;
+  for (i = 0; i < len; i++) {
+    PtMapItem *item = &g_array_index (stream->ptmap, PtMapItem, i);
+    if (item->pt == pt)
+      return item->caps;
+  }
+  return NULL;
+}
+
+int
+transport_stream_get_pt (TransportStream * stream, const gchar * encoding_name)
+{
+  guint i;
+  gint ret = 0;
+
+  for (i = 0; i < stream->ptmap->len; i++) {
+    PtMapItem *item = &g_array_index (stream->ptmap, PtMapItem, i);
+    if (!gst_caps_is_empty (item->caps)) {
+      GstStructure *s = gst_caps_get_structure (item->caps, 0);
+      if (!g_strcmp0 (gst_structure_get_string (s, "encoding-name"),
+              encoding_name)) {
+        ret = item->pt;
+        break;
+      }
+    }
+  }
+
+  return ret;
+}
+
+int *
+transport_stream_get_all_pt (TransportStream * stream,
+    const gchar * encoding_name, gsize * pt_len)
+{
+  guint i;
+  gsize ret_i = 0;
+  gsize ret_size = 8;
+  int *ret = NULL;
+
+  for (i = 0; i < stream->ptmap->len; i++) {
+    PtMapItem *item = &g_array_index (stream->ptmap, PtMapItem, i);
+    if (!gst_caps_is_empty (item->caps)) {
+      GstStructure *s = gst_caps_get_structure (item->caps, 0);
+      if (!g_strcmp0 (gst_structure_get_string (s, "encoding-name"),
+              encoding_name)) {
+        if (!ret)
+          ret = g_new0 (int, ret_size);
+        if (ret_i >= ret_size) {
+          ret_size *= 2;
+          ret = g_realloc_n (ret, ret_size, sizeof (int));
+        }
+        ret[ret_i++] = item->pt;
+      }
+    }
+  }
+
+  *pt_len = ret_i;
+  return ret;
+}
+
 static void
 transport_stream_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec)
@@ -117,6 +182,14 @@ transport_stream_dispose (GObject * object)
     gst_object_unref (stream->rtcp_transport);
   stream->rtcp_transport = NULL;
 
+  if (stream->rtxsend)
+    gst_object_unref (stream->rtxsend);
+  stream->rtxsend = NULL;
+
+  if (stream->rtxreceive)
+    gst_object_unref (stream->rtxreceive);
+  stream->rtxreceive = NULL;
+
   GST_OBJECT_PARENT (object) = NULL;
 
   G_OBJECT_CLASS (parent_class)->dispose (object);
@@ -128,6 +201,7 @@ transport_stream_finalize (GObject * object)
   TransportStream *stream = TRANSPORT_STREAM (object);
 
   g_array_free (stream->ptmap, TRUE);
+  g_array_free (stream->remote_ssrcmap, TRUE);
 
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
@@ -238,6 +312,7 @@ transport_stream_init (TransportStream * stream)
 {
   stream->ptmap = g_array_new (FALSE, TRUE, sizeof (PtMapItem));
   g_array_set_clear_func (stream->ptmap, (GDestroyNotify) clear_ptmap_item);
+  stream->remote_ssrcmap = g_array_new (FALSE, TRUE, sizeof (SsrcMapItem));
 }
 
 TransportStream *
diff --git a/ext/webrtc/transportstream.h b/ext/webrtc/transportstream.h
index 9c4e4a0de..97d4f215b 100644
--- a/ext/webrtc/transportstream.h
+++ b/ext/webrtc/transportstream.h
@@ -37,6 +37,12 @@ typedef struct
   GstCaps *caps;
 } PtMapItem;
 
+typedef struct
+{
+  guint32 ssrc;
+  guint media_idx;
+} SsrcMapItem;
+
 struct _TransportStream
 {
   GstObject                 parent;
@@ -54,6 +60,11 @@ struct _TransportStream
   GstWebRTCDTLSTransport   *rtcp_transport;
 
   GArray                   *ptmap;                  /* array of PtMapItem's */
+  GArray                   *remote_ssrcmap;         /* array of SsrcMapItem's */
+  gboolean                  output_connected;       /* whether receive bin is connected to rtpbin */
+
+  GstElement               *rtxsend;
+  GstElement               *rtxreceive;
 };
 
 struct _TransportStreamClass
@@ -63,6 +74,13 @@ struct _TransportStreamClass
 
 TransportStream *       transport_stream_new        (GstWebRTCBin * webrtc,
                                                      guint session_id);
+int                     transport_stream_get_pt     (TransportStream * stream,
+                                                     const gchar * encoding_name);
+int *                   transport_stream_get_all_pt (TransportStream * stream,
+                                                     const gchar * encoding_name,
+                                                     gsize * pt_len);
+GstCaps *               transport_stream_get_caps_for_pt    (TransportStream * stream,
+                                                             guint pt);
 
 G_END_DECLS
 
diff --git a/ext/webrtc/utils.c b/ext/webrtc/utils.c
index 2b99c7047..044d58322 100644
--- a/ext/webrtc/utils.c
+++ b/ext/webrtc/utils.c
@@ -21,9 +21,17 @@
 # include "config.h"
 #endif
 
+#include <stdlib.h>
+
 #include "utils.h"
 #include "gstwebrtcbin.h"
 
+GQuark
+gst_webrtc_bin_error_quark (void)
+{
+  return g_quark_from_static_string ("gst-webrtc-bin-error-quark");
+}
+
 GstPadTemplate *
 _find_pad_template (GstElement * element, GstPadDirection direction,
     GstPadPresence presence, const gchar * name)
@@ -47,28 +55,59 @@ _find_pad_template (GstElement * element, GstPadDirection direction,
 }
 
 GstSDPMessage *
-_get_latest_sdp (GstWebRTCBin * webrtc)
+_get_latest_offer (GstWebRTCBin * webrtc)
 {
   if (webrtc->current_local_description &&
-      webrtc->current_local_description->type == GST_WEBRTC_SDP_TYPE_ANSWER) {
+      webrtc->current_local_description->type == GST_WEBRTC_SDP_TYPE_OFFER) {
     return webrtc->current_local_description->sdp;
   }
   if (webrtc->current_remote_description &&
-      webrtc->current_remote_description->type == GST_WEBRTC_SDP_TYPE_ANSWER) {
+      webrtc->current_remote_description->type == GST_WEBRTC_SDP_TYPE_OFFER) {
     return webrtc->current_remote_description->sdp;
   }
+
+  return NULL;
+}
+
+GstSDPMessage *
+_get_latest_answer (GstWebRTCBin * webrtc)
+{
   if (webrtc->current_local_description &&
-      webrtc->current_local_description->type == GST_WEBRTC_SDP_TYPE_OFFER) {
+      webrtc->current_local_description->type == GST_WEBRTC_SDP_TYPE_ANSWER) {
     return webrtc->current_local_description->sdp;
   }
   if (webrtc->current_remote_description &&
-      webrtc->current_remote_description->type == GST_WEBRTC_SDP_TYPE_OFFER) {
+      webrtc->current_remote_description->type == GST_WEBRTC_SDP_TYPE_ANSWER) {
     return webrtc->current_remote_description->sdp;
   }
 
   return NULL;
 }
 
+GstSDPMessage *
+_get_latest_sdp (GstWebRTCBin * webrtc)
+{
+  GstSDPMessage *ret = NULL;
+
+  if ((ret = _get_latest_answer (webrtc)))
+    return ret;
+  if ((ret = _get_latest_offer (webrtc)))
+    return ret;
+
+  return NULL;
+}
+
+GstSDPMessage *
+_get_latest_self_generated_sdp (GstWebRTCBin * webrtc)
+{
+  if (webrtc->priv->last_generated_answer)
+    return webrtc->priv->last_generated_answer->sdp;
+  if (webrtc->priv->last_generated_offer)
+    return webrtc->priv->last_generated_offer->sdp;
+
+  return NULL;
+}
+
 struct pad_block *
 _create_pad_block (GstElement * element, GstPad * pad, gulong block_id,
     gpointer user_data, GDestroyNotify notify)
@@ -136,3 +175,33 @@ _g_checksum_to_webrtc_string (GChecksumType type)
       return NULL;
   }
 }
+
+GstCaps *
+_rtp_caps_from_media (const GstSDPMedia * media)
+{
+  GstCaps *ret;
+  int i, j;
+
+  ret = gst_caps_new_empty ();
+  for (i = 0; i < gst_sdp_media_formats_len (media); i++) {
+    guint pt = atoi (gst_sdp_media_get_format (media, i));
+    GstCaps *caps;
+
+    caps = gst_sdp_media_get_caps_from_media (media, pt);
+    if (!caps)
+      continue;
+
+    /* gst_sdp_media_get_caps_from_media() produces caps with name
+     * "application/x-unknown" which will fail intersection with
+     * "application/x-rtp" caps so mangle the returns caps to have the
+     * correct name here */
+    for (j = 0; j < gst_caps_get_size (caps); j++) {
+      GstStructure *s = gst_caps_get_structure (caps, j);
+      gst_structure_set_name (s, "application/x-rtp");
+    }
+
+    gst_caps_append (ret, caps);
+  }
+
+  return ret;
+}
diff --git a/ext/webrtc/utils.h b/ext/webrtc/utils.h
index f76f850d9..5e4f6c647 100644
--- a/ext/webrtc/utils.h
+++ b/ext/webrtc/utils.h
@@ -26,12 +26,30 @@
 
 G_BEGIN_DECLS
 
+#define GST_WEBRTC_BIN_ERROR gst_webrtc_bin_error_quark ()
+GQuark gst_webrtc_bin_error_quark (void);
+
+typedef enum
+{
+  GST_WEBRTC_BIN_ERROR_FAILED,
+  GST_WEBRTC_BIN_ERROR_INVALID_SYNTAX,
+  GST_WEBRTC_BIN_ERROR_INVALID_MODIFICATION,
+  GST_WEBRTC_BIN_ERROR_INVALID_STATE,
+  GST_WEBRTC_BIN_ERROR_BAD_SDP,
+  GST_WEBRTC_BIN_ERROR_FINGERPRINT,
+  GST_WEBRTC_BIN_ERROR_SCTP_FAILURE,
+  GST_WEBRTC_BIN_ERROR_DATA_CHANNEL_FAILURE,
+} GstWebRTCError;
+
 GstPadTemplate *        _find_pad_template          (GstElement * element,
                                                      GstPadDirection direction,
                                                      GstPadPresence presence,
                                                      const gchar * name);
 
 GstSDPMessage *         _get_latest_sdp             (GstWebRTCBin * webrtc);
+GstSDPMessage *         _get_latest_offer           (GstWebRTCBin * webrtc);
+GstSDPMessage *         _get_latest_answer          (GstWebRTCBin * webrtc);
+GstSDPMessage *         _get_latest_self_generated_sdp (GstWebRTCBin * webrtc);
 
 GstWebRTCICEStream *    _find_ice_stream_for_session            (GstWebRTCBin * webrtc,
                                                                  guint session_id);
@@ -59,6 +77,8 @@ G_GNUC_INTERNAL
 gchar *                 _enum_value_to_string       (GType type, guint value);
 G_GNUC_INTERNAL
 const gchar *           _g_checksum_to_webrtc_string (GChecksumType type);
+G_GNUC_INTERNAL
+GstCaps *               _rtp_caps_from_media        (const GstSDPMedia * media);
 
 G_END_DECLS
 
diff --git a/ext/webrtc/webrtcdatachannel.c b/ext/webrtc/webrtcdatachannel.c
new file mode 100644
index 000000000..693e626cd
--- /dev/null
+++ b/ext/webrtc/webrtcdatachannel.c
@@ -0,0 +1,1351 @@
+/* GStreamer
+ * Copyright (C) 2018 Matthew Waters <matthew@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+/**
+ * SECTION:gstwebrtc-datachannel
+ * @short_description: RTCDataChannel object
+ * @title: GstWebRTCDataChannel
+ * @see_also: #GstWebRTCRTPTransceiver
+ *
+ * <http://w3c.github.io/webrtc-pc/#dom-rtcsctptransport>
+ */
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "webrtcdatachannel.h"
+#include <gst/app/gstappsink.h>
+#include <gst/app/gstappsrc.h>
+#include <gst/base/gstbytereader.h>
+#include <gst/base/gstbytewriter.h>
+#include <gst/sctp/sctpreceivemeta.h>
+#include <gst/sctp/sctpsendmeta.h>
+
+#include "gstwebrtcbin.h"
+#include "utils.h"
+
+#define GST_CAT_DEFAULT gst_webrtc_data_channel_debug
+GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
+
+#define gst_webrtc_data_channel_parent_class parent_class
+G_DEFINE_TYPE_WITH_CODE (GstWebRTCDataChannel, gst_webrtc_data_channel,
+    G_TYPE_OBJECT, GST_DEBUG_CATEGORY_INIT (gst_webrtc_data_channel_debug,
+        "webrtcdatachannel", 0, "webrtcdatachannel"););
+
+#define CHANNEL_LOCK(channel) g_mutex_lock(&channel->lock)
+#define CHANNEL_UNLOCK(channel) g_mutex_unlock(&channel->lock)
+
+enum
+{
+  SIGNAL_0,
+  SIGNAL_ON_OPEN,
+  SIGNAL_ON_CLOSE,
+  SIGNAL_ON_ERROR,
+  SIGNAL_ON_MESSAGE_DATA,
+  SIGNAL_ON_MESSAGE_STRING,
+  SIGNAL_ON_BUFFERED_AMOUNT_LOW,
+  SIGNAL_SEND_DATA,
+  SIGNAL_SEND_STRING,
+  SIGNAL_CLOSE,
+  LAST_SIGNAL,
+};
+
+enum
+{
+  PROP_0,
+  PROP_LABEL,
+  PROP_ORDERED,
+  PROP_MAX_PACKET_LIFETIME,
+  PROP_MAX_RETRANSMITS,
+  PROP_PROTOCOL,
+  PROP_NEGOTIATED,
+  PROP_ID,
+  PROP_PRIORITY,
+  PROP_READY_STATE,
+  PROP_BUFFERED_AMOUNT,
+  PROP_BUFFERED_AMOUNT_LOW_THRESHOLD,
+};
+
+static guint gst_webrtc_data_channel_signals[LAST_SIGNAL] = { 0 };
+
+typedef enum
+{
+  DATA_CHANNEL_PPID_WEBRTC_CONTROL = 50,
+  DATA_CHANNEL_PPID_WEBRTC_STRING = 51,
+  DATA_CHANNEL_PPID_WEBRTC_BINARY_PARTIAL = 52, /* deprecated */
+  DATA_CHANNEL_PPID_WEBRTC_BINARY = 53,
+  DATA_CHANNEL_PPID_WEBRTC_STRING_PARTIAL = 54, /* deprecated */
+  DATA_CHANNEL_PPID_WEBRTC_BINARY_EMPTY = 56,
+  DATA_CHANNEL_PPID_WEBRTC_STRING_EMPTY = 57,
+} DataChannelPPID;
+
+typedef enum
+{
+  CHANNEL_TYPE_RELIABLE = 0x00,
+  CHANNEL_TYPE_RELIABLE_UNORDERED = 0x80,
+  CHANNEL_TYPE_PARTIAL_RELIABLE_REXMIT = 0x01,
+  CHANNEL_TYPE_PARTIAL_RELIABLE_REXMIT_UNORDERED = 0x81,
+  CHANNEL_TYPE_PARTIAL_RELIABLE_TIMED = 0x02,
+  CHANNEL_TYPE_PARTIAL_RELIABLE_TIMED_UNORDERED = 0x82,
+} DataChannelReliabilityType;
+
+typedef enum
+{
+  CHANNEL_MESSAGE_ACK = 0x02,
+  CHANNEL_MESSAGE_OPEN = 0x03,
+} DataChannelMessage;
+
+static guint16
+priority_type_to_uint (GstWebRTCPriorityType pri)
+{
+  switch (pri) {
+    case GST_WEBRTC_PRIORITY_TYPE_VERY_LOW:
+      return 64;
+    case GST_WEBRTC_PRIORITY_TYPE_LOW:
+      return 192;
+    case GST_WEBRTC_PRIORITY_TYPE_MEDIUM:
+      return 384;
+    case GST_WEBRTC_PRIORITY_TYPE_HIGH:
+      return 768;
+  }
+  g_assert_not_reached ();
+  return 0;
+}
+
+static GstWebRTCPriorityType
+priority_uint_to_type (guint16 val)
+{
+  if (val <= 128)
+    return GST_WEBRTC_PRIORITY_TYPE_VERY_LOW;
+  if (val <= 256)
+    return GST_WEBRTC_PRIORITY_TYPE_LOW;
+  if (val <= 512)
+    return GST_WEBRTC_PRIORITY_TYPE_MEDIUM;
+  return GST_WEBRTC_PRIORITY_TYPE_HIGH;
+}
+
+static GstBuffer *
+construct_open_packet (GstWebRTCDataChannel * channel)
+{
+  GstByteWriter w;
+  gsize label_len = strlen (channel->label);
+  gsize proto_len = strlen (channel->protocol);
+  gsize size = 12 + label_len + proto_len;
+  DataChannelReliabilityType reliability = 0;
+  guint32 reliability_param = 0;
+  guint16 priority;
+  GstBuffer *buf;
+
+/*
+ *    0                   1                   2                   3
+ *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *   |  Message Type |  Channel Type |            Priority           |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *   |                    Reliability Parameter                      |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *   |         Label Length          |       Protocol Length         |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *   \                                                               /
+ *   |                             Label                             |
+ *   /                                                               \
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *   \                                                               /
+ *   |                            Protocol                           |
+ *   /                                                               \
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+  gst_byte_writer_init_with_size (&w, size, FALSE);
+
+  if (!gst_byte_writer_put_uint8 (&w, (guint8) CHANNEL_MESSAGE_OPEN))
+    g_return_val_if_reached (NULL);
+
+  if (!channel->ordered)
+    reliability |= 0x80;
+  if (channel->max_retransmits != -1) {
+    reliability |= 0x01;
+    reliability_param = channel->max_retransmits;
+  }
+  if (channel->max_packet_lifetime != -1) {
+    reliability |= 0x02;
+    reliability_param = channel->max_packet_lifetime;
+  }
+
+  priority = priority_type_to_uint (channel->priority);
+
+  if (!gst_byte_writer_put_uint8 (&w, (guint8) reliability))
+    g_return_val_if_reached (NULL);
+  if (!gst_byte_writer_put_uint16_be (&w, (guint16) priority))
+    g_return_val_if_reached (NULL);
+  if (!gst_byte_writer_put_uint32_be (&w, (guint32) reliability_param))
+    g_return_val_if_reached (NULL);
+  if (!gst_byte_writer_put_uint16_be (&w, (guint16) label_len))
+    g_return_val_if_reached (NULL);
+  if (!gst_byte_writer_put_uint16_be (&w, (guint16) proto_len))
+    g_return_val_if_reached (NULL);
+  if (!gst_byte_writer_put_data (&w, (guint8 *) channel->label, label_len))
+    g_return_val_if_reached (NULL);
+  if (!gst_byte_writer_put_data (&w, (guint8 *) channel->protocol, proto_len))
+    g_return_val_if_reached (NULL);
+
+  buf = gst_byte_writer_reset_and_get_buffer (&w);
+
+  /* send reliable and ordered */
+  gst_sctp_buffer_add_send_meta (buf, DATA_CHANNEL_PPID_WEBRTC_CONTROL, TRUE,
+      GST_SCTP_SEND_META_PARTIAL_RELIABILITY_NONE, 0);
+
+  return buf;
+}
+
+static GstBuffer *
+construct_ack_packet (GstWebRTCDataChannel * channel)
+{
+  GstByteWriter w;
+  GstBuffer *buf;
+
+/*
+ *   0                   1                   2                   3
+ *   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *   |  Message Type |
+ *   +-+-+-+-+-+-+-+-+
+ */
+
+  gst_byte_writer_init_with_size (&w, 1, FALSE);
+
+  if (!gst_byte_writer_put_uint8 (&w, (guint8) CHANNEL_MESSAGE_ACK))
+    g_return_val_if_reached (NULL);
+
+  buf = gst_byte_writer_reset_and_get_buffer (&w);
+
+  /* send reliable and ordered */
+  gst_sctp_buffer_add_send_meta (buf, DATA_CHANNEL_PPID_WEBRTC_CONTROL, TRUE,
+      GST_SCTP_SEND_META_PARTIAL_RELIABILITY_NONE, 0);
+
+  return buf;
+}
+
+typedef void (*ChannelTask) (GstWebRTCDataChannel * channel,
+    gpointer user_data);
+
+struct task
+{
+  GstWebRTCDataChannel *channel;
+  ChannelTask func;
+  gpointer user_data;
+  GDestroyNotify notify;
+};
+
+static void
+_execute_task (GstWebRTCBin * webrtc, struct task *task)
+{
+  if (task->func)
+    task->func (task->channel, task->user_data);
+}
+
+static void
+_free_task (struct task *task)
+{
+  gst_object_unref (task->channel);
+
+  if (task->notify)
+    task->notify (task->user_data);
+  g_free (task);
+}
+
+static void
+_channel_enqueue_task (GstWebRTCDataChannel * channel, ChannelTask func,
+    gpointer user_data, GDestroyNotify notify)
+{
+  struct task *task = g_new0 (struct task, 1);
+
+  task->channel = gst_object_ref (channel);
+  task->func = func;
+  task->user_data = user_data;
+  task->notify = notify;
+
+  gst_webrtc_bin_enqueue_task (channel->webrtcbin,
+      (GstWebRTCBinFunc) _execute_task, task, (GDestroyNotify) _free_task);
+}
+
+static void
+_channel_store_error (GstWebRTCDataChannel * channel, GError * error)
+{
+  CHANNEL_LOCK (channel);
+  if (error) {
+    GST_WARNING_OBJECT (channel, "Error: %s",
+        error ? error->message : "Unknown");
+    if (!channel->stored_error)
+      channel->stored_error = error;
+    else
+      g_clear_error (&error);
+  }
+  CHANNEL_UNLOCK (channel);
+}
+
+static void
+_maybe_emit_on_error (GstWebRTCDataChannel * channel, GError * error)
+{
+  if (error) {
+    GST_WARNING_OBJECT (channel, "error thrown");
+    g_signal_emit (channel, gst_webrtc_data_channel_signals[SIGNAL_ON_ERROR], 0,
+        error);
+  }
+}
+
+static void
+_emit_on_open (GstWebRTCDataChannel * channel, gpointer user_data)
+{
+  CHANNEL_LOCK (channel);
+  if (channel->ready_state == GST_WEBRTC_DATA_CHANNEL_STATE_CLOSING ||
+      channel->ready_state == GST_WEBRTC_DATA_CHANNEL_STATE_CLOSED) {
+    CHANNEL_UNLOCK (channel);
+    return;
+  }
+
+  if (channel->ready_state != GST_WEBRTC_DATA_CHANNEL_STATE_OPEN) {
+    channel->ready_state = GST_WEBRTC_DATA_CHANNEL_STATE_OPEN;
+    CHANNEL_UNLOCK (channel);
+    g_object_notify (G_OBJECT (channel), "ready-state");
+
+    GST_INFO_OBJECT (channel, "We are open and ready for data!");
+    g_signal_emit (channel, gst_webrtc_data_channel_signals[SIGNAL_ON_OPEN], 0,
+        NULL);
+  } else {
+    CHANNEL_UNLOCK (channel);
+  }
+}
+
+static void
+_transport_closed_unlocked (GstWebRTCDataChannel * channel)
+{
+  GError *error;
+
+  if (channel->ready_state == GST_WEBRTC_DATA_CHANNEL_STATE_CLOSED)
+    return;
+
+  channel->ready_state = GST_WEBRTC_DATA_CHANNEL_STATE_CLOSED;
+
+  error = channel->stored_error;
+  channel->stored_error = NULL;
+  CHANNEL_UNLOCK (channel);
+
+  g_object_notify (G_OBJECT (channel), "ready-state");
+  GST_INFO_OBJECT (channel, "We are closed for data");
+
+  _maybe_emit_on_error (channel, error);
+
+  g_signal_emit (channel, gst_webrtc_data_channel_signals[SIGNAL_ON_CLOSE], 0,
+      NULL);
+  CHANNEL_LOCK (channel);
+}
+
+static void
+_transport_closed (GstWebRTCDataChannel * channel, gpointer user_data)
+{
+  CHANNEL_LOCK (channel);
+  _transport_closed_unlocked (channel);
+  CHANNEL_UNLOCK (channel);
+}
+
+static void
+_close_sctp_stream (GstWebRTCDataChannel * channel, gpointer user_data)
+{
+  GstPad *pad, *peer;
+
+  pad = gst_element_get_static_pad (channel->appsrc, "src");
+  peer = gst_pad_get_peer (pad);
+  gst_object_unref (pad);
+
+  if (peer) {
+    GstElement *sctpenc = gst_pad_get_parent_element (peer);
+
+    if (sctpenc) {
+      gst_element_release_request_pad (sctpenc, peer);
+      gst_object_unref (sctpenc);
+    }
+    gst_object_unref (peer);
+  }
+
+  _transport_closed (channel, NULL);
+}
+
+static void
+_close_procedure (GstWebRTCDataChannel * channel, gpointer user_data)
+{
+  /* https://www.w3.org/TR/webrtc/#data-transport-closing-procedure */
+  CHANNEL_LOCK (channel);
+  if (channel->ready_state == GST_WEBRTC_DATA_CHANNEL_STATE_CLOSED
+      || channel->ready_state == GST_WEBRTC_DATA_CHANNEL_STATE_CLOSING) {
+    CHANNEL_UNLOCK (channel);
+    return;
+  }
+  channel->ready_state = GST_WEBRTC_DATA_CHANNEL_STATE_CLOSING;
+  CHANNEL_UNLOCK (channel);
+  g_object_notify (G_OBJECT (channel), "ready-state");
+
+  CHANNEL_LOCK (channel);
+  if (channel->buffered_amount <= 0) {
+    _channel_enqueue_task (channel, (ChannelTask) _close_sctp_stream,
+        NULL, NULL);
+  }
+
+  CHANNEL_UNLOCK (channel);
+}
+
+static void
+_on_sctp_reset_stream (GstWebRTCSCTPTransport * sctp, guint stream_id,
+    GstWebRTCDataChannel * channel)
+{
+  if (channel->id == stream_id)
+    _channel_enqueue_task (channel, (ChannelTask) _transport_closed,
+        GUINT_TO_POINTER (stream_id), NULL);
+}
+
+static void
+gst_webrtc_data_channel_close (GstWebRTCDataChannel * channel)
+{
+  _close_procedure (channel, NULL);
+}
+
+static GstFlowReturn
+_parse_control_packet (GstWebRTCDataChannel * channel, guint8 * data,
+    gsize size, GError ** error)
+{
+  GstByteReader r;
+  guint8 message_type;
+
+  if (!data)
+    g_return_val_if_reached (GST_FLOW_ERROR);
+  if (size < 1)
+    g_return_val_if_reached (GST_FLOW_ERROR);
+
+  gst_byte_reader_init (&r, data, size);
+
+  if (!gst_byte_reader_get_uint8 (&r, &message_type))
+    g_return_val_if_reached (GST_FLOW_ERROR);
+
+  if (message_type == CHANNEL_MESSAGE_ACK) {
+    /* all good */
+    GST_INFO_OBJECT (channel, "Received channel ack");
+    return GST_FLOW_OK;
+  } else if (message_type == CHANNEL_MESSAGE_OPEN) {
+    guint8 reliability;
+    guint32 reliability_param;
+    guint16 priority, label_len, proto_len;
+    const guint8 *src;
+    gchar *label, *proto;
+    GstBuffer *buffer;
+    GstFlowReturn ret;
+
+    GST_INFO_OBJECT (channel, "Received channel open");
+
+    if (channel->negotiated) {
+      g_set_error (error, GST_WEBRTC_BIN_ERROR,
+          GST_WEBRTC_BIN_ERROR_DATA_CHANNEL_FAILURE,
+          "Data channel was signalled as negotiated already");
+      g_return_val_if_reached (GST_FLOW_ERROR);
+    }
+
+    if (channel->opened)
+      return GST_FLOW_OK;
+
+    if (!gst_byte_reader_get_uint8 (&r, &reliability))
+      goto parse_error;
+    if (!gst_byte_reader_get_uint16_be (&r, &priority))
+      goto parse_error;
+    if (!gst_byte_reader_get_uint32_be (&r, &reliability_param))
+      goto parse_error;
+    if (!gst_byte_reader_get_uint16_be (&r, &label_len))
+      goto parse_error;
+    if (!gst_byte_reader_get_uint16_be (&r, &proto_len))
+      goto parse_error;
+
+    label = g_new0 (gchar, (gsize) label_len + 1);
+    proto = g_new0 (gchar, (gsize) proto_len + 1);
+
+    if (!gst_byte_reader_get_data (&r, label_len, &src))
+      goto parse_error;
+    memcpy (label, src, label_len);
+    label[label_len] = '\0';
+    if (!gst_byte_reader_get_data (&r, proto_len, &src))
+      goto parse_error;
+    memcpy (proto, src, proto_len);
+    proto[proto_len] = '\0';
+
+    channel->label = label;
+    channel->protocol = proto;
+    channel->priority = priority_uint_to_type (priority);
+    channel->ordered = !(reliability & 0x80);
+    if (reliability & 0x01) {
+      channel->max_retransmits = reliability_param;
+      channel->max_packet_lifetime = -1;
+    } else if (reliability & 0x02) {
+      channel->max_retransmits = -1;
+      channel->max_packet_lifetime = reliability_param;
+    } else {
+      channel->max_retransmits = -1;
+      channel->max_packet_lifetime = -1;
+    }
+    channel->opened = TRUE;
+
+    GST_INFO_OBJECT (channel, "Received channel open for SCTP stream %i "
+        "label %s protocol %s ordered %s", channel->id, channel->label,
+        channel->protocol, channel->ordered ? "true" : "false");
+
+    _channel_enqueue_task (channel, (ChannelTask) _emit_on_open, NULL, NULL);
+
+    GST_INFO_OBJECT (channel, "Sending channel ack");
+    buffer = construct_ack_packet (channel);
+
+    CHANNEL_LOCK (channel);
+    channel->buffered_amount += gst_buffer_get_size (buffer);
+    CHANNEL_UNLOCK (channel);
+
+    ret = gst_app_src_push_buffer (GST_APP_SRC (channel->appsrc), buffer);
+    if (ret != GST_FLOW_OK) {
+      g_set_error (error, GST_WEBRTC_BIN_ERROR,
+          GST_WEBRTC_BIN_ERROR_DATA_CHANNEL_FAILURE,
+          "Could not send ack packet");
+    }
+    return ret;
+  } else {
+    g_set_error (error, GST_WEBRTC_BIN_ERROR,
+        GST_WEBRTC_BIN_ERROR_DATA_CHANNEL_FAILURE,
+        "Unknown message type in control protocol");
+    return GST_FLOW_ERROR;
+  }
+
+parse_error:
+  {
+    g_set_error (error, GST_WEBRTC_BIN_ERROR,
+        GST_WEBRTC_BIN_ERROR_DATA_CHANNEL_FAILURE, "Failed to parse packet");
+    g_return_val_if_reached (GST_FLOW_ERROR);
+  }
+}
+
+static void
+on_sink_eos (GstAppSink * sink, gpointer user_data)
+{
+}
+
+struct map_info
+{
+  GstBuffer *buffer;
+  GstMapInfo map_info;
+};
+
+static void
+buffer_unmap_and_unref (struct map_info *info)
+{
+  gst_buffer_unmap (info->buffer, &info->map_info);
+  gst_buffer_unref (info->buffer);
+  g_free (info);
+}
+
+static void
+_emit_have_data (GstWebRTCDataChannel * channel, GBytes * data)
+{
+  GST_LOG_OBJECT (channel, "Have data %p", data);
+  g_signal_emit (channel,
+      gst_webrtc_data_channel_signals[SIGNAL_ON_MESSAGE_DATA], 0, data);
+}
+
+static void
+_emit_have_string (GstWebRTCDataChannel * channel, gchar * str)
+{
+  GST_LOG_OBJECT (channel, "Have string %p", str);
+  g_signal_emit (channel,
+      gst_webrtc_data_channel_signals[SIGNAL_ON_MESSAGE_STRING], 0, str);
+}
+
+static GstFlowReturn
+_data_channel_have_sample (GstWebRTCDataChannel * channel, GstSample * sample,
+    GError ** error)
+{
+  GstSctpReceiveMeta *receive;
+  GstBuffer *buffer;
+  GstFlowReturn ret = GST_FLOW_OK;
+
+  GST_LOG_OBJECT (channel, "Received sample %" GST_PTR_FORMAT, sample);
+
+  g_return_val_if_fail (channel->sctp_transport != NULL, GST_FLOW_ERROR);
+
+  buffer = gst_sample_get_buffer (sample);
+  if (!buffer) {
+    g_set_error (error, GST_WEBRTC_BIN_ERROR,
+        GST_WEBRTC_BIN_ERROR_DATA_CHANNEL_FAILURE, "No buffer to handle");
+    return GST_FLOW_ERROR;
+  }
+  receive = gst_sctp_buffer_get_receive_meta (buffer);
+  if (!receive) {
+    g_set_error (error, GST_WEBRTC_BIN_ERROR,
+        GST_WEBRTC_BIN_ERROR_DATA_CHANNEL_FAILURE,
+        "No SCTP Receive meta on the buffer");
+    return GST_FLOW_ERROR;
+  }
+
+  switch (receive->ppid) {
+    case DATA_CHANNEL_PPID_WEBRTC_CONTROL:{
+      GstMapInfo info = GST_MAP_INFO_INIT;
+      if (!gst_buffer_map (buffer, &info, GST_MAP_READ)) {
+        g_set_error (error, GST_WEBRTC_BIN_ERROR,
+            GST_WEBRTC_BIN_ERROR_DATA_CHANNEL_FAILURE,
+            "Failed to map received buffer");
+        ret = GST_FLOW_ERROR;
+      } else {
+        ret = _parse_control_packet (channel, info.data, info.size, error);
+      }
+      break;
+    }
+    case DATA_CHANNEL_PPID_WEBRTC_STRING:
+    case DATA_CHANNEL_PPID_WEBRTC_STRING_PARTIAL:{
+      GstMapInfo info = GST_MAP_INFO_INIT;
+      if (!gst_buffer_map (buffer, &info, GST_MAP_READ)) {
+        g_set_error (error, GST_WEBRTC_BIN_ERROR,
+            GST_WEBRTC_BIN_ERROR_DATA_CHANNEL_FAILURE,
+            "Failed to map received buffer");
+        ret = GST_FLOW_ERROR;
+      } else {
+        gchar *str = g_strndup ((gchar *) info.data, info.size);
+        _channel_enqueue_task (channel, (ChannelTask) _emit_have_string, str,
+            g_free);
+      }
+      break;
+    }
+    case DATA_CHANNEL_PPID_WEBRTC_BINARY:
+    case DATA_CHANNEL_PPID_WEBRTC_BINARY_PARTIAL:{
+      struct map_info *info = g_new0 (struct map_info, 1);
+      if (!gst_buffer_map (buffer, &info->map_info, GST_MAP_READ)) {
+        g_set_error (error, GST_WEBRTC_BIN_ERROR,
+            GST_WEBRTC_BIN_ERROR_DATA_CHANNEL_FAILURE,
+            "Failed to map received buffer");
+        ret = GST_FLOW_ERROR;
+      } else {
+        GBytes *data = g_bytes_new_with_free_func (info->map_info.data,
+            info->map_info.size, (GDestroyNotify) buffer_unmap_and_unref, info);
+        info->buffer = gst_buffer_ref (buffer);
+        _channel_enqueue_task (channel, (ChannelTask) _emit_have_data, data,
+            (GDestroyNotify) g_bytes_unref);
+      }
+      break;
+    }
+    case DATA_CHANNEL_PPID_WEBRTC_BINARY_EMPTY:
+      _channel_enqueue_task (channel, (ChannelTask) _emit_have_data, NULL,
+          NULL);
+      break;
+    case DATA_CHANNEL_PPID_WEBRTC_STRING_EMPTY:
+      _channel_enqueue_task (channel, (ChannelTask) _emit_have_string, NULL,
+          NULL);
+      break;
+    default:
+      g_set_error (error, GST_WEBRTC_BIN_ERROR,
+          GST_WEBRTC_BIN_ERROR_DATA_CHANNEL_FAILURE,
+          "Unknown SCTP PPID %u received", receive->ppid);
+      ret = GST_FLOW_ERROR;
+      break;
+  }
+
+  return ret;
+}
+
+static GstFlowReturn
+on_sink_preroll (GstAppSink * sink, gpointer user_data)
+{
+  GstWebRTCDataChannel *channel = user_data;
+  GstSample *sample = gst_app_sink_pull_preroll (sink);
+  GstFlowReturn ret;
+
+  if (sample) {
+    /* This sample also seems to be provided by the sample callback
+       ret = _data_channel_have_sample (channel, sample); */
+    ret = GST_FLOW_OK;
+    gst_sample_unref (sample);
+  } else if (gst_app_sink_is_eos (sink)) {
+    ret = GST_FLOW_EOS;
+  } else {
+    ret = GST_FLOW_ERROR;
+  }
+
+  if (ret != GST_FLOW_OK) {
+    _channel_enqueue_task (channel, (ChannelTask) _close_procedure, NULL, NULL);
+  }
+
+  return ret;
+}
+
+static GstFlowReturn
+on_sink_sample (GstAppSink * sink, gpointer user_data)
+{
+  GstWebRTCDataChannel *channel = user_data;
+  GstSample *sample = gst_app_sink_pull_sample (sink);
+  GstFlowReturn ret;
+  GError *error = NULL;
+
+  if (sample) {
+    ret = _data_channel_have_sample (channel, sample, &error);
+    gst_sample_unref (sample);
+  } else if (gst_app_sink_is_eos (sink)) {
+    ret = GST_FLOW_EOS;
+  } else {
+    ret = GST_FLOW_ERROR;
+  }
+
+  if (error)
+    _channel_store_error (channel, error);
+
+  if (ret != GST_FLOW_OK) {
+    _channel_enqueue_task (channel, (ChannelTask) _close_procedure, NULL, NULL);
+  }
+
+  return ret;
+}
+
+static GstAppSinkCallbacks sink_callbacks = {
+  on_sink_eos,
+  on_sink_preroll,
+  on_sink_sample,
+};
+
+void
+gst_webrtc_data_channel_start_negotiation (GstWebRTCDataChannel * channel)
+{
+  GstBuffer *buffer;
+
+  g_return_if_fail (!channel->negotiated);
+  g_return_if_fail (channel->id != -1);
+  g_return_if_fail (channel->sctp_transport != NULL);
+
+  buffer = construct_open_packet (channel);
+
+  GST_INFO_OBJECT (channel, "Sending channel open for SCTP stream %i "
+      "label %s protocol %s ordered %s", channel->id, channel->label,
+      channel->protocol, channel->ordered ? "true" : "false");
+
+  CHANNEL_LOCK (channel);
+  channel->buffered_amount += gst_buffer_get_size (buffer);
+  CHANNEL_UNLOCK (channel);
+
+  if (gst_app_src_push_buffer (GST_APP_SRC (channel->appsrc),
+          buffer) == GST_FLOW_OK) {
+    channel->opened = TRUE;
+    _channel_enqueue_task (channel, (ChannelTask) _emit_on_open, NULL, NULL);
+  } else {
+    GError *error = NULL;
+    g_set_error (&error, GST_WEBRTC_BIN_ERROR,
+        GST_WEBRTC_BIN_ERROR_DATA_CHANNEL_FAILURE,
+        "Failed to send DCEP open packet");
+    _channel_store_error (channel, error);
+    _channel_enqueue_task (channel, (ChannelTask) _close_procedure, NULL, NULL);
+  }
+}
+
+static void
+_get_sctp_reliability (GstWebRTCDataChannel * channel,
+    GstSctpSendMetaPartiallyReliability * reliability, guint * rel_param)
+{
+  if (channel->max_retransmits != -1) {
+    *reliability = GST_SCTP_SEND_META_PARTIAL_RELIABILITY_RTX;
+    *rel_param = channel->max_retransmits;
+  } else if (channel->max_packet_lifetime != -1) {
+    *reliability = GST_SCTP_SEND_META_PARTIAL_RELIABILITY_TTL;
+    *rel_param = channel->max_packet_lifetime;
+  } else {
+    *reliability = GST_SCTP_SEND_META_PARTIAL_RELIABILITY_NONE;
+    *rel_param = 0;
+  }
+}
+
+static gboolean
+_is_within_max_message_size (GstWebRTCDataChannel * channel, gsize size)
+{
+  return size <= channel->sctp_transport->max_message_size;
+}
+
+static void
+gst_webrtc_data_channel_send_data (GstWebRTCDataChannel * channel,
+    GBytes * bytes)
+{
+  GstSctpSendMetaPartiallyReliability reliability;
+  guint rel_param;
+  guint32 ppid;
+  GstBuffer *buffer;
+  GstFlowReturn ret;
+
+  if (!bytes) {
+    buffer = gst_buffer_new ();
+    ppid = DATA_CHANNEL_PPID_WEBRTC_BINARY_EMPTY;
+  } else {
+    gsize size;
+    guint8 *data;
+
+    data = (guint8 *) g_bytes_get_data (bytes, &size);
+    g_return_if_fail (data != NULL);
+    if (!_is_within_max_message_size (channel, size)) {
+      GError *error = NULL;
+      g_set_error (&error, GST_WEBRTC_BIN_ERROR,
+          GST_WEBRTC_BIN_ERROR_DATA_CHANNEL_FAILURE,
+          "Requested to send data that is too large");
+      _channel_store_error (channel, error);
+      _channel_enqueue_task (channel, (ChannelTask) _close_procedure, NULL,
+          NULL);
+      return;
+    }
+
+    buffer = gst_buffer_new_wrapped_full (GST_MEMORY_FLAG_READONLY, data, size,
+        0, size, g_bytes_ref (bytes), (GDestroyNotify) g_bytes_unref);
+    ppid = DATA_CHANNEL_PPID_WEBRTC_BINARY;
+  }
+
+  _get_sctp_reliability (channel, &reliability, &rel_param);
+  gst_sctp_buffer_add_send_meta (buffer, ppid, channel->ordered, reliability,
+      rel_param);
+
+  GST_LOG_OBJECT (channel, "Sending data using buffer %" GST_PTR_FORMAT,
+      buffer);
+
+  CHANNEL_LOCK (channel);
+  channel->buffered_amount += gst_buffer_get_size (buffer);
+  CHANNEL_UNLOCK (channel);
+
+  ret = gst_app_src_push_buffer (GST_APP_SRC (channel->appsrc), buffer);
+
+  if (ret != GST_FLOW_OK) {
+    GError *error = NULL;
+    g_set_error (&error, GST_WEBRTC_BIN_ERROR,
+        GST_WEBRTC_BIN_ERROR_DATA_CHANNEL_FAILURE, "Failed to send data");
+    _channel_store_error (channel, error);
+    _channel_enqueue_task (channel, (ChannelTask) _close_procedure, NULL, NULL);
+  }
+}
+
+static void
+gst_webrtc_data_channel_send_string (GstWebRTCDataChannel * channel,
+    gchar * str)
+{
+  GstSctpSendMetaPartiallyReliability reliability;
+  guint rel_param;
+  guint32 ppid;
+  GstBuffer *buffer;
+  GstFlowReturn ret;
+
+  if (!channel->negotiated)
+    g_return_if_fail (channel->opened);
+  g_return_if_fail (channel->sctp_transport != NULL);
+
+  if (!str) {
+    buffer = gst_buffer_new ();
+    ppid = DATA_CHANNEL_PPID_WEBRTC_STRING_EMPTY;
+  } else {
+    gsize size = strlen (str);
+    gchar *str_copy = g_strdup (str);
+
+    if (!_is_within_max_message_size (channel, size)) {
+      GError *error = NULL;
+      g_set_error (&error, GST_WEBRTC_BIN_ERROR,
+          GST_WEBRTC_BIN_ERROR_DATA_CHANNEL_FAILURE,
+          "Requested to send a string that is too large");
+      _channel_store_error (channel, error);
+      _channel_enqueue_task (channel, (ChannelTask) _close_procedure, NULL,
+          NULL);
+      return;
+    }
+
+    buffer =
+        gst_buffer_new_wrapped_full (GST_MEMORY_FLAG_READONLY, str_copy,
+        size, 0, size, str_copy, g_free);
+    ppid = DATA_CHANNEL_PPID_WEBRTC_STRING;
+  }
+
+  _get_sctp_reliability (channel, &reliability, &rel_param);
+  gst_sctp_buffer_add_send_meta (buffer, ppid, channel->ordered, reliability,
+      rel_param);
+
+  GST_TRACE_OBJECT (channel, "Sending string using buffer %" GST_PTR_FORMAT,
+      buffer);
+
+  CHANNEL_LOCK (channel);
+  channel->buffered_amount += gst_buffer_get_size (buffer);
+  CHANNEL_UNLOCK (channel);
+
+  ret = gst_app_src_push_buffer (GST_APP_SRC (channel->appsrc), buffer);
+
+  if (ret != GST_FLOW_OK) {
+    GError *error = NULL;
+    g_set_error (&error, GST_WEBRTC_BIN_ERROR,
+        GST_WEBRTC_BIN_ERROR_DATA_CHANNEL_FAILURE, "Failed to send string");
+    _channel_store_error (channel, error);
+    _channel_enqueue_task (channel, (ChannelTask) _close_procedure, NULL, NULL);
+  }
+}
+
+static void
+_on_sctp_notify_state_unlocked (GObject * sctp_transport,
+    GstWebRTCDataChannel * channel)
+{
+  GstWebRTCSCTPTransportState state;
+
+  g_object_get (sctp_transport, "state", &state, NULL);
+  if (state == GST_WEBRTC_SCTP_TRANSPORT_STATE_CONNECTED) {
+    if (channel->negotiated)
+      _channel_enqueue_task (channel, (ChannelTask) _emit_on_open, NULL, NULL);
+  }
+}
+
+static void
+_on_sctp_notify_state (GObject * sctp_transport, GParamSpec * pspec,
+    GstWebRTCDataChannel * channel)
+{
+  CHANNEL_LOCK (channel);
+  _on_sctp_notify_state_unlocked (sctp_transport, channel);
+  CHANNEL_UNLOCK (channel);
+}
+
+static void
+gst_webrtc_data_channel_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstWebRTCDataChannel *channel = GST_WEBRTC_DATA_CHANNEL (object);
+
+  CHANNEL_LOCK (channel);
+  switch (prop_id) {
+    case PROP_LABEL:
+      channel->label = g_value_dup_string (value);
+      break;
+    case PROP_ORDERED:
+      channel->ordered = g_value_get_boolean (value);
+      break;
+    case PROP_MAX_PACKET_LIFETIME:
+      channel->max_packet_lifetime = g_value_get_int (value);
+      break;
+    case PROP_MAX_RETRANSMITS:
+      channel->max_retransmits = g_value_get_int (value);
+      break;
+    case PROP_PROTOCOL:
+      channel->protocol = g_value_dup_string (value);
+      break;
+    case PROP_NEGOTIATED:
+      channel->negotiated = g_value_get_boolean (value);
+      break;
+    case PROP_ID:
+      channel->id = g_value_get_int (value);
+      break;
+    case PROP_PRIORITY:
+      channel->priority = g_value_get_enum (value);
+      break;
+    case PROP_BUFFERED_AMOUNT_LOW_THRESHOLD:
+      channel->buffered_amount_low_threshold = g_value_get_uint64 (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+  CHANNEL_UNLOCK (channel);
+}
+
+static void
+gst_webrtc_data_channel_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstWebRTCDataChannel *channel = GST_WEBRTC_DATA_CHANNEL (object);
+
+  CHANNEL_LOCK (channel);
+  switch (prop_id) {
+    case PROP_LABEL:
+      g_value_set_string (value, channel->label);
+      break;
+    case PROP_ORDERED:
+      g_value_set_boolean (value, channel->ordered);
+      break;
+    case PROP_MAX_PACKET_LIFETIME:
+      g_value_set_int (value, channel->max_packet_lifetime);
+      break;
+    case PROP_MAX_RETRANSMITS:
+      g_value_set_int (value, channel->max_retransmits);
+      break;
+    case PROP_PROTOCOL:
+      g_value_set_string (value, channel->protocol);
+      break;
+    case PROP_NEGOTIATED:
+      g_value_set_boolean (value, channel->negotiated);
+      break;
+    case PROP_ID:
+      g_value_set_int (value, channel->id);
+      break;
+    case PROP_PRIORITY:
+      g_value_set_enum (value, channel->priority);
+      break;
+    case PROP_READY_STATE:
+      g_value_set_enum (value, channel->ready_state);
+      break;
+    case PROP_BUFFERED_AMOUNT:
+      g_value_set_uint64 (value, channel->buffered_amount);
+      break;
+    case PROP_BUFFERED_AMOUNT_LOW_THRESHOLD:
+      g_value_set_uint64 (value, channel->buffered_amount_low_threshold);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+  CHANNEL_UNLOCK (channel);
+}
+
+static void
+_emit_low_threshold (GstWebRTCDataChannel * channel, gpointer user_data)
+{
+  GST_LOG_OBJECT (channel, "Low threshold reached");
+  g_signal_emit (channel,
+      gst_webrtc_data_channel_signals[SIGNAL_ON_BUFFERED_AMOUNT_LOW], 0);
+}
+
+static GstPadProbeReturn
+on_appsrc_data (GstPad * pad, GstPadProbeInfo * info, gpointer user_data)
+{
+  GstWebRTCDataChannel *channel = user_data;
+  guint64 prev_amount;
+  guint64 size = 0;
+
+  if (GST_PAD_PROBE_INFO_TYPE (info) & (GST_PAD_PROBE_TYPE_BUFFER)) {
+    GstBuffer *buffer = GST_PAD_PROBE_INFO_BUFFER (info);
+    size = gst_buffer_get_size (buffer);
+  } else if (GST_PAD_PROBE_INFO_TYPE (info) & GST_PAD_PROBE_TYPE_BUFFER_LIST) {
+    GstBufferList *list = GST_PAD_PROBE_INFO_BUFFER_LIST (info);
+    size = gst_buffer_list_calculate_size (list);
+  }
+
+  if (size > 0) {
+    CHANNEL_LOCK (channel);
+    prev_amount = channel->buffered_amount;
+    channel->buffered_amount -= size;
+    if (prev_amount > channel->buffered_amount_low_threshold &&
+        channel->buffered_amount < channel->buffered_amount_low_threshold) {
+      _channel_enqueue_task (channel, (ChannelTask) _emit_low_threshold,
+          NULL, NULL);
+    }
+
+    if (channel->ready_state == GST_WEBRTC_DATA_CHANNEL_STATE_CLOSING
+        && channel->buffered_amount <= 0) {
+      _channel_enqueue_task (channel, (ChannelTask) _close_sctp_stream, NULL,
+          NULL);
+    }
+    CHANNEL_UNLOCK (channel);
+  }
+
+  return GST_PAD_PROBE_OK;
+}
+
+static void
+gst_webrtc_data_channel_constructed (GObject * object)
+{
+  GstWebRTCDataChannel *channel = GST_WEBRTC_DATA_CHANNEL (object);
+  GstPad *pad;
+  GstCaps *caps;
+
+  caps = gst_caps_new_any ();
+
+  channel->appsrc = gst_element_factory_make ("appsrc", NULL);
+  gst_object_ref_sink (channel->appsrc);
+  pad = gst_element_get_static_pad (channel->appsrc, "src");
+
+  channel->src_probe = gst_pad_add_probe (pad, GST_PAD_PROBE_TYPE_DATA_BOTH,
+      (GstPadProbeCallback) on_appsrc_data, channel, NULL);
+
+  channel->appsink = gst_element_factory_make ("appsink", NULL);
+  gst_object_ref_sink (channel->appsink);
+  g_object_set (channel->appsink, "sync", FALSE, "async", FALSE, "caps", caps,
+      NULL);
+  gst_app_sink_set_callbacks (GST_APP_SINK (channel->appsink), &sink_callbacks,
+      channel, NULL);
+
+  gst_object_unref (pad);
+  gst_caps_unref (caps);
+}
+
+static void
+gst_webrtc_data_channel_finalize (GObject * object)
+{
+  GstWebRTCDataChannel *channel = GST_WEBRTC_DATA_CHANNEL (object);
+
+  if (channel->src_probe) {
+    GstPad *pad = gst_element_get_static_pad (channel->appsrc, "src");
+    gst_pad_remove_probe (pad, channel->src_probe);
+    gst_object_unref (pad);
+    channel->src_probe = 0;
+  }
+
+  g_free (channel->label);
+  channel->label = NULL;
+
+  g_free (channel->protocol);
+  channel->protocol = NULL;
+
+  if (channel->sctp_transport)
+    g_signal_handlers_disconnect_by_data (channel->sctp_transport, channel);
+  g_clear_object (&channel->sctp_transport);
+
+  g_clear_object (&channel->appsrc);
+  g_clear_object (&channel->appsink);
+
+  g_mutex_clear (&channel->lock);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gst_webrtc_data_channel_class_init (GstWebRTCDataChannelClass * klass)
+{
+  GObjectClass *gobject_class = (GObjectClass *) klass;
+
+  gobject_class->constructed = gst_webrtc_data_channel_constructed;
+  gobject_class->get_property = gst_webrtc_data_channel_get_property;
+  gobject_class->set_property = gst_webrtc_data_channel_set_property;
+  gobject_class->finalize = gst_webrtc_data_channel_finalize;
+
+  g_object_class_install_property (gobject_class,
+      PROP_LABEL,
+      g_param_spec_string ("label",
+          "Label", "Data channel label",
+          NULL,
+          G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class,
+      PROP_ORDERED,
+      g_param_spec_boolean ("ordered",
+          "Ordered", "Using ordered transmission mode",
+          FALSE,
+          G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class,
+      PROP_MAX_PACKET_LIFETIME,
+      g_param_spec_int ("max-packet-lifetime",
+          "Maximum Packet Lifetime",
+          "Maximum number of milliseconds that transmissions and "
+          "retransmissions may occur in unreliable mode (-1 = unset)",
+          -1, G_MAXUINT16, -1,
+          G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class,
+      PROP_MAX_RETRANSMITS,
+      g_param_spec_int ("max-retransmits",
+          "Maximum Retransmits",
+          "Maximum number of retransmissions attempted in unreliable mode",
+          -1, G_MAXUINT16, 0,
+          G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class,
+      PROP_PROTOCOL,
+      g_param_spec_string ("protocol",
+          "Protocol", "Data channel protocol",
+          "",
+          G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class,
+      PROP_NEGOTIATED,
+      g_param_spec_boolean ("negotiated",
+          "Negotiated",
+          "Whether this data channel was negotiated by the application", FALSE,
+          G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class,
+      PROP_ID,
+      g_param_spec_int ("id",
+          "ID",
+          "ID negotiated by this data channel (-1 = unset)",
+          -1, G_MAXUINT16, -1,
+          G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class,
+      PROP_PRIORITY,
+      g_param_spec_enum ("priority",
+          "Priority",
+          "The priority of data sent using this data channel",
+          GST_TYPE_WEBRTC_PRIORITY_TYPE,
+          GST_WEBRTC_PRIORITY_TYPE_LOW,
+          G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class,
+      PROP_READY_STATE,
+      g_param_spec_enum ("ready-state",
+          "Ready State",
+          "The Ready state of this data channel",
+          GST_TYPE_WEBRTC_DATA_CHANNEL_STATE,
+          GST_WEBRTC_DATA_CHANNEL_STATE_NEW,
+          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class,
+      PROP_BUFFERED_AMOUNT,
+      g_param_spec_uint64 ("buffered-amount",
+          "Buffered Amount",
+          "The amount of data in bytes currently buffered",
+          0, G_MAXUINT64, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class,
+      PROP_BUFFERED_AMOUNT_LOW_THRESHOLD,
+      g_param_spec_uint64 ("buffered-amount-low-threshold",
+          "Buffered Amount Low Threshold",
+          "The threshold at which the buffered amount is considered low and "
+          "the buffered-amount-low signal is emitted",
+          0, G_MAXUINT64, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstWebRTCDataChannel::on-open:
+   * @object: the #GstWebRTCDataChannel
+   */
+  gst_webrtc_data_channel_signals[SIGNAL_ON_OPEN] =
+      g_signal_new ("on-open", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_generic,
+      G_TYPE_NONE, 0);
+
+  /**
+   * GstWebRTCDataChannel::on-close:
+   * @object: the #GstWebRTCDataChannel
+   */
+  gst_webrtc_data_channel_signals[SIGNAL_ON_CLOSE] =
+      g_signal_new ("on-close", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_generic,
+      G_TYPE_NONE, 0);
+
+  /**
+   * GstWebRTCDataChannel::on-error:
+   * @object: the #GstWebRTCDataChannel
+   * @error: the #GError thrown
+   */
+  gst_webrtc_data_channel_signals[SIGNAL_ON_ERROR] =
+      g_signal_new ("on-error", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_generic,
+      G_TYPE_NONE, 1, G_TYPE_ERROR);
+
+  /**
+   * GstWebRTCDataChannel::on-message-data:
+   * @object: the #GstWebRTCDataChannel
+   * @data: (nullable): a #GBytes of the data received
+   */
+  gst_webrtc_data_channel_signals[SIGNAL_ON_MESSAGE_DATA] =
+      g_signal_new ("on-message-data", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_generic,
+      G_TYPE_NONE, 1, G_TYPE_BYTES);
+
+  /**
+   * GstWebRTCDataChannel::on-message-string:
+   * @object: the #GstWebRTCDataChannel
+   * @data: (nullable): the data received as a string
+   */
+  gst_webrtc_data_channel_signals[SIGNAL_ON_MESSAGE_STRING] =
+      g_signal_new ("on-message-string", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_generic,
+      G_TYPE_NONE, 1, G_TYPE_STRING);
+
+  /**
+   * GstWebRTCDataChannel::on-buffered-amount-low:
+   * @object: the #GstWebRTCDataChannel
+   */
+  gst_webrtc_data_channel_signals[SIGNAL_ON_BUFFERED_AMOUNT_LOW] =
+      g_signal_new ("on-buffered-amount-low", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_generic,
+      G_TYPE_NONE, 0);
+
+  /**
+   * GstWebRTCDataChannel::send-data:
+   * @object: the #GstWebRTCDataChannel
+   * @data: (nullable): a #GBytes with the data
+   */
+  gst_webrtc_data_channel_signals[SIGNAL_SEND_DATA] =
+      g_signal_new_class_handler ("send-data", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_CALLBACK (gst_webrtc_data_channel_send_data), NULL, NULL,
+      g_cclosure_marshal_generic, G_TYPE_NONE, 1, G_TYPE_BYTES);
+
+  /**
+   * GstWebRTCDataChannel::send-string:
+   * @object: the #GstWebRTCDataChannel
+   * @data: (nullable): the data to send as a string
+   */
+  gst_webrtc_data_channel_signals[SIGNAL_SEND_STRING] =
+      g_signal_new_class_handler ("send-string", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_CALLBACK (gst_webrtc_data_channel_send_string), NULL, NULL,
+      g_cclosure_marshal_generic, G_TYPE_NONE, 1, G_TYPE_STRING);
+
+  /**
+   * GstWebRTCDataChannel::close:
+   * @object: the #GstWebRTCDataChannel
+   *
+   * Close the data channel
+   */
+  gst_webrtc_data_channel_signals[SIGNAL_CLOSE] =
+      g_signal_new_class_handler ("close", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_CALLBACK (gst_webrtc_data_channel_close), NULL, NULL,
+      g_cclosure_marshal_generic, G_TYPE_NONE, 0);
+}
+
+static void
+gst_webrtc_data_channel_init (GstWebRTCDataChannel * channel)
+{
+  g_mutex_init (&channel->lock);
+}
+
+static void
+_data_channel_set_sctp_transport (GstWebRTCDataChannel * channel,
+    GstWebRTCSCTPTransport * sctp)
+{
+  g_return_if_fail (GST_IS_WEBRTC_DATA_CHANNEL (channel));
+  g_return_if_fail (GST_IS_WEBRTC_SCTP_TRANSPORT (sctp));
+
+  CHANNEL_LOCK (channel);
+  if (channel->sctp_transport)
+    g_signal_handlers_disconnect_by_data (channel->sctp_transport, channel);
+
+  gst_object_replace ((GstObject **) & channel->sctp_transport,
+      GST_OBJECT (sctp));
+
+  if (sctp) {
+    g_signal_connect (sctp, "stream-reset", G_CALLBACK (_on_sctp_reset_stream),
+        channel);
+    g_signal_connect (sctp, "notify::state", G_CALLBACK (_on_sctp_notify_state),
+        channel);
+    _on_sctp_notify_state_unlocked (G_OBJECT (sctp), channel);
+  }
+  CHANNEL_UNLOCK (channel);
+}
+
+void
+gst_webrtc_data_channel_link_to_sctp (GstWebRTCDataChannel * channel,
+    GstWebRTCSCTPTransport * sctp_transport)
+{
+  if (sctp_transport && !channel->sctp_transport) {
+    gint id;
+
+    g_object_get (channel, "id", &id, NULL);
+
+    if (sctp_transport->association_established && id != -1) {
+      gchar *pad_name;
+
+      _data_channel_set_sctp_transport (channel, sctp_transport);
+      pad_name = g_strdup_printf ("sink_%u", id);
+      if (!gst_element_link_pads (channel->appsrc, "src",
+              channel->sctp_transport->sctpenc, pad_name))
+        g_warn_if_reached ();
+      g_free (pad_name);
+    }
+  }
+}
diff --git a/ext/webrtc/webrtcdatachannel.h b/ext/webrtc/webrtcdatachannel.h
new file mode 100644
index 000000000..b054ed4b8
--- /dev/null
+++ b/ext/webrtc/webrtcdatachannel.h
@@ -0,0 +1,85 @@
+/* GStreamer
+ * Copyright (C) 2018 Matthew Waters <matthew@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_WEBRTC_DATA_CHANNEL_H__
+#define __GST_WEBRTC_DATA_CHANNEL_H__
+
+#include <gst/gst.h>
+#include <gst/webrtc/webrtc_fwd.h>
+#include <gst/webrtc/dtlstransport.h>
+#include "sctptransport.h"
+
+G_BEGIN_DECLS
+
+GST_WEBRTC_API
+GType gst_webrtc_data_channel_get_type(void);
+#define GST_TYPE_WEBRTC_DATA_CHANNEL            (gst_webrtc_data_channel_get_type())
+#define GST_WEBRTC_DATA_CHANNEL(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WEBRTC_DATA_CHANNEL,GstWebRTCDataChannel))
+#define GST_IS_WEBRTC_DATA_CHANNEL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WEBRTC_DATA_CHANNEL))
+#define GST_WEBRTC_DATA_CHANNEL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_WEBRTC_DATA_CHANNEL,GstWebRTCDataChannelClass))
+#define GST_IS_WEBRTC_DATA_CHANNEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_WEBRTC_DATA_CHANNEL))
+#define GST_WEBRTC_DATA_CHANNEL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_WEBRTC_DATA_CHANNEL,GstWebRTCDataChannelClass))
+
+typedef struct _GstWebRTCDataChannel GstWebRTCDataChannel;
+typedef struct _GstWebRTCDataChannelClass GstWebRTCDataChannelClass;
+
+struct _GstWebRTCDataChannel
+{
+  GObject                         parent;
+
+  GstWebRTCSCTPTransport           *sctp_transport;
+  GstElement                       *appsrc;
+  GstElement                       *appsink;
+
+  gchar                            *label;
+  gboolean                          ordered;
+  guint                             max_packet_lifetime;
+  guint                             max_retransmits;
+  gchar                            *protocol;
+  gboolean                          negotiated;
+  gint                              id;
+  GstWebRTCPriorityType             priority;
+  GstWebRTCDataChannelState         ready_state;
+  guint64                           buffered_amount;
+  guint64                           buffered_amount_low_threshold;
+
+  GstWebRTCBin                     *webrtcbin;
+  gboolean                          opened;
+  gulong                            src_probe;
+  GError                           *stored_error;
+  GMutex                            lock;
+
+  gpointer                          _padding[GST_PADDING];
+};
+
+struct _GstWebRTCDataChannelClass
+{
+  GObjectClass            parent_class;
+
+  gpointer                  _padding[GST_PADDING];
+};
+
+void    gst_webrtc_data_channel_start_negotiation   (GstWebRTCDataChannel       *channel);
+G_GNUC_INTERNAL
+void    gst_webrtc_data_channel_link_to_sctp (GstWebRTCDataChannel              *channel,
+                                              GstWebRTCSCTPTransport            *sctp_transport);
+
+G_END_DECLS
+
+#endif /* __GST_WEBRTC_DATA_CHANNEL_H__ */
diff --git a/ext/webrtc/webrtcsdp.c b/ext/webrtc/webrtcsdp.c
index 5584d9bd1..42d650f7b 100644
--- a/ext/webrtc/webrtcsdp.c
+++ b/ext/webrtc/webrtcsdp.c
@@ -24,9 +24,9 @@
 #include "webrtcsdp.h"
 
 #include "utils.h"
-#include "gstwebrtcbin.h"
 
 #include <string.h>
+#include <stdlib.h>
 
 #define IS_EMPTY_SDP_ATTRIBUTE(val) (val == NULL || g_strcmp0(val, "") == 0)
 
@@ -44,10 +44,9 @@ _sdp_source_to_string (SDPSource source)
 }
 
 static gboolean
-_check_valid_state_for_sdp_change (GstWebRTCBin * webrtc, SDPSource source,
-    GstWebRTCSDPType type, GError ** error)
+_check_valid_state_for_sdp_change (GstWebRTCSignalingState state,
+    SDPSource source, GstWebRTCSDPType type, GError ** error)
 {
-  GstWebRTCSignalingState state = webrtc->signaling_state;
 #define STATE(val) GST_WEBRTC_SIGNALING_STATE_ ## val
 #define TYPE(val) GST_WEBRTC_SDP_TYPE_ ## val
 
@@ -82,14 +81,14 @@ _check_valid_state_for_sdp_change (GstWebRTCBin * webrtc, SDPSource source,
     return TRUE;
 
   {
-    gchar *state = _enum_value_to_string (GST_TYPE_WEBRTC_SIGNALING_STATE,
-        webrtc->signaling_state);
+    gchar *state_str = _enum_value_to_string (GST_TYPE_WEBRTC_SIGNALING_STATE,
+        state);
     gchar *type_str = _enum_value_to_string (GST_TYPE_WEBRTC_SDP_TYPE, type);
     g_set_error (error, GST_WEBRTC_BIN_ERROR,
         GST_WEBRTC_BIN_ERROR_INVALID_STATE,
-        "Not in the correct state (%s) for setting %s %s description", state,
-        _sdp_source_to_string (source), type_str);
-    g_free (state);
+        "Not in the correct state (%s) for setting %s %s description",
+        state_str, _sdp_source_to_string (source), type_str);
+    g_free (state_str);
     g_free (type_str);
   }
 
@@ -100,8 +99,8 @@ _check_valid_state_for_sdp_change (GstWebRTCBin * webrtc, SDPSource source,
 }
 
 static gboolean
-_check_sdp_crypto (GstWebRTCBin * webrtc, SDPSource source,
-    GstWebRTCSessionDescription * sdp, GError ** error)
+_check_sdp_crypto (SDPSource source, GstWebRTCSessionDescription * sdp,
+    GError ** error)
 {
   const gchar *message_fingerprint, *fingerprint;
   const GstSDPKey *key;
@@ -213,7 +212,7 @@ _media_has_mid (const GstSDPMedia * media, guint media_idx, GError ** error)
   return TRUE;
 }
 
-static const gchar *
+const gchar *
 _media_get_ice_ufrag (const GstSDPMessage * msg, guint media_idx)
 {
   const gchar *ice_ufrag;
@@ -228,7 +227,7 @@ _media_get_ice_ufrag (const GstSDPMessage * msg, guint media_idx)
   return ice_ufrag;
 }
 
-static const gchar *
+const gchar *
 _media_get_ice_pwd (const GstSDPMessage * msg, guint media_idx)
 {
   const gchar *ice_pwd;
@@ -278,46 +277,35 @@ _media_has_dtls_id (const GstSDPMedia * media, guint media_idx, GError ** error)
 }
 #endif
 gboolean
-validate_sdp (GstWebRTCBin * webrtc, SDPSource source,
+validate_sdp (GstWebRTCSignalingState state, SDPSource source,
     GstWebRTCSessionDescription * sdp, GError ** error)
 {
-#if 0
   const gchar *group, *bundle_ice_ufrag = NULL, *bundle_ice_pwd = NULL;
   gchar **group_members = NULL;
   gboolean is_bundle = FALSE;
-#endif
   int i;
 
-  if (!_check_valid_state_for_sdp_change (webrtc, source, sdp->type, error))
+  if (!_check_valid_state_for_sdp_change (state, source, sdp->type, error))
     return FALSE;
-  if (!_check_sdp_crypto (webrtc, source, sdp, error))
+  if (!_check_sdp_crypto (source, sdp, error))
     return FALSE;
 /* not explicitly required
   if (ICE && !_check_trickle_ice (sdp->sdp))
-    return FALSE;
+    return FALSE;*/
   group = gst_sdp_message_get_attribute_val (sdp->sdp, "group");
-  is_bundle = g_str_has_prefix (group, "BUNDLE");
+  is_bundle = group && g_str_has_prefix (group, "BUNDLE");
   if (is_bundle)
-    group_members = g_strsplit (&group[6], " ", -1);*/
+    group_members = g_strsplit (&group[6], " ", -1);
 
   for (i = 0; i < gst_sdp_message_medias_len (sdp->sdp); i++) {
     const GstSDPMedia *media = gst_sdp_message_get_media (sdp->sdp, i);
-#if 0
     const gchar *mid;
-    gboolean media_in_bundle = FALSE, first_media_in_bundle = FALSE;
-    gboolean bundle_only = FALSE;
-#endif
+    gboolean media_in_bundle = FALSE;
     if (!_media_has_mid (media, i, error))
       goto fail;
-#if 0
     mid = gst_sdp_media_get_attribute_val (media, "mid");
-    media_in_bundle = is_bundle && g_strv_contains (group_members, mid);
-    if (media_in_bundle)
-      bundle_only =
-          gst_sdp_media_get_attribute_val (media, "bundle-only") != NULL;
-    first_media_in_bundle = media_in_bundle
-        && g_strcmp0 (mid, group_members[0]) == 0;
-#endif
+    media_in_bundle = is_bundle
+        && g_strv_contains ((const gchar **) group_members, mid);
     if (!_media_get_ice_ufrag (sdp->sdp, i)) {
       g_set_error (error, GST_WEBRTC_BIN_ERROR, GST_WEBRTC_BIN_ERROR_BAD_SDP,
           "media %u is missing or contains an empty \'ice-ufrag\' attribute",
@@ -331,7 +319,6 @@ validate_sdp (GstWebRTCBin * webrtc, SDPSource source,
     }
     if (!_media_has_setup (media, i, error))
       goto fail;
-#if 0
     /* check paramaters in bundle are the same */
     if (media_in_bundle) {
       const gchar *ice_ufrag =
@@ -339,7 +326,7 @@ validate_sdp (GstWebRTCBin * webrtc, SDPSource source,
       const gchar *ice_pwd = gst_sdp_media_get_attribute_val (media, "ice-pwd");
       if (!bundle_ice_ufrag)
         bundle_ice_ufrag = ice_ufrag;
-      else if (!g_strcmp0 (bundle_ice_ufrag, ice_ufrag) != 0) {
+      else if (g_strcmp0 (bundle_ice_ufrag, ice_ufrag) != 0) {
         g_set_error (error, GST_WEBRTC_BIN_ERROR, GST_WEBRTC_BIN_ERROR_BAD_SDP,
             "media %u has different ice-ufrag values in bundle. "
             "%s != %s", i, bundle_ice_ufrag, ice_ufrag);
@@ -347,22 +334,21 @@ validate_sdp (GstWebRTCBin * webrtc, SDPSource source,
       }
       if (!bundle_ice_pwd) {
         bundle_ice_pwd = ice_pwd;
-      } else if (g_strcmp0 (bundle_ice_pwd, ice_pwd) == 0) {
+      } else if (g_strcmp0 (bundle_ice_pwd, ice_pwd) != 0) {
         g_set_error (error, GST_WEBRTC_BIN_ERROR, GST_WEBRTC_BIN_ERROR_BAD_SDP,
-            "media %u has different ice-ufrag values in bundle. "
-            "%s != %s", i, bundle_ice_ufrag, ice_ufrag);
+            "media %u has different ice-pwd values in bundle. "
+            "%s != %s", i, bundle_ice_pwd, ice_pwd);
         goto fail;
       }
     }
-#endif
   }
 
-//  g_strv_free (group_members);
+  g_strfreev (group_members);
 
   return TRUE;
 
 fail:
-//  g_strv_free (group_members);
+  g_strfreev (group_members);
   return FALSE;
 }
 
@@ -411,6 +397,8 @@ GstWebRTCRTPTransceiverDirection
 _intersect_answer_directions (GstWebRTCRTPTransceiverDirection offer,
     GstWebRTCRTPTransceiverDirection answer)
 {
+  if (offer == DIR (INACTIVE) || answer == DIR (INACTIVE))
+    return DIR (INACTIVE);
   if (offer == DIR (SENDONLY) && answer == DIR (SENDRECV))
     return DIR (RECVONLY);
   if (offer == DIR (SENDONLY) && answer == DIR (RECVONLY))
@@ -425,6 +413,10 @@ _intersect_answer_directions (GstWebRTCRTPTransceiverDirection offer,
     return DIR (SENDONLY);
   if (offer == DIR (SENDRECV) && answer == DIR (RECVONLY))
     return DIR (RECVONLY);
+  if (offer == DIR (RECVONLY) && answer == DIR (RECVONLY))
+    return DIR (INACTIVE);
+  if (offer == DIR (SENDONLY) && answer == DIR (SENDONLY))
+    return DIR (INACTIVE);
 
   return DIR (NONE);
 }
@@ -445,11 +437,13 @@ _media_replace_direction (GstSDPMedia * media,
 
     if (g_strcmp0 (attr->key, "sendonly") == 0
         || g_strcmp0 (attr->key, "sendrecv") == 0
-        || g_strcmp0 (attr->key, "recvonly") == 0) {
+        || g_strcmp0 (attr->key, "recvonly") == 0
+        || g_strcmp0 (attr->key, "inactive") == 0) {
       GstSDPAttribute new_attr = { 0, };
       GST_TRACE ("replace %s with %s", attr->key, dir_str);
       gst_sdp_attribute_set (&new_attr, dir_str, "");
       gst_sdp_media_replace_attribute (media, i, &new_attr);
+      g_free (dir_str);
       return;
     }
   }
@@ -714,3 +708,214 @@ _generate_ice_credentials (gchar ** ufrag, gchar ** password)
         ice_credential_chars[g_random_int_range (0,
             strlen (ice_credential_chars))];
 }
+
+int
+_get_sctp_port_from_media (const GstSDPMedia * media)
+{
+  int i;
+  const gchar *format;
+  gchar *endptr;
+
+  if (gst_sdp_media_formats_len (media) != 1) {
+    /* only exactly one format is supported */
+    return -1;
+  }
+
+  format = gst_sdp_media_get_format (media, 0);
+
+  if (g_strcmp0 (format, "webrtc-datachannel") == 0) {
+    /* draft-ietf-mmusic-sctp-sdp-21, e.g. Firefox 63 and later */
+
+    for (i = 0; i < gst_sdp_media_attributes_len (media); i++) {
+      const GstSDPAttribute *attr = gst_sdp_media_get_attribute (media, i);
+
+      if (g_strcmp0 (attr->key, "sctp-port") == 0) {
+        gint64 port = g_ascii_strtoll (attr->value, &endptr, 10);
+        if (endptr == attr->value) {
+          /* conversion error */
+          return -1;
+        }
+        return port;
+      }
+    }
+  } else {
+    /* draft-ietf-mmusic-sctp-sdp-05, e.g. Chrome as recent as 75 */
+    gint64 port = g_ascii_strtoll (format, &endptr, 10);
+    if (endptr == format) {
+      /* conversion error */
+      return -1;
+    }
+
+    for (i = 0; i < gst_sdp_media_attributes_len (media); i++) {
+      const GstSDPAttribute *attr = gst_sdp_media_get_attribute (media, i);
+
+      if (g_strcmp0 (attr->key, "sctpmap") == 0 && atoi (attr->value) == port) {
+        /* a=sctpmap:5000 webrtc-datachannel 256 */
+        gchar **parts = g_strsplit (attr->value, " ", 3);
+        if (!parts[1] || g_strcmp0 (parts[1], "webrtc-datachannel") != 0) {
+          port = -1;
+        }
+        g_strfreev (parts);
+        return port;
+      }
+    }
+  }
+
+  return -1;
+}
+
+guint64
+_get_sctp_max_message_size_from_media (const GstSDPMedia * media)
+{
+  int i;
+
+  for (i = 0; i < gst_sdp_media_attributes_len (media); i++) {
+    const GstSDPAttribute *attr = gst_sdp_media_get_attribute (media, i);
+
+    if (g_strcmp0 (attr->key, "max-message-size") == 0)
+      return atoi (attr->value);
+  }
+
+  return 65536;
+}
+
+gboolean
+_message_media_is_datachannel (const GstSDPMessage * msg, guint media_id)
+{
+  const GstSDPMedia *media;
+
+  if (!msg)
+    return FALSE;
+
+  if (gst_sdp_message_medias_len (msg) <= media_id)
+    return FALSE;
+
+  media = gst_sdp_message_get_media (msg, media_id);
+
+  if (g_strcmp0 (gst_sdp_media_get_media (media), "application") != 0)
+    return FALSE;
+
+  if (gst_sdp_media_formats_len (media) != 1)
+    return FALSE;
+
+  if (g_strcmp0 (gst_sdp_media_get_format (media, 0),
+          "webrtc-datachannel") != 0)
+    return FALSE;
+
+  return TRUE;
+}
+
+guint
+_message_get_datachannel_index (const GstSDPMessage * msg)
+{
+  guint i;
+
+  for (i = 0; i < gst_sdp_message_medias_len (msg); i++) {
+    if (_message_media_is_datachannel (msg, i)) {
+      g_assert (i < G_MAXUINT);
+      return i;
+    }
+  }
+
+  return G_MAXUINT;
+}
+
+void
+_get_ice_credentials_from_sdp_media (const GstSDPMessage * sdp, guint media_idx,
+    gchar ** ufrag, gchar ** pwd)
+{
+  int i;
+
+  *ufrag = NULL;
+  *pwd = NULL;
+
+  {
+    /* search in the corresponding media section */
+    const GstSDPMedia *media = gst_sdp_message_get_media (sdp, media_idx);
+    const gchar *tmp_ufrag =
+        gst_sdp_media_get_attribute_val (media, "ice-ufrag");
+    const gchar *tmp_pwd = gst_sdp_media_get_attribute_val (media, "ice-pwd");
+    if (tmp_ufrag && tmp_pwd) {
+      *ufrag = g_strdup (tmp_ufrag);
+      *pwd = g_strdup (tmp_pwd);
+      return;
+    }
+  }
+
+  /* then in the sdp message itself */
+  for (i = 0; i < gst_sdp_message_attributes_len (sdp); i++) {
+    const GstSDPAttribute *attr = gst_sdp_message_get_attribute (sdp, i);
+
+    if (g_strcmp0 (attr->key, "ice-ufrag") == 0) {
+      g_assert (!*ufrag);
+      *ufrag = g_strdup (attr->value);
+    } else if (g_strcmp0 (attr->key, "ice-pwd") == 0) {
+      g_assert (!*pwd);
+      *pwd = g_strdup (attr->value);
+    }
+  }
+  if (!*ufrag && !*pwd) {
+    /* Check in the medias themselves. According to JSEP, they should be
+     * identical FIXME: only for bundle-d streams */
+    for (i = 0; i < gst_sdp_message_medias_len (sdp); i++) {
+      const GstSDPMedia *media = gst_sdp_message_get_media (sdp, i);
+      const gchar *tmp_ufrag =
+          gst_sdp_media_get_attribute_val (media, "ice-ufrag");
+      const gchar *tmp_pwd = gst_sdp_media_get_attribute_val (media, "ice-pwd");
+      if (tmp_ufrag && tmp_pwd) {
+        *ufrag = g_strdup (tmp_ufrag);
+        *pwd = g_strdup (tmp_pwd);
+        break;
+      }
+    }
+  }
+}
+
+gboolean
+_parse_bundle (GstSDPMessage * sdp, GStrv * bundled)
+{
+  const gchar *group;
+  gboolean ret = FALSE;
+
+  group = gst_sdp_message_get_attribute_val (sdp, "group");
+
+  if (group && g_str_has_prefix (group, "BUNDLE ")) {
+    *bundled = g_strsplit (group + strlen ("BUNDLE "), " ", 0);
+
+    if (!(*bundled)[0]) {
+      GST_ERROR ("Invalid format for BUNDLE group, expected at least "
+          "one mid (%s)", group);
+      g_strfreev (*bundled);
+      *bundled = NULL;
+      goto done;
+    }
+  } else {
+    ret = TRUE;
+    goto done;
+  }
+
+  ret = TRUE;
+
+done:
+  return ret;
+}
+
+gboolean
+_get_bundle_index (GstSDPMessage * sdp, GStrv bundled, guint * idx)
+{
+  gboolean ret = FALSE;
+  guint i;
+
+  for (i = 0; i < gst_sdp_message_medias_len (sdp); i++) {
+    const GstSDPMedia *media = gst_sdp_message_get_media (sdp, i);
+    const gchar *mid = gst_sdp_media_get_attribute_val (media, "mid");
+
+    if (!g_strcmp0 (mid, bundled[0])) {
+      *idx = i;
+      ret = TRUE;
+      break;
+    }
+  }
+
+  return ret;
+}
diff --git a/ext/webrtc/webrtcsdp.h b/ext/webrtc/webrtcsdp.h
index 779dcc276..7620091fa 100644
--- a/ext/webrtc/webrtcsdp.h
+++ b/ext/webrtc/webrtcsdp.h
@@ -38,7 +38,7 @@ const gchar *                       _sdp_source_to_string                   (SDP
 
 
 G_GNUC_INTERNAL
-gboolean                            validate_sdp                            (GstWebRTCBin * webrtc,
+gboolean                            validate_sdp                            (GstWebRTCSignalingState state,
                                                                              SDPSource source,
                                                                              GstWebRTCSessionDescription * sdp,
                                                                              GError ** error);
@@ -76,5 +76,35 @@ G_GNUC_INTERNAL
 gboolean                            _media_has_attribute_key                (const GstSDPMedia * media,
                                                                              const gchar * key);
 
+G_GNUC_INTERNAL
+int                                 _get_sctp_port_from_media               (const GstSDPMedia * media);
+G_GNUC_INTERNAL
+guint64                             _get_sctp_max_message_size_from_media   (const GstSDPMedia * media);
+
+G_GNUC_INTERNAL
+void                                _get_ice_credentials_from_sdp_media     (const GstSDPMessage * sdp,
+                                                                             guint media_idx,
+                                                                             gchar ** ufrag,
+                                                                             gchar ** pwd);
+G_GNUC_INTERNAL
+gboolean                            _message_media_is_datachannel           (const GstSDPMessage * msg,
+                                                                             guint media_id);
+G_GNUC_INTERNAL
+guint                               _message_get_datachannel_index          (const GstSDPMessage * msg);
+
+G_GNUC_INTERNAL
+gboolean                            _get_bundle_index                       (GstSDPMessage * sdp,
+                                                                             GStrv bundled,
+                                                                             guint * idx);
+G_GNUC_INTERNAL
+gboolean                            _parse_bundle                           (GstSDPMessage * sdp,
+                                                                             GStrv * bundled);
+
+G_GNUC_INTERNAL
+const gchar *                       _media_get_ice_pwd                  (const GstSDPMessage * msg,
+                                                                             guint media_idx);
+G_GNUC_INTERNAL
+const gchar *                       _media_get_ice_ufrag                (const GstSDPMessage * msg,
+                                                                             guint media_idx);
 
 #endif /* __WEBRTC_UTILS_H__ */
diff --git a/ext/webrtc/webrtctransceiver.c b/ext/webrtc/webrtctransceiver.c
index 1735b1a8a..f26536741 100644
--- a/ext/webrtc/webrtctransceiver.c
+++ b/ext/webrtc/webrtctransceiver.c
@@ -25,9 +25,14 @@
 #include "utils.h"
 #include "webrtctransceiver.h"
 
+#define GST_CAT_DEFAULT webrtc_transceiver_debug
+GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
+
 #define webrtc_transceiver_parent_class parent_class
-G_DEFINE_TYPE (WebRTCTransceiver, webrtc_transceiver,
-    GST_TYPE_WEBRTC_RTP_TRANSCEIVER);
+G_DEFINE_TYPE_WITH_CODE (WebRTCTransceiver, webrtc_transceiver,
+    GST_TYPE_WEBRTC_RTP_TRANSCEIVER,
+    GST_DEBUG_CATEGORY_INIT (webrtc_transceiver_debug,
+        "webrtctransceiver", 0, "webrtctransceiver"););
 
 #define DEFAULT_FEC_TYPE GST_WEBRTC_FEC_TYPE_NONE
 #define DEFAULT_DO_NACK FALSE
@@ -69,6 +74,34 @@ webrtc_transceiver_set_transport (WebRTCTransceiver * trans,
         (GstObject *) stream->rtcp_transport);
 }
 
+GstWebRTCDTLSTransport *
+webrtc_transceiver_get_dtls_transport (GstWebRTCRTPTransceiver * trans)
+{
+  g_return_val_if_fail (WEBRTC_IS_TRANSCEIVER (trans), NULL);
+
+  if (trans->sender) {
+    return trans->sender->transport;
+  } else if (trans->receiver) {
+    return trans->receiver->transport;
+  }
+
+  return NULL;
+}
+
+GstWebRTCDTLSTransport *
+webrtc_transceiver_get_rtcp_dtls_transport (GstWebRTCRTPTransceiver * trans)
+{
+  g_return_val_if_fail (WEBRTC_IS_TRANSCEIVER (trans), NULL);
+
+  if (trans->sender) {
+    return trans->sender->rtcp_transport;
+  } else if (trans->receiver) {
+    return trans->receiver->rtcp_transport;
+  }
+
+  return NULL;
+}
+
 static void
 webrtc_transceiver_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec)
@@ -138,6 +171,8 @@ webrtc_transceiver_finalize (GObject * object)
     gst_structure_free (trans->local_rtx_ssrc_map);
   trans->local_rtx_ssrc_map = NULL;
 
+  gst_caps_replace (&trans->last_configured_caps, NULL);
+
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
diff --git a/ext/webrtc/webrtctransceiver.h b/ext/webrtc/webrtctransceiver.h
index 25bb24e82..c03730415 100644
--- a/ext/webrtc/webrtctransceiver.h
+++ b/ext/webrtc/webrtctransceiver.h
@@ -44,6 +44,8 @@ struct _WebRTCTransceiver
   GstWebRTCFECType         fec_type;
   guint                    fec_percentage;
   gboolean                 do_nack;
+
+  GstCaps                  *last_configured_caps;
 };
 
 struct _WebRTCTransceiverClass
@@ -58,6 +60,9 @@ WebRTCTransceiver *       webrtc_transceiver_new            (GstWebRTCBin * webr
 void                      webrtc_transceiver_set_transport  (WebRTCTransceiver * trans,
                                                              TransportStream * stream);
 
+GstWebRTCDTLSTransport *  webrtc_transceiver_get_dtls_transport (GstWebRTCRTPTransceiver * trans);
+GstWebRTCDTLSTransport *  webrtc_transceiver_get_rtcp_dtls_transport (GstWebRTCRTPTransceiver * trans);
+
 G_END_DECLS
 
 #endif /* __WEBRTC_TRANSCEIVER_H__ */
diff --git a/gst-libs/gst/Makefile.am b/gst-libs/gst/Makefile.am
index db67fc89f..0d18cde4a 100644
--- a/gst-libs/gst/Makefile.am
+++ b/gst-libs/gst/Makefile.am
@@ -7,18 +7,18 @@ OPENCV_DIR=opencv
 endif
 
 SUBDIRS = uridownloader adaptivedemux interfaces basecamerabinsrc codecparsers \
-	 insertbin mpegts video audio player isoff webrtc $(WAYLAND_DIR) \
+	 insertbin mpegts video audio sctp player isoff webrtc $(WAYLAND_DIR) \
 	 $(OPENCV_DIR)
 
 noinst_HEADERS = gst-i18n-plugin.h gettext.h glib-compat-private.h
 DIST_SUBDIRS = uridownloader adaptivedemux interfaces basecamerabinsrc \
-	codecparsers insertbin mpegts wayland opencv video audio player isoff webrtc
+	codecparsers insertbin mpegts wayland opencv video audio player isoff sctp webrtc
 
 adaptivedemux: uridownloader
 
 INDEPENDENT_SUBDIRS = \
 	interfaces basecamerabinsrc codecparsers insertbin uridownloader \
-	mpegts player isoff $(WAYLAND_DIR) $(OPENCV_DIR)
+	mpegts player isoff sctp $(WAYLAND_DIR) $(OPENCV_DIR)
 
 .PHONY: independent-subdirs $(INDEPENDENT_SUBDIRS)
 
diff --git a/gst-libs/gst/sctp/Makefile.am b/gst-libs/gst/sctp/Makefile.am
new file mode 100644
index 000000000..afc2c34fb
--- /dev/null
+++ b/gst-libs/gst/sctp/Makefile.am
@@ -0,0 +1,26 @@
+lib_LTLIBRARIES = libgstsctp-1.0.la
+
+libgstsctp_1_0_la_SOURCES = \
+    sctpsendmeta.c \
+    sctpreceivemeta.c
+
+libgstsctp_1_0_la_CFLAGS = \
+    -I$(top_srcdir)/gst-libs \
+    -I$(top_builddir)/gst-libs \
+    -DBUILDING_GST_SCTP \
+    $(GST_PLUGINS_BASE_CFLAGS) \
+    $(GST_BASE_CFLAGS) \
+    $(GST_CFLAGS)
+
+libgstsctp_1_0_la_LIBADD = $(GST_LIBS) $(GST_BASE_LIBS)
+
+libgstsctp_1_0_la_LDFLAGS = \
+    $(GST_LIB_LDFLAGS) \
+    $(GST_ALL_LDFLAGS) \
+    $(GST_LT_LDFLAGS)
+
+libgstsctp_1_0_includedir = $(includedir)/gstreamer-1.0/gst/sctp
+libgstsctp_1_0_include_HEADERS = \
+    sctpsendmeta.h \
+    sctpreceivemeta.h \
+    sctp-prelude.h
diff --git a/gst-libs/gst/sctp/meson.build b/gst-libs/gst/sctp/meson.build
new file mode 100644
index 000000000..876f990e8
--- /dev/null
+++ b/gst-libs/gst/sctp/meson.build
@@ -0,0 +1,26 @@
+sctp_sources = [
+  'sctpreceivemeta.c',
+  'sctpsendmeta.c',
+]
+
+sctp_headers = [
+  'sctpreceivemeta.h',
+  'sctpsendmeta.h',
+  'sctp-prelude.h',
+]
+
+install_headers(sctp_headers, subdir : 'gstreamer-1.0/gst/sctp')
+
+libgstsctp = library('gstsctp-' + api_version,
+  sctp_sources,
+  c_args : gst_plugins_bad_args + ['-DBUILDING_GST_SCTP'],
+  include_directories : [configinc, libsinc],
+  version : libversion,
+  soversion : soversion,
+  install : true,
+  dependencies : [gstbase_dep],
+)
+
+gstsctp_dep = declare_dependency(link_with : libgstsctp,
+  include_directories : [libsinc],
+  dependencies : [gstbase_dep])
diff --git a/gst-libs/gst/sctp/sctp-prelude.h b/gst-libs/gst/sctp/sctp-prelude.h
new file mode 100644
index 000000000..e92e78fbc
--- /dev/null
+++ b/gst-libs/gst/sctp/sctp-prelude.h
@@ -0,0 +1,31 @@
+/* GStreamer SCTP Library
+ * Copyright (C) 2018 GStreamer developers
+ *
+ * sctp-prelude.h: prelude include header for gst-audiobad library
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_SCTP_PRELUDE_H__
+#define __GST_SCTP_PRELUDE_H__
+
+#include <gst/gst.h>
+
+#ifndef GST_SCTP_API
+#  define GST_SCTP_API GST_EXPORT         /* from config.h */
+#endif
+
+#endif /* __GST_SCTP_PRELUDE_H__ */
diff --git a/gst-libs/gst/sctp/sctpreceivemeta.c b/gst-libs/gst/sctp/sctpreceivemeta.c
new file mode 100644
index 000000000..e1c77d466
--- /dev/null
+++ b/gst-libs/gst/sctp/sctpreceivemeta.c
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2015, Collabora Ltd.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this
+ * list of conditions and the following disclaimer in the documentation and/or other
+ * materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "sctpreceivemeta.h"
+
+static gboolean gst_sctp_receive_meta_init (GstMeta * meta, gpointer params,
+    GstBuffer * buffer);
+static gboolean gst_sctp_receive_meta_transform (GstBuffer * transbuf,
+    GstMeta * meta, GstBuffer * buffer, GQuark type, gpointer data);
+
+GType
+gst_sctp_receive_meta_api_get_type (void)
+{
+  static const gchar *tags[] = { NULL };
+  static volatile GType type;
+  if (g_once_init_enter (&type)) {
+    GType _type = gst_meta_api_type_register ("GstSctpReceiveMetaAPI", tags);
+    g_once_init_leave (&type, _type);
+  }
+  return type;
+}
+
+const GstMetaInfo *
+gst_sctp_receive_meta_get_info (void)
+{
+  static const GstMetaInfo *gst_sctp_receive_meta_info = NULL;
+
+  if (g_once_init_enter (&gst_sctp_receive_meta_info)) {
+    const GstMetaInfo *meta = gst_meta_register (GST_SCTP_RECEIVE_META_API_TYPE,
+        "GstSctpReceiveMeta",
+        sizeof (GstSctpReceiveMeta),
+        gst_sctp_receive_meta_init,
+        (GstMetaFreeFunction) NULL,
+        gst_sctp_receive_meta_transform);
+    g_once_init_leave (&gst_sctp_receive_meta_info, meta);
+  }
+  return gst_sctp_receive_meta_info;
+}
+
+static gboolean
+gst_sctp_receive_meta_init (GstMeta * meta, gpointer params, GstBuffer * buffer)
+{
+  GstSctpReceiveMeta *gst_sctp_receive_meta = (GstSctpReceiveMeta *) meta;
+  gst_sctp_receive_meta->ppid = 0;
+  return TRUE;
+}
+
+static gboolean
+gst_sctp_receive_meta_transform (GstBuffer * transbuf, GstMeta * meta,
+    GstBuffer * buffer, GQuark type, gpointer data)
+{
+  GstSctpReceiveMeta *gst_sctp_receive_meta = (GstSctpReceiveMeta *) meta;
+  gst_sctp_buffer_add_receive_meta (transbuf, gst_sctp_receive_meta->ppid);
+  return TRUE;
+}
+
+GstSctpReceiveMeta *
+gst_sctp_buffer_add_receive_meta (GstBuffer * buffer, guint32 ppid)
+{
+  GstSctpReceiveMeta *gst_sctp_receive_meta = NULL;
+
+  g_return_val_if_fail (GST_IS_BUFFER (buffer), NULL);
+  gst_sctp_receive_meta =
+      (GstSctpReceiveMeta *) gst_buffer_add_meta (buffer,
+      GST_SCTP_RECEIVE_META_INFO, NULL);
+  gst_sctp_receive_meta->ppid = ppid;
+  return gst_sctp_receive_meta;
+}
diff --git a/gst-libs/gst/sctp/sctpreceivemeta.h b/gst-libs/gst/sctp/sctpreceivemeta.h
new file mode 100644
index 000000000..5a508370c
--- /dev/null
+++ b/gst-libs/gst/sctp/sctpreceivemeta.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2015, Collabora Ltd.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this
+ * list of conditions and the following disclaimer in the documentation and/or other
+ * materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ */
+
+#ifndef __GST_SCTP_RECEIVE_META_H__
+#define __GST_SCTP_RECEIVE_META_H__
+
+#include <gst/gst.h>
+#include <gst/sctp/sctp-prelude.h>
+
+G_BEGIN_DECLS
+
+#define GST_SCTP_RECEIVE_META_API_TYPE (gst_sctp_receive_meta_api_get_type())
+#define GST_SCTP_RECEIVE_META_INFO (gst_sctp_receive_meta_get_info())
+typedef struct _GstSctpReceiveMeta GstSctpReceiveMeta;
+
+struct _GstSctpReceiveMeta
+{
+  GstMeta meta;
+
+  guint32 ppid;
+};
+
+GST_SCTP_API
+GType gst_sctp_receive_meta_api_get_type (void);
+GST_SCTP_API
+const GstMetaInfo *gst_sctp_receive_meta_get_info (void);
+GST_SCTP_API
+GstSctpReceiveMeta *gst_sctp_buffer_add_receive_meta (GstBuffer * buffer,
+    guint32 ppid);
+
+#define gst_sctp_buffer_get_receive_meta(b) ((GstSctpReceiveMeta *)gst_buffer_get_meta((b), GST_SCTP_RECEIVE_META_API_TYPE))
+
+G_END_DECLS
+
+#endif /* __GST_SCTP_RECEIVE_META_H__ */
diff --git a/gst-libs/gst/sctp/sctpsendmeta.c b/gst-libs/gst/sctp/sctpsendmeta.c
new file mode 100644
index 000000000..d8ce14fc9
--- /dev/null
+++ b/gst-libs/gst/sctp/sctpsendmeta.c
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2015, Collabora Ltd.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this
+ * list of conditions and the following disclaimer in the documentation and/or other
+ * materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "sctpsendmeta.h"
+
+static gboolean gst_sctp_send_meta_init (GstMeta * meta, gpointer params,
+    GstBuffer * buffer);
+static gboolean gst_sctp_send_meta_transform (GstBuffer * transbuf,
+    GstMeta * meta, GstBuffer * buffer, GQuark type, gpointer data);
+
+GType
+gst_sctp_send_meta_api_get_type (void)
+{
+  static const gchar *tags[] = { NULL };
+  static volatile GType type;
+  if (g_once_init_enter (&type)) {
+    GType _type = gst_meta_api_type_register ("GstSctpSendMetaAPI", tags);
+    g_once_init_leave (&type, _type);
+  }
+  return type;
+}
+
+const GstMetaInfo *
+gst_sctp_send_meta_get_info (void)
+{
+  static const GstMetaInfo *gst_sctp_send_meta_info = NULL;
+
+  if (g_once_init_enter (&gst_sctp_send_meta_info)) {
+    const GstMetaInfo *meta = gst_meta_register (GST_SCTP_SEND_META_API_TYPE,
+        "GstSctpSendMeta",
+        sizeof (GstSctpSendMeta),
+        gst_sctp_send_meta_init,
+        (GstMetaFreeFunction) NULL,
+        gst_sctp_send_meta_transform);
+    g_once_init_leave (&gst_sctp_send_meta_info, meta);
+  }
+  return gst_sctp_send_meta_info;
+}
+
+static gboolean
+gst_sctp_send_meta_init (GstMeta * meta, gpointer params, GstBuffer * buffer)
+{
+  GstSctpSendMeta *gst_sctp_send_meta = (GstSctpSendMeta *) meta;
+  gst_sctp_send_meta->ppid = 0;
+  gst_sctp_send_meta->ordered = TRUE;
+  gst_sctp_send_meta->pr = GST_SCTP_SEND_META_PARTIAL_RELIABILITY_NONE;
+  gst_sctp_send_meta->pr_param = 0;
+  return TRUE;
+}
+
+static gboolean
+gst_sctp_send_meta_transform (GstBuffer * transbuf, GstMeta * meta,
+    GstBuffer * buffer, GQuark type, gpointer data)
+{
+  GstSctpSendMeta *gst_sctp_send_meta = (GstSctpSendMeta *) meta;
+  gst_sctp_buffer_add_send_meta (transbuf, gst_sctp_send_meta->ppid,
+      gst_sctp_send_meta->ordered, gst_sctp_send_meta->pr,
+      gst_sctp_send_meta->pr_param);
+  return TRUE;
+}
+
+GstSctpSendMeta *
+gst_sctp_buffer_add_send_meta (GstBuffer * buffer, guint32 ppid,
+    gboolean ordered, GstSctpSendMetaPartiallyReliability pr, guint32 pr_param)
+{
+  GstSctpSendMeta *gst_sctp_send_meta = NULL;
+
+  g_return_val_if_fail (GST_IS_BUFFER (buffer), NULL);
+  gst_sctp_send_meta =
+      (GstSctpSendMeta *) gst_buffer_add_meta (buffer, GST_SCTP_SEND_META_INFO,
+      NULL);
+  gst_sctp_send_meta->ppid = ppid;
+  gst_sctp_send_meta->ordered = ordered;
+  gst_sctp_send_meta->pr = pr;
+  gst_sctp_send_meta->pr_param = pr_param;
+  return gst_sctp_send_meta;
+}
diff --git a/gst-libs/gst/sctp/sctpsendmeta.h b/gst-libs/gst/sctp/sctpsendmeta.h
new file mode 100644
index 000000000..b1860e52f
--- /dev/null
+++ b/gst-libs/gst/sctp/sctpsendmeta.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2015, Collabora Ltd.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this
+ * list of conditions and the following disclaimer in the documentation and/or other
+ * materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ */
+
+#ifndef __GST_SCTP_SEND_META_H__
+#define __GST_SCTP_SEND_META_H__
+
+#include <gst/gst.h>
+#include <gst/sctp/sctp-prelude.h>
+
+G_BEGIN_DECLS
+
+typedef enum
+{
+  GST_SCTP_SEND_META_PARTIAL_RELIABILITY_NONE,
+  GST_SCTP_SEND_META_PARTIAL_RELIABILITY_TTL,
+  GST_SCTP_SEND_META_PARTIAL_RELIABILITY_BUF,
+  GST_SCTP_SEND_META_PARTIAL_RELIABILITY_RTX
+} GstSctpSendMetaPartiallyReliability;
+
+#define GST_SCTP_SEND_META_API_TYPE (gst_sctp_send_meta_api_get_type())
+#define GST_SCTP_SEND_META_INFO (gst_sctp_send_meta_get_info())
+typedef struct _GstSctpSendMeta GstSctpSendMeta;
+
+struct _GstSctpSendMeta
+{
+  GstMeta meta;
+
+  guint32 ppid;
+  gboolean ordered;
+  GstSctpSendMetaPartiallyReliability pr;
+  guint32 pr_param;
+};
+
+GST_SCTP_API
+GType gst_sctp_send_meta_api_get_type (void);
+GST_SCTP_API
+const GstMetaInfo *gst_sctp_send_meta_get_info (void);
+GST_SCTP_API
+GstSctpSendMeta *gst_sctp_buffer_add_send_meta (GstBuffer * buffer,
+    guint32 ppid, gboolean ordered, GstSctpSendMetaPartiallyReliability pr,
+    guint32 pr_param);
+
+#define gst_sctp_buffer_get_send_meta(b) ((GstSctpSendMeta *)gst_buffer_get_meta((b), GST_SCTP_SEND_META_API_TYPE))
+
+G_END_DECLS
+
+#endif /* __GST_SCTP_SEND_META_H__ */
diff --git a/gst-libs/gst/webrtc/Makefile.am b/gst-libs/gst/webrtc/Makefile.am
index 945c4c079..edc9de0aa 100644
--- a/gst-libs/gst/webrtc/Makefile.am
+++ b/gst-libs/gst/webrtc/Makefile.am
@@ -38,6 +38,7 @@ nodist_libgstwebrtc_@GST_API_VERSION@include_HEADERS = $(built_headers)
 libgstwebrtc_@GST_API_VERSION@_la_CFLAGS = \
 	-I$(top_builddir)/gst-libs \
 	-I$(top_srcdir)/gst-libs \
+	-DBUILDING_GST_WEBRTC \
 	$(GST_PLUGINS_BASE_CFLAGS) \
 	$(GST_BASE_CFLAGS) \
 	$(GST_CFLAGS) \
diff --git a/gst-libs/gst/webrtc/dtlstransport.c b/gst-libs/gst/webrtc/dtlstransport.c
index c3b2d519d..ea7671fb2 100644
--- a/gst-libs/gst/webrtc/dtlstransport.c
+++ b/gst-libs/gst/webrtc/dtlstransport.c
@@ -23,7 +23,7 @@
  * @title: GstWebRTCDTLSTransport
  * @see_also: #GstWebRTCRTPSender, #GstWebRTCRTPReceiver, #GstWebRTCICETransport
  *
- * <ulink url="https://www.w3.org/TR/webrtc/#rtcdtlstransport">https://www.w3.org/TR/webrtc/#rtcdtlstransport</ulink>
+ * <https://www.w3.org/TR/webrtc/#rtcdtlstransport>
  */
 
 #ifdef HAVE_CONFIG_H
diff --git a/gst-libs/gst/webrtc/dtlstransport.h b/gst-libs/gst/webrtc/dtlstransport.h
index 207328e73..feb3944bb 100644
--- a/gst-libs/gst/webrtc/dtlstransport.h
+++ b/gst-libs/gst/webrtc/dtlstransport.h
@@ -35,6 +35,9 @@ GType gst_webrtc_dtls_transport_get_type(void);
 #define GST_IS_WEBRTC_DTLS_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_WEBRTC_DTLS_TRANSPORT))
 #define GST_WEBRTC_DTLS_TRANSPORT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_WEBRTC_DTLS_TRANSPORT,GstWebRTCDTLSTransportClass))
 
+/**
+ * GstWebRTCDTLSTransport:
+ */
 struct _GstWebRTCDTLSTransport
 {
   GstObject                          parent;
@@ -65,6 +68,8 @@ GST_WEBRTC_API
 void                        gst_webrtc_dtls_transport_set_transport     (GstWebRTCDTLSTransport * transport,
                                                                          GstWebRTCICETransport * ice);
 
+G_DEFINE_AUTOPTR_CLEANUP_FUNC(GstWebRTCDTLSTransport, gst_object_unref)
+
 G_END_DECLS
 
 #endif /* __GST_WEBRTC_DTLS_TRANSPORT_H__ */
diff --git a/gst-libs/gst/webrtc/icetransport.c b/gst-libs/gst/webrtc/icetransport.c
index e6f44378f..d7e77d90f 100644
--- a/gst-libs/gst/webrtc/icetransport.c
+++ b/gst-libs/gst/webrtc/icetransport.c
@@ -23,7 +23,7 @@
  * @title: GstWebRTCICETransport
  * @see_also: #GstWebRTCRTPSender, #GstWebRTCRTPReceiver, #GstWebRTCDTLSTransport
  *
- * <ulink url="https://www.w3.org/TR/webrtc/#rtcicetransport">https://www.w3.org/TR/webrtc/#rtcicetransport</ulink>
+ * <https://www.w3.org/TR/webrtc/#rtcicetransport>
  */
 
 #ifdef HAVE_CONFIG_H
diff --git a/gst-libs/gst/webrtc/icetransport.h b/gst-libs/gst/webrtc/icetransport.h
index 86860a236..c1e56d41e 100644
--- a/gst-libs/gst/webrtc/icetransport.h
+++ b/gst-libs/gst/webrtc/icetransport.h
@@ -34,6 +34,9 @@ GType gst_webrtc_ice_transport_get_type(void);
 #define GST_IS_WEBRTC_ICE_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_WEBRTC_ICE_TRANSPORT))
 #define GST_WEBRTC_ICE_TRANSPORT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_WEBRTC_ICE_TRANSPORT,GstWebRTCICETransportClass))
 
+/**
+ * GstWebRTCICETransport:
+ */
 struct _GstWebRTCICETransport
 {
   GstObject                          parent;
@@ -71,6 +74,8 @@ void            gst_webrtc_ice_transport_selected_pair_change       (GstWebRTCIC
 GST_WEBRTC_API
 void            gst_webrtc_ice_transport_new_candidate              (GstWebRTCICETransport * ice, guint stream_id, GstWebRTCICEComponent component, gchar * attr);
 
+G_DEFINE_AUTOPTR_CLEANUP_FUNC(GstWebRTCICETransport, gst_object_unref)
+
 G_END_DECLS
 
 #endif /* __GST_WEBRTC_ICE_TRANSPORT_H__ */
diff --git a/gst-libs/gst/webrtc/meson.build b/gst-libs/gst/webrtc/meson.build
index f138fa374..a9f11dc59 100644
--- a/gst-libs/gst/webrtc/meson.build
+++ b/gst-libs/gst/webrtc/meson.build
@@ -25,29 +25,28 @@ webrtc_enumtypes_headers = [
   'webrtc_fwd.h',
 ]
 
-mkenums = find_program('webrtc_mkenum.py')
-gstwebrtc_h = custom_target('gstwebrtcenum_h',
-  output : 'webrtc-enumtypes.h',
-  input : webrtc_enumtypes_headers,
-  install : true,
-  install_dir : 'include/gstreamer-1.0/gst/webrtc/',
-  command : [mkenums, glib_mkenums, '@OUTPUT@', '@INPUT@'])
+webrtc_enums = gnome.mkenums_simple('webrtc-enumtypes',
+  sources : webrtc_enumtypes_headers,
+  body_prefix : '#ifdef HAVE_CONFIG_H\n#include "config.h"\n#endif',
+  header_prefix : '#include <gst/webrtc/webrtc_fwd.h>',
+  decorator: 'GST_WEBRTC_API',
+  install_header: true,
+  install_dir : join_paths(get_option('includedir'), 'gstreamer-1.0/gst/webrtc/'))
+
+gstwebrtc_c = webrtc_enums[0]
+gstwebrtc_h = webrtc_enums[1]
 
-gstwebrtc_c = custom_target('gstwebrtcenum_c',
-  output : 'webrtc-enumtypes.c',
-  input : webrtc_enumtypes_headers,
-  depends : [gstwebrtc_h],
-  command : [mkenums, glib_mkenums, '@OUTPUT@', '@INPUT@'])
 webrtc_gen_sources = [gstwebrtc_h]
 
 gstwebrtc_dependencies = [gstbase_dep, gstsdp_dep]
 
 gstwebrtc = library('gstwebrtc-' + api_version,
   webrtc_sources, gstwebrtc_c, gstwebrtc_h,
-  c_args : gst_plugins_bad_args + ['-DGST_USE_UNSTABLE_API'],
+  c_args : gst_plugins_bad_args + ['-DGST_USE_UNSTABLE_API', '-DBUILDING_GST_WEBRTC'],
   include_directories : [configinc, libsinc],
   version : libversion,
   soversion : soversion,
+  darwin_versions : osxversion,
   install : true,
   dependencies : gstwebrtc_dependencies,
 )
diff --git a/gst-libs/gst/webrtc/rtcsessiondescription.c b/gst-libs/gst/webrtc/rtcsessiondescription.c
index af5cd1c0d..abdf5ca92 100644
--- a/gst-libs/gst/webrtc/rtcsessiondescription.c
+++ b/gst-libs/gst/webrtc/rtcsessiondescription.c
@@ -22,7 +22,7 @@
  * @short_description: RTCSessionDescription object
  * @title: GstWebRTCSessionDescription
  *
- * <ulink url="https://www.w3.org/TR/webrtc/#rtcsessiondescription-class">https://www.w3.org/TR/webrtc/#rtcsessiondescription-class</ulink>
+ * <https://www.w3.org/TR/webrtc/#rtcsessiondescription-class>
  */
 
 #ifdef HAVE_CONFIG_H
diff --git a/gst-libs/gst/webrtc/rtcsessiondescription.h b/gst-libs/gst/webrtc/rtcsessiondescription.h
index 3e0f1f4cd..5308c549a 100644
--- a/gst-libs/gst/webrtc/rtcsessiondescription.h
+++ b/gst-libs/gst/webrtc/rtcsessiondescription.h
@@ -38,7 +38,7 @@ GType gst_webrtc_session_description_get_type (void);
  * @type: the #GstWebRTCSDPType of the description
  * @sdp: the #GstSDPMessage of the description
  *
- * See <ulink url="https://www.w3.org/TR/webrtc/#rtcsessiondescription-class">https://www.w3.org/TR/webrtc/#rtcsessiondescription-class</ulink>
+ * See <https://www.w3.org/TR/webrtc/#rtcsessiondescription-class>
  */
 struct _GstWebRTCSessionDescription
 {
@@ -53,6 +53,9 @@ GstWebRTCSessionDescription *       gst_webrtc_session_description_copy     (con
 GST_WEBRTC_API
 void                                gst_webrtc_session_description_free     (GstWebRTCSessionDescription * desc);
 
+
+G_DEFINE_AUTOPTR_CLEANUP_FUNC(GstWebRTCSessionDescription, gst_webrtc_session_description_free)
+
 G_END_DECLS
 
 #endif /* __GST_WEBRTC_PEERCONNECTION_H__ */
diff --git a/gst-libs/gst/webrtc/rtpreceiver.c b/gst-libs/gst/webrtc/rtpreceiver.c
index f21d77ef1..768e9876d 100644
--- a/gst-libs/gst/webrtc/rtpreceiver.c
+++ b/gst-libs/gst/webrtc/rtpreceiver.c
@@ -23,7 +23,7 @@
  * @title: GstWebRTCRTPReceiver
  * @see_also: #GstWebRTCRTPSender, #GstWebRTCRTPTransceiver
  *
- * <ulink url="https://www.w3.org/TR/webrtc/#rtcrtpreceiver-interface">https://www.w3.org/TR/webrtc/#rtcrtpreceiver-interface</ulink>
+ * <https://www.w3.org/TR/webrtc/#rtcrtpreceiver-interface>
  */
 
 #ifdef HAVE_CONFIG_H
diff --git a/gst-libs/gst/webrtc/rtpreceiver.h b/gst-libs/gst/webrtc/rtpreceiver.h
index 82a541cf8..55a9a86fd 100644
--- a/gst-libs/gst/webrtc/rtpreceiver.h
+++ b/gst-libs/gst/webrtc/rtpreceiver.h
@@ -35,9 +35,9 @@ GType gst_webrtc_rtp_receiver_get_type(void);
 #define GST_IS_WEBRTC_RTP_RECEIVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_WEBRTC_RTP_RECEIVER))
 #define GST_WEBRTC_RTP_RECEIVER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_WEBRTC_RTP_RECEIVER,GstWebRTCRTPReceiverClass))
 
-typedef struct _GstWebRTCRTPReceiver GstWebRTCRTPReceiver;
-typedef struct _GstWebRTCRTPReceiverClass GstWebRTCRTPReceiverClass;
-
+/**
+ * GstWebRTCRTPReceiver:
+ */
 struct _GstWebRTCRTPReceiver
 {
   GstObject                          parent;
@@ -65,6 +65,8 @@ GST_WEBRTC_API
 void                        gst_webrtc_rtp_receiver_set_rtcp_transport  (GstWebRTCRTPReceiver * receiver,
                                                                          GstWebRTCDTLSTransport * transport);
 
+G_DEFINE_AUTOPTR_CLEANUP_FUNC(GstWebRTCRTPReceiver, gst_object_unref)
+
 G_END_DECLS
 
 #endif /* __GST_WEBRTC_RTP_RECEIVER_H__ */
diff --git a/gst-libs/gst/webrtc/rtpsender.c b/gst-libs/gst/webrtc/rtpsender.c
index da743f32d..3a8a9044f 100644
--- a/gst-libs/gst/webrtc/rtpsender.c
+++ b/gst-libs/gst/webrtc/rtpsender.c
@@ -23,7 +23,7 @@
  * @title: GstWebRTCRTPSender
  * @see_also: #GstWebRTCRTPReceiver, #GstWebRTCRTPTransceiver
  *
- * <ulink url="https://www.w3.org/TR/webrtc/#rtcrtpsender-interface">https://www.w3.org/TR/webrtc/#rtcrtpsender-interface</ulink>
+ * <https://www.w3.org/TR/webrtc/#rtcrtpsender-interface>
  */
 
 #ifdef HAVE_CONFIG_H
diff --git a/gst-libs/gst/webrtc/rtpsender.h b/gst-libs/gst/webrtc/rtpsender.h
index f1af0900b..bcaf93c60 100644
--- a/gst-libs/gst/webrtc/rtpsender.h
+++ b/gst-libs/gst/webrtc/rtpsender.h
@@ -35,6 +35,9 @@ GType gst_webrtc_rtp_sender_get_type(void);
 #define GST_IS_WEBRTC_RTP_SENDER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_WEBRTC_RTP_SENDER))
 #define GST_WEBRTC_RTP_SENDER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_WEBRTC_RTP_SENDER,GstWebRTCRTPSenderClass))
 
+/**
+ * GstWebRTCRTPSender:
+ */
 struct _GstWebRTCRTPSender
 {
   GstObject                          parent;
@@ -66,6 +69,8 @@ void                        gst_webrtc_rtp_sender_set_rtcp_transport    (GstWebR
                                                                          GstWebRTCDTLSTransport * transport);
 
 
+G_DEFINE_AUTOPTR_CLEANUP_FUNC(GstWebRTCRTPSender, gst_object_unref)
+
 G_END_DECLS
 
 #endif /* __GST_WEBRTC_RTP_SENDER_H__ */
diff --git a/gst-libs/gst/webrtc/rtptransceiver.c b/gst-libs/gst/webrtc/rtptransceiver.c
index d0d9628d0..08019462a 100644
--- a/gst-libs/gst/webrtc/rtptransceiver.c
+++ b/gst-libs/gst/webrtc/rtptransceiver.c
@@ -23,7 +23,7 @@
  * @title: GstWebRTCRTPTransceiver
  * @see_also: #GstWebRTCRTPSender, #GstWebRTCRTPReceiver
  *
- * <ulink url="https://www.w3.org/TR/webrtc/#rtcrtptransceiver-interface">https://www.w3.org/TR/webrtc/#rtcrtptransceiver-interface</ulink>
+ * <https://www.w3.org/TR/webrtc/#rtcrtptransceiver-interface>
  */
 
 #ifdef HAVE_CONFIG_H
@@ -39,7 +39,7 @@ GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
 G_DEFINE_ABSTRACT_TYPE_WITH_CODE (GstWebRTCRTPTransceiver,
     gst_webrtc_rtp_transceiver, GST_TYPE_OBJECT,
     GST_DEBUG_CATEGORY_INIT (gst_webrtc_rtp_transceiver_debug,
-        "webrtctransceiver", 0, "webrtctransceiver");
+        "webrtcrtptransceiver", 0, "webrtcrtptransceiver");
     );
 
 enum
@@ -54,9 +54,9 @@ enum
   PROP_MID,
   PROP_SENDER,
   PROP_RECEIVER,
-  PROP_STOPPED,                 // FIXME
-  PROP_DIRECTION,               // FIXME
+  PROP_DIRECTION,
   PROP_MLINE,
+  PROP_STOPPED,                 // FIXME
 };
 
 //static guint gst_webrtc_rtp_transceiver_signals[LAST_SIGNAL] = { 0 };
@@ -77,6 +77,9 @@ gst_webrtc_rtp_transceiver_set_property (GObject * object, guint prop_id,
     case PROP_MLINE:
       webrtc->mline = g_value_get_uint (value);
       break;
+    case PROP_DIRECTION:
+      webrtc->direction = g_value_get_enum (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -99,6 +102,9 @@ gst_webrtc_rtp_transceiver_get_property (GObject * object, guint prop_id,
     case PROP_MLINE:
       g_value_set_uint (value, webrtc->mline);
       break;
+    case PROP_DIRECTION:
+      g_value_set_enum (value, webrtc->direction);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -178,9 +184,25 @@ gst_webrtc_rtp_transceiver_class_init (GstWebRTCRTPTransceiverClass * klass)
           "Index in the SDP of the Media",
           0, G_MAXUINT, 0,
           G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstWebRTCRTPTransceiver:direction:
+   *
+   * Direction of the transceiver.
+   *
+   * Since: 1.18
+   **/
+  g_object_class_install_property (gobject_class,
+      PROP_DIRECTION,
+      g_param_spec_enum ("direction", "Direction",
+          "Transceiver direction",
+          GST_TYPE_WEBRTC_RTP_TRANSCEIVER_DIRECTION,
+          GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_NONE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 }
 
 static void
 gst_webrtc_rtp_transceiver_init (GstWebRTCRTPTransceiver * webrtc)
 {
+  webrtc->direction = GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_NONE;
 }
diff --git a/gst-libs/gst/webrtc/rtptransceiver.h b/gst-libs/gst/webrtc/rtptransceiver.h
index 6192314d0..4b2e6e30c 100644
--- a/gst-libs/gst/webrtc/rtptransceiver.h
+++ b/gst-libs/gst/webrtc/rtptransceiver.h
@@ -36,6 +36,9 @@ GType gst_webrtc_rtp_transceiver_get_type(void);
 #define GST_IS_WEBRTC_RTP_TRANSCEIVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_WEBRTC_RTP_TRANSCEIVER))
 #define GST_WEBRTC_RTP_TRANSCEIVER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_WEBRTC_RTP_TRANSCEIVER,GstWebRTCRTPTransceiverClass))
 
+/**
+ * GstWebRTCRTPTransceiver:
+ */
 struct _GstWebRTCRTPTransceiver
 {
   GstObject                         parent;
@@ -58,9 +61,12 @@ struct _GstWebRTCRTPTransceiverClass
 {
   GstObjectClass        parent_class;
 
+  /* FIXME; reset */
   gpointer              _padding[GST_PADDING];
 };
 
+G_DEFINE_AUTOPTR_CLEANUP_FUNC(GstWebRTCRTPTransceiver, gst_object_unref)
+
 G_END_DECLS
 
 #endif /* __GST_WEBRTC_RTP_TRANSCEIVER_H__ */
diff --git a/gst-libs/gst/webrtc/webrtc_fwd.h b/gst-libs/gst/webrtc/webrtc_fwd.h
index be0a3c334..fced4ab9c 100644
--- a/gst-libs/gst/webrtc/webrtc_fwd.h
+++ b/gst-libs/gst/webrtc/webrtc_fwd.h
@@ -27,8 +27,13 @@
 
 #include <gst/gst.h>
 
+/**
+ * SECTION:webrtc_fwd.h
+ * @title: GstWebRTC Enumerations
+ */
+
 #ifndef GST_WEBRTC_API
-#define GST_WEBRTC_API GST_EXPORT
+#  define GST_WEBRTC_API GST_EXPORT         /* from config.h */
 #endif
 
 #include <gst/webrtc/webrtc-enumtypes.h>
@@ -52,11 +57,11 @@ typedef struct _GstWebRTCRTPTransceiverClass GstWebRTCRTPTransceiverClass;
 
 /**
  * GstWebRTCDTLSTransportState:
- * GST_WEBRTC_DTLS_TRANSPORT_STATE_NEW: new
- * GST_WEBRTC_DTLS_TRANSPORT_STATE_CLOSED: closed
- * GST_WEBRTC_DTLS_TRANSPORT_STATE_FAILED: failed
- * GST_WEBRTC_DTLS_TRANSPORT_STATE_CONNECTING: connecting
- * GST_WEBRTC_DTLS_TRANSPORT_STATE_CONNECTED: connected
+ * @GST_WEBRTC_DTLS_TRANSPORT_STATE_NEW: new
+ * @GST_WEBRTC_DTLS_TRANSPORT_STATE_CLOSED: closed
+ * @GST_WEBRTC_DTLS_TRANSPORT_STATE_FAILED: failed
+ * @GST_WEBRTC_DTLS_TRANSPORT_STATE_CONNECTING: connecting
+ * @GST_WEBRTC_DTLS_TRANSPORT_STATE_CONNECTED: connected
  */
 typedef enum /*< underscore_name=gst_webrtc_dtls_transport_state >*/
 {
@@ -69,11 +74,11 @@ typedef enum /*< underscore_name=gst_webrtc_dtls_transport_state >*/
 
 /**
  * GstWebRTCICEGatheringState:
- * GST_WEBRTC_ICE_GATHERING_STATE_NEW: new
- * GST_WEBRTC_ICE_GATHERING_STATE_GATHERING: gathering
- * GST_WEBRTC_ICE_GATHERING_STATE_COMPLETE: complete
+ * @GST_WEBRTC_ICE_GATHERING_STATE_NEW: new
+ * @GST_WEBRTC_ICE_GATHERING_STATE_GATHERING: gathering
+ * @GST_WEBRTC_ICE_GATHERING_STATE_COMPLETE: complete
  *
- * See <ulink url="http://w3c.github.io/webrtc-pc/#dom-rtcicegatheringstate">http://w3c.github.io/webrtc-pc/#dom-rtcicegatheringstate</ulink>
+ * See <http://w3c.github.io/webrtc-pc/#dom-rtcicegatheringstate>
  */
 typedef enum /*< underscore_name=gst_webrtc_ice_gathering_state >*/
 {
@@ -84,15 +89,15 @@ typedef enum /*< underscore_name=gst_webrtc_ice_gathering_state >*/
 
 /**
  * GstWebRTCICEConnectionState:
- * GST_WEBRTC_ICE_CONNECTION_STATE_NEW: new
- * GST_WEBRTC_ICE_CONNECTION_STATE_CHECKING: checking
- * GST_WEBRTC_ICE_CONNECTION_STATE_CONNECTED: connected
- * GST_WEBRTC_ICE_CONNECTION_STATE_COMPLETED: completed
- * GST_WEBRTC_ICE_CONNECTION_STATE_FAILED: failed
- * GST_WEBRTC_ICE_CONNECTION_STATE_DISCONNECTED: disconnected
- * GST_WEBRTC_ICE_CONNECTION_STATE_CLOSED: closed
+ * @GST_WEBRTC_ICE_CONNECTION_STATE_NEW: new
+ * @GST_WEBRTC_ICE_CONNECTION_STATE_CHECKING: checking
+ * @GST_WEBRTC_ICE_CONNECTION_STATE_CONNECTED: connected
+ * @GST_WEBRTC_ICE_CONNECTION_STATE_COMPLETED: completed
+ * @GST_WEBRTC_ICE_CONNECTION_STATE_FAILED: failed
+ * @GST_WEBRTC_ICE_CONNECTION_STATE_DISCONNECTED: disconnected
+ * @GST_WEBRTC_ICE_CONNECTION_STATE_CLOSED: closed
  *
- * See <ulink url="http://w3c.github.io/webrtc-pc/#dom-rtciceconnectionstate">http://w3c.github.io/webrtc-pc/#dom-rtciceconnectionstate</ulink>
+ * See <http://w3c.github.io/webrtc-pc/#dom-rtciceconnectionstate>
  */
 typedef enum /*< underscore_name=gst_webrtc_ice_connection_state >*/
 {
@@ -107,14 +112,14 @@ typedef enum /*< underscore_name=gst_webrtc_ice_connection_state >*/
 
 /**
  * GstWebRTCSignalingState:
- * GST_WEBRTC_SIGNALING_STATE_STABLE: stable
- * GST_WEBRTC_SIGNALING_STATE_CLOSED: closed
- * GST_WEBRTC_SIGNALING_STATE_HAVE_LOCAL_OFFER: have-local-offer
- * GST_WEBRTC_SIGNALING_STATE_HAVE_REMOTE_OFFER: have-remote-offer
- * GST_WEBRTC_SIGNALING_STATE_HAVE_LOCAL_PRANSWER: have-local-pranswer
- * GST_WEBRTC_SIGNALING_STATE_HAVE_REMOTE_PRANSWER: have-remote-pranswer
+ * @GST_WEBRTC_SIGNALING_STATE_STABLE: stable
+ * @GST_WEBRTC_SIGNALING_STATE_CLOSED: closed
+ * @GST_WEBRTC_SIGNALING_STATE_HAVE_LOCAL_OFFER: have-local-offer
+ * @GST_WEBRTC_SIGNALING_STATE_HAVE_REMOTE_OFFER: have-remote-offer
+ * @GST_WEBRTC_SIGNALING_STATE_HAVE_LOCAL_PRANSWER: have-local-pranswer
+ * @GST_WEBRTC_SIGNALING_STATE_HAVE_REMOTE_PRANSWER: have-remote-pranswer
  *
- * See <ulink url="http://w3c.github.io/webrtc-pc/#dom-rtcsignalingstate">http://w3c.github.io/webrtc-pc/#dom-rtcsignalingstate</ulink>
+ * See <http://w3c.github.io/webrtc-pc/#dom-rtcsignalingstate>
  */
 typedef enum /*< underscore_name=gst_webrtc_signaling_state >*/
 {
@@ -128,14 +133,14 @@ typedef enum /*< underscore_name=gst_webrtc_signaling_state >*/
 
 /**
  * GstWebRTCPeerConnectionState:
- * GST_WEBRTC_PEER_CONNECTION_STATE_NEW: new
- * GST_WEBRTC_PEER_CONNECTION_STATE_CONNECTING: connecting
- * GST_WEBRTC_PEER_CONNECTION_STATE_CONNECTED: connected
- * GST_WEBRTC_PEER_CONNECTION_STATE_DISCONNECTED: disconnected
- * GST_WEBRTC_PEER_CONNECTION_STATE_FAILED: failed
- * GST_WEBRTC_PEER_CONNECTION_STATE_CLOSED: closed
+ * @GST_WEBRTC_PEER_CONNECTION_STATE_NEW: new
+ * @GST_WEBRTC_PEER_CONNECTION_STATE_CONNECTING: connecting
+ * @GST_WEBRTC_PEER_CONNECTION_STATE_CONNECTED: connected
+ * @GST_WEBRTC_PEER_CONNECTION_STATE_DISCONNECTED: disconnected
+ * @GST_WEBRTC_PEER_CONNECTION_STATE_FAILED: failed
+ * @GST_WEBRTC_PEER_CONNECTION_STATE_CLOSED: closed
  *
- * See <ulink url="http://w3c.github.io/webrtc-pc/#dom-rtcpeerconnectionstate">http://w3c.github.io/webrtc-pc/#dom-rtcpeerconnectionstate</ulink>
+ * See <http://w3c.github.io/webrtc-pc/#dom-rtcpeerconnectionstate>
  */
 typedef enum /*< underscore_name=gst_webrtc_peer_connection_state >*/
 {
@@ -149,8 +154,8 @@ typedef enum /*< underscore_name=gst_webrtc_peer_connection_state >*/
 
 /**
  * GstWebRTCICERole:
- * GST_WEBRTC_ICE_ROLE_CONTROLLED: controlled
- * GST_WEBRTC_ICE_ROLE_CONTROLLING: controlling
+ * @GST_WEBRTC_ICE_ROLE_CONTROLLED: controlled
+ * @GST_WEBRTC_ICE_ROLE_CONTROLLING: controlling
  */
 typedef enum /*< underscore_name=gst_webrtc_ice_role >*/
 {
@@ -160,8 +165,8 @@ typedef enum /*< underscore_name=gst_webrtc_ice_role >*/
 
 /**
  * GstWebRTCICEComponent:
- * GST_WEBRTC_ICE_COMPONENT_RTP,
- * GST_WEBRTC_ICE_COMPONENT_RTCP,
+ * @GST_WEBRTC_ICE_COMPONENT_RTP: RTP component
+ * @GST_WEBRTC_ICE_COMPONENT_RTCP: RTCP component
  */
 typedef enum /*< underscore_name=gst_webrtc_ice_component >*/
 {
@@ -171,12 +176,12 @@ typedef enum /*< underscore_name=gst_webrtc_ice_component >*/
 
 /**
  * GstWebRTCSDPType:
- * GST_WEBRTC_SDP_TYPE_OFFER: offer
- * GST_WEBRTC_SDP_TYPE_PRANSWER: pranswer
- * GST_WEBRTC_SDP_TYPE_ANSWER: answer
- * GST_WEBRTC_SDP_TYPE_ROLLBACK: rollback
+ * @GST_WEBRTC_SDP_TYPE_OFFER: offer
+ * @GST_WEBRTC_SDP_TYPE_PRANSWER: pranswer
+ * @GST_WEBRTC_SDP_TYPE_ANSWER: answer
+ * @GST_WEBRTC_SDP_TYPE_ROLLBACK: rollback
  *
- * See <ulink url="http://w3c.github.io/webrtc-pc/#rtcsdptype">http://w3c.github.io/webrtc-pc/#rtcsdptype</ulink>
+ * See <http://w3c.github.io/webrtc-pc/#rtcsdptype>
  */
 typedef enum /*< underscore_name=gst_webrtc_sdp_type >*/
 {
@@ -187,12 +192,12 @@ typedef enum /*< underscore_name=gst_webrtc_sdp_type >*/
 } GstWebRTCSDPType;
 
 /**
- * GstWebRTCRtpTransceiverDirection:
- * GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_NONE: none
- * GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_INACTIVE: inactive
- * GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDONLY: sendonly
- * GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_RECVONLY: recvonly
- * GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDRECV: sendrecv
+ * GstWebRTCRTPTransceiverDirection:
+ * @GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_NONE: none
+ * @GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_INACTIVE: inactive
+ * @GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDONLY: sendonly
+ * @GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_RECVONLY: recvonly
+ * @GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDRECV: sendrecv
  */
 typedef enum /*< underscore_name=gst_webrtc_rtp_transceiver_direction >*/
 {
@@ -205,10 +210,10 @@ typedef enum /*< underscore_name=gst_webrtc_rtp_transceiver_direction >*/
 
 /**
  * GstWebRTCDTLSSetup:
- * GST_WEBRTC_DTLS_SETUP_NONE: none
- * GST_WEBRTC_DTLS_SETUP_ACTPASS: actpass
- * GST_WEBRTC_DTLS_SETUP_ACTIVE: sendonly
- * GST_WEBRTC_DTLS_SETUP_PASSIVE: recvonly
+ * @GST_WEBRTC_DTLS_SETUP_NONE: none
+ * @GST_WEBRTC_DTLS_SETUP_ACTPASS: actpass
+ * @GST_WEBRTC_DTLS_SETUP_ACTIVE: sendonly
+ * @GST_WEBRTC_DTLS_SETUP_PASSIVE: recvonly
  */
 typedef enum /*< underscore_name=gst_webrtc_dtls_setup >*/
 {
@@ -220,20 +225,20 @@ typedef enum /*< underscore_name=gst_webrtc_dtls_setup >*/
 
 /**
  * GstWebRTCStatsType:
- * GST_WEBRTC_STATS_CODEC: codec
- * GST_WEBRTC_STATS_INBOUND_RTP: inbound-rtp
- * GST_WEBRTC_STATS_OUTBOUND_RTP: outbound-rtp
- * GST_WEBRTC_STATS_REMOTE_INBOUND_RTP: remote-inbound-rtp
- * GST_WEBRTC_STATS_REMOTE_OUTBOUND_RTP: remote-outbound-rtp
- * GST_WEBRTC_STATS_CSRC: csrc
- * GST_WEBRTC_STATS_PEER_CONNECTION: peer-connectiion
- * GST_WEBRTC_STATS_DATA_CHANNEL: data-channel
- * GST_WEBRTC_STATS_STREAM: stream
- * GST_WEBRTC_STATS_TRANSPORT: transport
- * GST_WEBRTC_STATS_CANDIDATE_PAIR: candidate-pair
- * GST_WEBRTC_STATS_LOCAL_CANDIDATE: local-candidate
- * GST_WEBRTC_STATS_REMOTE_CANDIDATE: remote-candidate
- * GST_WEBRTC_STATS_CERTIFICATE: certificate
+ * @GST_WEBRTC_STATS_CODEC: codec
+ * @GST_WEBRTC_STATS_INBOUND_RTP: inbound-rtp
+ * @GST_WEBRTC_STATS_OUTBOUND_RTP: outbound-rtp
+ * @GST_WEBRTC_STATS_REMOTE_INBOUND_RTP: remote-inbound-rtp
+ * @GST_WEBRTC_STATS_REMOTE_OUTBOUND_RTP: remote-outbound-rtp
+ * @GST_WEBRTC_STATS_CSRC: csrc
+ * @GST_WEBRTC_STATS_PEER_CONNECTION: peer-connectiion
+ * @GST_WEBRTC_STATS_DATA_CHANNEL: data-channel
+ * @GST_WEBRTC_STATS_STREAM: stream
+ * @GST_WEBRTC_STATS_TRANSPORT: transport
+ * @GST_WEBRTC_STATS_CANDIDATE_PAIR: candidate-pair
+ * @GST_WEBRTC_STATS_LOCAL_CANDIDATE: local-candidate
+ * @GST_WEBRTC_STATS_REMOTE_CANDIDATE: remote-candidate
+ * @GST_WEBRTC_STATS_CERTIFICATE: certificate
  */
 typedef enum /*< underscore_name=gst_webrtc_stats_type >*/
 {
@@ -255,8 +260,10 @@ typedef enum /*< underscore_name=gst_webrtc_stats_type >*/
 
 /**
  * GstWebRTCFECType:
- * GST_WEBRTC_FEC_TYPE_NONE: none
- * GST_WEBRTC_FEC_TYPE_ULP_RED: ulpfec + red
+ * @GST_WEBRTC_FEC_TYPE_NONE: none
+ * @GST_WEBRTC_FEC_TYPE_ULP_RED: ulpfec + red
+ *
+ * Since: 1.14.1
  */
 typedef enum /*< underscore_name=gst_webrtc_fec_type >*/
 {
@@ -264,4 +271,99 @@ typedef enum /*< underscore_name=gst_webrtc_fec_type >*/
   GST_WEBRTC_FEC_TYPE_ULP_RED,
 } GstWebRTCFECType;
 
+/**
+ * GstWebRTCSCTPTransportState:
+ * GST_WEBRTC_SCTP_TRANSPORT_STATE_NEW: new
+ * GST_WEBRTC_SCTP_TRANSPORT_STATE_CONNECTING: connecting
+ * GST_WEBRTC_SCTP_TRANSPORT_STATE_CONNECTED: connected
+ * GST_WEBRTC_SCTP_TRANSPORT_STATE_CLOSED: closed
+ *
+ * See <http://w3c.github.io/webrtc-pc/#dom-rtcsctptransportstate>
+ *
+ * Since: 1.16
+ */
+typedef enum /*< underscore_name=gst_webrtc_sctp_transport_state >*/
+{
+  GST_WEBRTC_SCTP_TRANSPORT_STATE_NEW,
+  GST_WEBRTC_SCTP_TRANSPORT_STATE_CONNECTING,
+  GST_WEBRTC_SCTP_TRANSPORT_STATE_CONNECTED,
+  GST_WEBRTC_SCTP_TRANSPORT_STATE_CLOSED,
+} GstWebRTCSCTPTransportState;
+
+/**
+ * GstWebRTCPriorityType:
+ * GST_WEBRTC_PRIORITY_TYPE_VERY_LOW: very-low
+ * GST_WEBRTC_PRIORITY_TYPE_LOW: low
+ * GST_WEBRTC_PRIORITY_TYPE_MEDIUM: medium
+ * GST_WEBRTC_PRIORITY_TYPE_HIGH: high
+ *
+ * See <http://w3c.github.io/webrtc-pc/#dom-rtcprioritytype>
+ *
+ * Since: 1.16
+ */
+typedef enum /*< underscore_name=gst_webrtc_priority_type >*/
+{
+  GST_WEBRTC_PRIORITY_TYPE_VERY_LOW = 1,
+  GST_WEBRTC_PRIORITY_TYPE_LOW,
+  GST_WEBRTC_PRIORITY_TYPE_MEDIUM,
+  GST_WEBRTC_PRIORITY_TYPE_HIGH,
+} GstWebRTCPriorityType;
+
+/**
+ * GstWebRTCDataChannelState:
+ * GST_WEBRTC_DATA_CHANNEL_STATE_NEW: new
+ * GST_WEBRTC_DATA_CHANNEL_STATE_CONNECTING: connection
+ * GST_WEBRTC_DATA_CHANNEL_STATE_OPEN: open
+ * GST_WEBRTC_DATA_CHANNEL_STATE_CLOSING: closing
+ * GST_WEBRTC_DATA_CHANNEL_STATE_CLOSED: closed
+ *
+ * See <http://w3c.github.io/webrtc-pc/#dom-rtcdatachannelstate>
+ *
+ * Since: 1.16
+ */
+typedef enum /*< underscore_name=gst_webrtc_data_channel_state >*/
+{
+  GST_WEBRTC_DATA_CHANNEL_STATE_NEW,
+  GST_WEBRTC_DATA_CHANNEL_STATE_CONNECTING,
+  GST_WEBRTC_DATA_CHANNEL_STATE_OPEN,
+  GST_WEBRTC_DATA_CHANNEL_STATE_CLOSING,
+  GST_WEBRTC_DATA_CHANNEL_STATE_CLOSED,
+} GstWebRTCDataChannelState;
+
+/**
+ * GstWebRTCBundlePolicy:
+ * GST_WEBRTC_BUNDLE_POLICY_NONE: none
+ * GST_WEBRTC_BUNDLE_POLICY_BALANCED: balanced
+ * GST_WEBRTC_BUNDLE_POLICY_MAX_COMPAT: max-compat
+ * GST_WEBRTC_BUNDLE_POLICY_MAX_BUNDLE: max-bundle
+ *
+ * See https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-24#section-4.1.1
+ * for more information.
+ *
+ * Since: 1.16
+ */
+typedef enum /*<underscore_name=gst_webrtc_bundle_policy>*/
+{
+  GST_WEBRTC_BUNDLE_POLICY_NONE,
+  GST_WEBRTC_BUNDLE_POLICY_BALANCED,
+  GST_WEBRTC_BUNDLE_POLICY_MAX_COMPAT,
+  GST_WEBRTC_BUNDLE_POLICY_MAX_BUNDLE,
+} GstWebRTCBundlePolicy;
+
+/**
+ * GstWebRTCICETransportPolicy:
+ * GST_WEBRTC_ICE_TRANSPORT_POLICY_ALL: all
+ * GST_WEBRTC_ICE_TRANSPORT_POLICY_RELAY: relay
+ *
+ * See https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-24#section-4.1.1
+ * for more information.
+ *
+ * Since: 1.16
+ */
+typedef enum /*<underscore_name=gst_webrtc_ice_transport_policy>*/
+{
+  GST_WEBRTC_ICE_TRANSPORT_POLICY_ALL,
+  GST_WEBRTC_ICE_TRANSPORT_POLICY_RELAY,
+} GstWebRTCICETransportPolicy;
+
 #endif /* __GST_WEBRTC_FWD_H__ */
diff --git a/pkgconfig/Makefile.am b/pkgconfig/Makefile.am
index 0e69cd1f8..e02e29099 100644
--- a/pkgconfig/Makefile.am
+++ b/pkgconfig/Makefile.am
@@ -6,6 +6,7 @@ pcverfiles =  \
 	gstreamer-insertbin-@GST_API_VERSION@.pc \
 	gstreamer-mpegts-@GST_API_VERSION@.pc \
 	gstreamer-player-@GST_API_VERSION@.pc \
+	gstreamer-sctp-@GST_API_VERSION@.pc \
 	gstreamer-webrtc-@GST_API_VERSION@.pc \
 	gstreamer-bad-audio-@GST_API_VERSION@.pc \
 	gstreamer-bad-video-@GST_API_VERSION@.pc
@@ -16,6 +17,7 @@ pcverfiles_uninstalled = \
 	gstreamer-insertbin-@GST_API_VERSION@-uninstalled.pc \
 	gstreamer-mpegts-@GST_API_VERSION@-uninstalled.pc \
 	gstreamer-player-@GST_API_VERSION@-uninstalled.pc \
+	gstreamer-sctp-@GST_API_VERSION@-uninstalled.pc \
 	gstreamer-webrtc-@GST_API_VERSION@-uninstalled.pc \
 	gstreamer-bad-audio-@GST_API_VERSION@-uninstalled.pc \
 	gstreamer-bad-video-@GST_API_VERSION@-uninstalled.pc
@@ -58,7 +60,8 @@ pcinfiles = \
            gstreamer-player.pc.in gstreamer-player-uninstalled.pc.in \
            gstreamer-webrtc.pc.in gstreamer-webrtc-uninstalled.pc.in \
            gstreamer-bad-audio.pc.in gstreamer-bad-audio-uninstalled.pc.in \
-           gstreamer-bad-video.pc.in gstreamer-bad-video-uninstalled.pc.in
+           gstreamer-bad-video.pc.in gstreamer-bad-video-uninstalled.pc.in \
+           gstreamer-sctp.pc.in gstreamer-sctp-uninstalled.pc.in
 
 DISTCLEANFILES = $(pcinfiles:.in=)
 EXTRA_DIST = $(pcinfiles)
diff --git a/pkgconfig/gstreamer-sctp-uninstalled.pc.in b/pkgconfig/gstreamer-sctp-uninstalled.pc.in
new file mode 100644
index 000000000..417623ae7
--- /dev/null
+++ b/pkgconfig/gstreamer-sctp-uninstalled.pc.in
@@ -0,0 +1,12 @@
+prefix=
+exec_prefix=
+libdir=${pcfiledir}/../gst-libs/gst/sctp
+includedir=${pcfiledir}/../gst-libs
+
+Name: GStreamer SCTP Library
+Description: SCTP helper functions, uninstalled
+Requires: gstreamer-@GST_API_VERSION@
+Version: @VERSION@
+Libs: -L${libdir} ${libdir}/libgstsctp-@GST_API_VERSION@.la
+Cflags: -I${includedir}
+
diff --git a/pkgconfig/gstreamer-sctp.pc.in b/pkgconfig/gstreamer-sctp.pc.in
new file mode 100644
index 000000000..ac8589763
--- /dev/null
+++ b/pkgconfig/gstreamer-sctp.pc.in
@@ -0,0 +1,12 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@/gstreamer-@GST_API_VERSION@
+
+Name: GStreamer SCTP Library
+Description: SCTP helper functions
+Requires: gstreamer-@GST_API_VERSION@
+Version: @VERSION@
+Libs: -L${libdir} -lgstsctp-@GST_API_VERSION@
+Cflags: -I${includedir}
+
-- 
2.20.1

